var tipuesearch = {"pages":[{"title":" M_attr ","text":"M_attr Developer Info John S. Urban","tags":"home","loc":"index.html"},{"title":"M_attr.f90 – M_attr","text":"Contents Modules M_attr Source Code M_attr.f90 Source Code !> !!##NAME !!    M_attr(3f) - [M_attr] control text attributes on terminals !!    (LICENSE:MIT) !! !!##SYNOPSIS !! !!      use M_attr, only : attr, attr_mode, attr_update !! !!##DESCRIPTION !!    M_attr(3f) is a Fortran module for adding attributes to terminal !!    output such as color on devices that recognize ANSI escape sequences. !! !!##MAJOR FEATURES !!   o Add text attributes with an HTML-like syntax using attr(3f). !!   o suppress the escape sequence output with attr_mode(3f). !!   o customize what strings are produced using attr_update(3f). !! !!##LIMITATIONS !!   o colors are not nestable. !!   o keywords are case-sensitive, !!   o ANSI escape sequences are not universally supported by !!     all terminal emulators; and normally should be suppressed !!     when not going to a tty device. Therefore, you should use !!     M_system::system_istty(3f) or the common Fortran extension !!     ISATTY() to set the default to \"plain\" instead of \"color\" !!     when the output file is not a conforming terminal. On basic !!     MSWindows console windows, it is best to use Windows 10+ and/or !!     the Linux mode; you may have to enable ANSI escape sequence !!     mode on MSWindows. It does work as-is with CygWin and MinGW and !!     Putty windows and mintty(1) as tested. !! !!##EXAMPLE !! !!    Sample program !! !!     program demo_M_attr !!     use M_attr, only : attr, attr_mode !!     implicit none !!     character(len=256) :: line !!     real :: value !!        write(*,'(a)')& !!        &attr('<r><W>ERROR:</W> red text on a white background</y>') !! !!        value=3.4567 !!        write(line,fmt=& !!        &'(\"<w><G>GREAT</G></w>:& !!        &The new value <Y><b>\",f8.4,\"</b></Y> is in range\")')value !!        write(*,'(a)')attr(trim(line)) !! !!        ! write same string as plain text !!        call attr_mode(manner='plain') !!        write(*,'(a)')attr(trim(line)) !! !!     end program demo_M_attr !! !!##AUTHOR !!    John S. Urban, 2020 !! !!##LICENSE !!    MIT !! !!##SEE ALSO !!    attr(3f), attr_mode(3f), attr_update(3f) !! !!    Related information: !! !!     terminfo(3c), termlib(3c), tput(1), reset(1), clear(1), !!     console_codes(4), ECMA-48, !!     https://en.wikipedia.org/wiki/ANSI_escape_code module M_attr use , intrinsic :: iso_fortran_env , only : stderr => ERROR_UNIT , stdin => INPUT_UNIT , stdout => OUTPUT_UNIT use , intrinsic :: iso_c_binding , only : c_int implicit none private public attr public attr_mode public attr_update interface attr ; module procedure attr_scalar , attr_matrix ; end interface ! direct use of constant strings character ( len = :), allocatable , save :: keywords (:) character ( len = :), allocatable , save :: values (:) character ( len = :), allocatable , save :: mono_values (:) character ( len = :), allocatable , save :: mode ! mnemonics character ( len =* ), parameter :: NL = new_line ( 'a' ) ! New line character. character ( len =* ), parameter :: ESCAPE = achar ( 27 ) ! \"\\\" character. ! codes character ( len =* ), parameter :: CODE_START = ESCAPE // '[' ! Start ANSI code, \"\". character ( len =* ), parameter :: CODE_END = 'm' ! End ANSI code, \"m\". character ( len =* ), parameter :: CODE_RESET = CODE_START // '0' // CODE_END ! Clear all styles, \"0m\". character ( len =* ), parameter :: CLEAR_DISPLAY = CODE_START // '2J' character ( len =* ), parameter :: HOME_DISPLAY = CODE_START // 'H' character ( len =* ), parameter :: BELL = achar ( 7 ) character ( len =* ), parameter :: AT_BOLD = '1' , AT_ITALIC = '3' , AT_UNDERLINE = '4' , AT_INVERSE = '7' character ( len =* ), parameter :: BLACK = '0' , RED = '1' , GREEN = '2' , YELLOW = '3' , BLUE = '4' , MAGENTA = '5' , CYAN = '6' , WHITE = '7' , DEFAULT = '9' !prefixes character ( len =* ), parameter :: FG = '3' character ( len =* ), parameter :: BG = '4' character ( len =* ), parameter :: FG_INTENSE = '9' character ( len =* ), parameter :: BG_INTENSE = '10' character ( len =* ), parameter :: ON = '' character ( len =* ), parameter :: OFF = '2' ! foreground colors character ( len =* ), parameter , public :: fg_red = CODE_START // FG // RED // CODE_END character ( len =* ), parameter , public :: fg_cyan = CODE_START // FG // CYAN // CODE_END character ( len =* ), parameter , public :: fg_magenta = CODE_START // FG // MAGENTA // CODE_END character ( len =* ), parameter , public :: fg_blue = CODE_START // FG // BLUE // CODE_END character ( len =* ), parameter , public :: fg_green = CODE_START // FG // GREEN // CODE_END character ( len =* ), parameter , public :: fg_yellow = CODE_START // FG // YELLOW // CODE_END character ( len =* ), parameter , public :: fg_white = CODE_START // FG // WHITE // CODE_END character ( len =* ), parameter , public :: fg_ebony = CODE_START // FG // BLACK // CODE_END character ( len =* ), parameter , public :: fg_black = CODE_START // FG // BLACK // CODE_END character ( len =* ), parameter , public :: fg_default = CODE_START // FG // DEFAULT // CODE_END ! background colors character ( len =* ), parameter , public :: bg_red = CODE_START // BG // RED // CODE_END character ( len =* ), parameter , public :: bg_cyan = CODE_START // BG // CYAN // CODE_END character ( len =* ), parameter , public :: bg_magenta = CODE_START // BG // MAGENTA // CODE_END character ( len =* ), parameter , public :: bg_blue = CODE_START // BG // BLUE // CODE_END character ( len =* ), parameter , public :: bg_green = CODE_START // BG // GREEN // CODE_END character ( len =* ), parameter , public :: bg_yellow = CODE_START // BG // YELLOW // CODE_END character ( len =* ), parameter , public :: bg_white = CODE_START // BG // WHITE // CODE_END character ( len =* ), parameter , public :: bg_ebony = CODE_START // BG // BLACK // CODE_END character ( len =* ), parameter , public :: bg_black = CODE_START // BG // BLACK // CODE_END character ( len =* ), parameter , public :: bg_default = CODE_START // BG // DEFAULT // CODE_END ! attributes character ( len =* ), parameter , public :: bold = CODE_START // ON // AT_BOLD // CODE_END character ( len =* ), parameter , public :: italic = CODE_START // ON // AT_ITALIC // CODE_END character ( len =* ), parameter , public :: inverse = CODE_START // ON // AT_INVERSE // CODE_END character ( len =* ), parameter , public :: underline = CODE_START // ON // AT_UNDERLINE // CODE_END character ( len =* ), parameter , public :: unbold = CODE_START // OFF // AT_BOLD // CODE_END character ( len =* ), parameter , public :: unitalic = CODE_START // OFF // AT_ITALIC // CODE_END character ( len =* ), parameter , public :: uninverse = CODE_START // OFF // AT_INVERSE // CODE_END character ( len =* ), parameter , public :: ununderline = CODE_START // OFF // AT_UNDERLINE // CODE_END character ( len =* ), parameter , public :: reset = CODE_RESET character ( len =* ), parameter , public :: clear = HOME_DISPLAY // CLEAR_DISPLAY private locate ! find PLACE in sorted character array where value can be found or should be placed private insert ! insert entry into a sorted allocatable array at specified position private replace ! replace entry by index from a sorted allocatable array if it is present private remove ! delete entry by index from a sorted allocatable array if it is present contains !> !!##NAME !!    attr(3f) - [M_attr] substitute escape sequences for HTML-like syntax !!               in strings !!    (LICENSE:MIT) !! !!##SYNOPSIS !! !!      function attr(string,clear_at_end) result (expanded) !!      ! scalar !!        character(len=*),intent(in) :: string !!        logical,intent(in),optional :: clear_at_end !!        character(len=:),allocatable :: expanded !!      ! or array !!        character(len=*),intent(in) :: string(:) !!        logical,intent(in),optional :: clear_at_end !!        character(len=:),allocatable :: expanded(:) !! !!##DESCRIPTION !!    Use HTML-like syntax to add attributes to terminal output such as color !!    on devices that recognize ANSI escape sequences. !! !!##OPTIONS !!    string        input string  of form !! !!                    \"<attribute_name>string</attribute_name> ...\". !! !!                   where the current attributes are color names, !!                   bold, italic, underline, ... !! !!    clear_at_end   By default, a sequence to clear all text attributes !!                   is sent at the end of the returned text if an escape !!                   character appears in the output string. This can be !!                   turned off by setting this value to false. Each line !!                   being self-contained has advantages when output is !!                   filtered with commands such as grep(1). !!##KEYWORDS !!    primary default keywords !! !!      colors: !!        r,         red,       R,  RED !!        g,         green,     G,  GREEN !!        b,         blue,      B,  BLUE !!        m,         magenta,   M,  MAGENTA !!        c,         cyan,      C,  CYAN !!        y,         yellow,    Y,  YELLOW !!        e,         ebony,     E,  EBONY !!        w,         white,     W,  WHITE !!      attributes: !!        it,        italic !!        bo,        bold !!        un,        underline !!       other: !!        clear !!        escape !!        default !!        reset !!        gt !!        lt !!      dual-value (one for color, one for mono): !!        ERROR !!        WARNING !!        INFO !! !!    By default, if the color mnemonics (ie. the keywords) are uppercase !!    they change the background color. If lowercase, the foreground color. !!    When preceded by a \"/\" character the attribute is returned to the default. !! !!    The \"default\" keyword is typically used explicitly when !!    clear_at_end=.false, and sets all text attributes to their initial defaults. !! !!##LIMITATIONS !!    o colors are not nestable, keywords are case-sensitive, !!    o not all terminals obey the sequences. On Windows, it is best if !!      you use Windows 10+ and/or the Linux mode; although it has worked !!      with all CygWin and MinGW and Putty windows and mintty. !!    o you should use \"<gt>\" and \"<lt>\" instead of \">\" and \"<\" in a string !!      processed by attr(3f) instead of in any plain text output so that !!      the raw mode will create correct input for the attr(3f) function !!      if read back in. !! !!##EXAMPLE !! !!    Sample program !! !!     program demo_esc !!     use M_attr, only : attr, attr_mode, attr_update !!        call printstuff('defaults') !! !!        call attr_mode(manner='plain') !!        call printstuff('plain:') !! !!        call printstuff('raw:') !! !!        call attr_mode(manner='color') !!        call printstuff('') !! !!        write(*,'(a)') attr('TEST ADDING A CUSTOM SEQUENCE:') !!        call attr_update('blink',char(27)//'[5m') !!        call attr_update('/blink',char(27)//'[38m') !!        write(*,'(a)') attr('<blink>Items for Friday</blink>') !! !!     contains !!     subroutine printstuff(label) !!     character(len=*),intent(in) :: label !!       call attr_mode(manner=label) !!       write(*,'(a)') attr('TEST MANNER='//label) !!       write(*,'(a)') attr('<r>RED</r>,<g>GREEN</g>,<b>BLUE</b>') !!       write(*,'(a)') attr('<c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y>') !!       write(*,'(a)') attr('<w>WHITE</w> and <e>EBONY</e>') !! !!       write(*,'(a)') attr('Adding <bo>bold</bo>') !!       write(*,'(a)') attr('<bo><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></bo>') !!       write(*,'(a)') attr('<bo><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y></bo>') !!       write(*,'(a)') attr('<bo><w>WHITE</w> and <e>EBONY</e></bo>') !! !!       write(*,'(a)') attr('Adding <ul>underline</ul>') !!       write(*,'(a)') attr(& !!        &'<bo><ul><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></ul></bo>') !!       write(*,'(a)') attr(& !!        &'<bo><ul><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y></ul></bo>') !!       write(*,'(a)') attr('<bo><ul><w>WHITE</w> and <e>EBONY</e></ul></bo>') !! !!       write(*,'(a)') attr('Adding <ul>italic</ul>') !!       write(*,'(a)') attr(& !!        &'<bo><ul><it><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></it></ul></bo>') !!       write(*,'(a)') attr(& !!        &'<bo><ul><it><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</it></y></ul></bo>') !!       write(*,'(a)') attr('<bo><ul><it><w>WHITE</w> and <e>EBONY</e></ul></bo>') !! !!       write(*,'(a)') attr('Adding <in>inverse</in>') !!       write(*,'(a)') attr(& !!        &'<in><bo><ul><it><r>RED</r>,<g>GREEN</g>,& !!        &<b>BLUE</b></it></ul></bo></in>') !!       write(*,'(a)') attr(& !!        &'<in><bo><ul><it><c>CYAN</c>,<m>MAGENTA</g>,& !!        &<y>YELLOW</it></y></ul></bo></in>') !!       write(*,'(a)') attr(& !!        &'<in><bo><ul><it><w>WHITE</w> and <e>EBONY</e></ul></bo></in>') !!     end subroutine printstuff !! !!     end program demo_esc !! !!##AUTHOR !!    John S. Urban, 2020 !! !!##LICENSE !!    MIT !! !!##SEE ALSO !!    attr_mode(3f), attr_update(3f) function attr_scalar ( string , clear_at_end ) result ( expanded ) character ( len =* ), intent ( in ) :: string logical , intent ( in ), optional :: clear_at_end logical :: clear_at_end_local character ( len = :), allocatable :: padded character ( len = :), allocatable :: expanded character ( len = :), allocatable :: name integer :: i integer :: ii integer :: maxlen integer :: place if ( present ( clear_at_end )) then clear_at_end_local = clear_at_end else clear_at_end_local = . false . endif if (. not . allocated ( mode )) then ! set substitution mode mode = 'color' ! 'color'|'raw'|'plain' call vt102 () endif if ( mode == 'raw' ) then expanded = string return endif maxlen = len ( string ) padded = string // ' ' i = 1 expanded = '' do select case ( padded ( i : i )) case ( '>' ) ! should not get here unless unmatched i = i + 1 expanded = expanded // '>' case ( '<' ) ! assuming not nested for now ii = index ( padded ( i + 1 :), '>' ) if ( ii . eq . 0 ) then expanded = expanded // '<' i = i + 1 else name = padded ( i + 1 : i + ii - 1 ) name = trim ( adjustl ( name )) call locate ( keywords , name , place ) if ( mode . eq . 'plain' ) then expanded = expanded // get ( name ) elseif ( place . le . 0 ) then ! unknown name; print what you found expanded = expanded // padded ( i : i + ii ) else expanded = expanded // get ( name ) endif i = ii + i + 1 endif case default expanded = expanded // padded ( i : i ) i = i + 1 end select if ( i >= maxlen + 1 ) exit enddo if ( ( index ( expanded , escape ). ne . 0 ). and .(. not . clear_at_end_local )) then if (( mode . ne . 'raw' ). and .( mode . ne . 'plain' )) then expanded = expanded // CODE_RESET ! Clear all styles endif endif end function attr_scalar function attr_matrix ( string , clear_at_end ) result ( expanded ) character ( len =* ), intent ( in ) :: string (:) logical , intent ( in ), optional :: clear_at_end character ( len = :), allocatable :: expanded (:) character ( len = :), allocatable :: hold integer :: i allocate ( character ( len = 0 ) :: expanded ( 0 )) do i = 1 , size ( string ) hold = attr_scalar ( string ( i )) expanded = [ character ( len = max ( len ( expanded ), len ( hold ))) :: expanded , hold ] enddo end function attr_matrix subroutine vt102 () ! create a dictionary with character keywords, values, and value lengths ! using the routines for maintaining a list call wipe_dictionary () ! insert and replace entries call attr_update ( 'bold' , bold ) call attr_update ( '/bold' , unbold ) call attr_update ( 'bo' , bold ) call attr_update ( '/bo' , unbold ) call attr_update ( 'livid' , bold ) call attr_update ( '/livid' , unbold ) call attr_update ( 'li' , bold ) call attr_update ( '/li' , unbold ) call attr_update ( 'italic' , italic ) call attr_update ( '/italic' , unitalic ) call attr_update ( 'it' , italic ) call attr_update ( '/it' , unitalic ) call attr_update ( 'inverse' , inverse ) call attr_update ( '/inverse' , uninverse ) call attr_update ( 'in' , inverse ) call attr_update ( '/in' , uninverse ) call attr_update ( 'underline' , underline ) call attr_update ( '/underline' , ununderline ) call attr_update ( 'un' , underline ) call attr_update ( '/un' , ununderline ) call attr_update ( 'ul' , underline ) call attr_update ( '/ul' , ununderline ) call attr_update ( 'attr' , ESCAPE ) call attr_update ( 'escape' , ESCAPE ) call attr_update ( 'clear' , clear ) call attr_update ( 'reset' , reset ) call attr_update ( 'bell' , BELL ) call attr_update ( 'gt' , '>' ) call attr_update ( 'lt' , '<' ) ! foreground colors call attr_update ( 'r' , fg_red ) call attr_update ( '/r' , fg_default ) call attr_update ( 'red' , fg_red ) call attr_update ( '/red' , fg_default ) call attr_update ( 'c' , fg_cyan ) call attr_update ( '/c' , fg_default ) call attr_update ( 'cyan' , fg_cyan ) call attr_update ( '/cyan' , fg_default ) call attr_update ( 'm' , fg_magenta ) call attr_update ( '/m' , fg_default ) call attr_update ( 'magenta' , fg_magenta ) call attr_update ( '/magenta' , fg_default ) call attr_update ( 'b' , fg_blue ) call attr_update ( '/b' , fg_default ) call attr_update ( 'blue' , fg_blue ) call attr_update ( '/blue' , fg_default ) call attr_update ( 'g' , fg_green ) call attr_update ( '/g' , fg_default ) call attr_update ( 'green' , fg_green ) call attr_update ( '/green' , fg_default ) call attr_update ( 'y' , fg_yellow ) call attr_update ( '/y' , fg_default ) call attr_update ( 'yellow' , fg_yellow ) call attr_update ( '/yellow' , fg_default ) call attr_update ( 'w' , fg_white ) call attr_update ( '/w' , fg_default ) call attr_update ( 'white' , fg_white ) call attr_update ( '/white' , fg_default ) call attr_update ( 'e' , fg_ebony ) call attr_update ( '/e' , fg_default ) call attr_update ( 'ebony' , fg_ebony ) call attr_update ( '/ebony' , fg_default ) call attr_update ( 'x' , fg_ebony ) call attr_update ( '/x' , fg_default ) call attr_update ( 'black' , fg_ebony ) call attr_update ( '/black' , fg_default ) ! background colors call attr_update ( 'R' , bg_red ) call attr_update ( '/R' , bg_default ) call attr_update ( 'RED' , bg_red ) call attr_update ( '/RED' , bg_default ) call attr_update ( 'C' , bg_cyan ) call attr_update ( '/C' , bg_default ) call attr_update ( 'CYAN' , bg_cyan ) call attr_update ( '/CYAN' , bg_default ) call attr_update ( 'M' , bg_magenta ) call attr_update ( '/M' , bg_default ) call attr_update ( 'MAGENTA' , bg_magenta ) call attr_update ( '/MAGENTA' , bg_default ) call attr_update ( 'B' , bg_blue ) call attr_update ( '/B' , bg_default ) call attr_update ( 'BLUE' , bg_blue ) call attr_update ( '/BLUE' , bg_default ) call attr_update ( 'G' , bg_green ) call attr_update ( '/G' , bg_default ) call attr_update ( 'GREEN' , bg_green ) call attr_update ( '/GREEN' , bg_default ) call attr_update ( 'Y' , bg_yellow ) call attr_update ( '/Y' , bg_default ) call attr_update ( 'YELLOW' , bg_yellow ) call attr_update ( '/YELLOW' , bg_default ) call attr_update ( 'W' , bg_white ) call attr_update ( '/W' , bg_default ) call attr_update ( 'WHITE' , bg_white ) call attr_update ( '/WHITE' , bg_default ) call attr_update ( 'E' , bg_ebony ) call attr_update ( '/E' , bg_default ) call attr_update ( 'EBONY' , bg_ebony ) call attr_update ( '/EBONY' , bg_default ) call attr_update ( 'X' , bg_ebony ) call attr_update ( '/X' , bg_default ) call attr_update ( 'BLACK' , bg_ebony ) call attr_update ( '/BLACK' , bg_default ) call attr_update ( 'ERROR' , fg_red // bold // bg_ebony // 'error:' // bg_default // fg_default , 'ERROR:' ) call attr_update ( 'WARNING' , fg_magenta // bold // bg_ebony // 'warning:' // bg_default // fg_default , 'WARNING:' ) call attr_update ( 'INFO' , fg_yellow // bold // bg_ebony // 'info:' // bg_default // fg_default , 'INFO:' ) end subroutine vt102 !> !! !> !!##NAME !!    attr_mode(3f) - [M_attr] select processing mode for output from attr(3f) !!    (LICENSE:MIT) !! !!##SYNOPSIS !! !! !!     subroutine attr_mode(manner) !! !!        character(len=*),intent(in) :: manner !! !!##DESCRIPTION !!    Turn off the generation of strings associated with the HTML keywords !!    in the string generated by the attr(3f) function, or display the !!    text in raw mode as it was passed to attr(3f) or return to ANSI !!    escape control sequence generation. !! !!##OPTIONS !!    MANNER  The current manners or modes supported via the attr_mode(3f) !!             procedure are !! !!         plain          suppress the output associated with keywords !!         color(default) commonly supported escape sequences !!         raw            echo the input to attr(3f) as its output !!         reload         restore original keyword meanings deleted or !!                        replaced by calls to attr_update(3f). !! !!##EXAMPLE !! !! !!    Sample program !! !!     program demo_attr_mode !!     use M_attr, only : attr, attr_mode !!     implicit none !!     character(len=1024) :: line !!     real :: value !! !!       value=3.4567 !!       if( (value>0.0) .and. (value<100.0))then !!         write(line,fmt='(\"& !!        &<w><G>GREAT</G></w>: The value <Y><b>\",f8.4,\"</b></Y> is in range & !!        &\")')value !!       else !!         write(line,fmt='(\"& !!        &<R><e>ERROR</e></R>:The new value <Y><b>\",g0,\"</b></Y> is out of range& !!        & \")')value !!       endif !! !!       write(*,'(a)')attr(trim(line)) !! !!       call attr_mode(manner='plain') ! write as plain text !!       write(*,'(a)')attr(trim(line)) !!       call attr_mode(manner='raw')   ! write as-is !!       write(*,'(a)')attr(trim(line)) !!       call attr_mode(manner='ansi')  ! return to default mode !!       write(*,'(a)')attr(trim(line)) !! !!     end program demo_attr_mode !! !!##AUTHOR !!    John S. Urban, 2020 !! !!##LICENSE !!    MIT subroutine attr_mode ( manner ) character ( len =* ), intent ( in ) :: manner integer :: i if (. not . allocated ( mode )) then ! set substitution mode mode = 'color' call vt102 () endif select case ( manner ) case ( 'vt102' , 'ANSI' , 'ansi' , 'color' , 'COLOR' ) mode = 'color' case ( 'reload' , 'default' , 'defaults' , '' ) call vt102 () mode = 'color' case ( 'raw' ) mode = 'raw' case ( 'dump' ) ! dump dictionary for debugging if ( allocated ( keywords )) then if ( size ( keywords ). gt . 0 ) then write ( stderr , '(*(a,t30,a))' ) 'KEYWORD' , 'VALUE' write ( stderr , '(*(a,t30,2(\"[\",a,\"]\"),/))' )( trim ( keywords ( i )), values ( i ), mono_values ( i ), i = 1 , size ( keywords )) endif endif case ( 'dummy' , 'plain' , 'text' ) mode = 'plain' case default write ( * , * ) 'unknown manner. Try color|raw|plain' mode = 'color' end select end subroutine attr_mode subroutine wipe_dictionary () if ( allocated ( keywords )) deallocate ( keywords ) allocate ( character ( len = 0 ) :: keywords ( 0 )) if ( allocated ( values )) deallocate ( values ) allocate ( character ( len = 0 ) :: values ( 0 )) if ( allocated ( mono_values )) deallocate ( mono_values ) allocate ( character ( len = 0 ) :: mono_values ( 0 )) end subroutine wipe_dictionary !> !! !> !!##NAME !!    attr_update(3f) - [M_attr] update internal dictionary given keyword and value !!    (LICENSE:MIT) !! !!##SYNOPSIS !! !! !!    subroutine attr_update(key,val) !! !!     character(len=*),intent(in)           :: key !!     character(len=*),intent(in),optional  :: val !!     character(len=*),intent(in),optional  :: mono_val !! !!##DESCRIPTION !!    Update internal dictionary in M_attr(3fm) module. !! !!##OPTIONS !!    key       name of keyword to add, replace, or delete from dictionary !!    val       if present add or replace value associated with keyword. If !!              not present remove keyword entry from dictionary. !!    mono_val  if present add or replace second value associated with !!              keyword used for plain text mode. !!              Must only be specified if VAL is also specified. !! !!##KEYWORDS !!    The following keywords are defined by default !! !!    colors: !! !!      r,red     c,cyan     w,white !!      g,green   m,magenta  e,ebony !!      b,blue    y,yellow !! !!    If the color keywords are capitalized they control the text background !!    instead of the text color. !! !!    attributes: !! !!      ul,underline !!      it,italics (often produces inverse colors on many devices !! !!##EXAMPLE !! !! !!    Sample program !! !!     program demo_update !!     use M_attr, only : attr, attr_update !!        write(*,'(a)') attr('<clear>TEST CUSTOMIZED:') !!        ! add custom keywords !!        call attr_update('blink',char(27)//'[5m') !!        call attr_update('/blink',char(27)//'[38m') !! !!        write(*,'(a)') attr('<blink>Items for Friday</blink>') !! !!        write(*,'(a)',advance='no') attr('<r>RED</r>,') !!        write(*,'(a)',advance='no') attr('<b>BLUE</b>,') !!        write(*,'(a)',advance='yes') attr('<g>GREEN</g>') !! !!        ! delete !!        call attr_update('r') !!        call attr_update('/r') !!        ! replace !!        call attr_update('b','<<<<') !!        call attr_update('/b','>>>>') !!        write(*,'(a)',advance='no') attr('<r>RED</r>,') !!        write(*,'(a)',advance='no') attr('<b>BLUE</b>,') !!        write(*,'(a)',advance='yes') attr('<g>GREEN</g>') !! !!     end program demo_update !! !!##AUTHOR !!    John S. Urban, 2020 !! !!##LICENSE !!    MIT subroutine attr_update ( key , valin , mono_valin ) character ( len =* ), intent ( in ) :: key character ( len =* ), intent ( in ), optional :: valin character ( len =* ), intent ( in ), optional :: mono_valin integer :: place character ( len = :), allocatable :: val character ( len = :), allocatable :: mono_val if ( present ( mono_valin )) then mono_val = mono_valin else mono_val = '' endif if ( present ( valin )) then val = valin ! find where string is or should be call locate ( keywords , key , place ) ! if string was not found insert it if ( place . lt . 1 ) then call insert ( keywords , key , iabs ( place )) call insert ( values , val , iabs ( place )) call insert ( mono_values , mono_val , iabs ( place )) else call replace ( values , val , place ) call replace ( values , mono_val , place ) endif else call locate ( keywords , key , place ) if ( place . gt . 0 ) then call remove ( keywords , place ) call remove ( values , place ) call remove ( mono_values , place ) endif endif end subroutine attr_update function get ( key ) result ( valout ) character ( len =* ), intent ( in ) :: key character ( len = :), allocatable :: valout integer :: place ! find where string is or should be call locate ( keywords , key , place ) if ( place . lt . 1 ) then valout = '' else if ( mode . eq . 'plain' ) then valout = trim ( mono_values ( place )) else valout = trim ( values ( place )) endif endif end function get subroutine locate ( list , value , place , ier , errmsg ) character ( len =* ), intent ( in ) :: value integer , intent ( out ) :: place character ( len = :), allocatable :: list (:) integer , intent ( out ), optional :: ier character ( len =* ), intent ( out ), optional :: errmsg integer :: i character ( len = :), allocatable :: message integer :: arraysize integer :: maxtry integer :: imin , imax integer :: error if (. not . allocated ( list )) then list = [ character ( len = max ( len_trim ( value ), 2 )) :: ] endif arraysize = size ( list ) error = 0 if ( arraysize . eq . 0 ) then maxtry = 0 place =- 1 else maxtry = int ( log ( float ( arraysize )) / log ( 2.0 ) + 1.0 ) place = ( arraysize + 1 ) / 2 endif imin = 1 imax = arraysize message = '' LOOP : block do i = 1 , maxtry if ( value . eq . list ( PLACE )) then exit LOOP else if ( value . gt . list ( place )) then imax = place - 1 else imin = place + 1 endif if ( imin . gt . imax ) then place =- imin if ( iabs ( place ). gt . arraysize ) then ! ran off end of list. Where new value should go or an unsorted input array' exit LOOP endif exit LOOP endif place = ( imax + imin ) / 2 if ( place . gt . arraysize . or . place . le . 0 ) then message = '*locate* error: search is out of bounds of list. Probably an unsorted input array' error =- 1 exit LOOP endif enddo message = '*locate* exceeded allowed tries. Probably an unsorted input array' endblock LOOP if ( present ( ier )) then ier = error else if ( error . ne . 0 ) then write ( stderr , * ) message // ' VALUE=' , trim ( value ) // ' PLACE=' , place stop 1 endif if ( present ( errmsg )) then errmsg = message endif end subroutine locate subroutine remove ( list , place ) character ( len = :), allocatable :: list (:) integer , intent ( in ) :: place integer :: ii , end if (. not . allocated ( list )) then list = [ character ( len = 2 ) :: ] endif ii = len ( list ) end = size ( list ) if ( place . le . 0. or . place . gt . end ) then ! index out of bounds of array elseif ( place . eq . end ) then ! remove from array list = [ character ( len = ii ) :: list (: place - 1 ) ] else list = [ character ( len = ii ) :: list (: place - 1 ), list ( place + 1 :) ] endif end subroutine remove subroutine replace ( list , value , place ) character ( len =* ), intent ( in ) :: value character ( len = :), allocatable :: list (:) character ( len = :), allocatable :: kludge (:) integer , intent ( in ) :: place integer :: ii integer :: tlen integer :: end if (. not . allocated ( list )) then list = [ character ( len = max ( len_trim ( value ), 2 )) :: ] endif tlen = len_trim ( value ) end = size ( list ) if ( place . lt . 0. or . place . gt . end ) then write ( stderr , * ) '*replace* error: index out of range. end=' , end , ' index=' , place elseif ( len_trim ( value ). le . len ( list )) then list ( place ) = value else ! increase length of variable ii = max ( tlen , len ( list )) kludge = [ character ( len = ii ) :: list ] list = kludge list ( place ) = value endif end subroutine replace subroutine insert ( list , value , place ) character ( len =* ), intent ( in ) :: value character ( len = :), allocatable :: list (:) character ( len = :), allocatable :: kludge (:) integer , intent ( in ) :: place integer :: ii integer :: end if (. not . allocated ( list )) then list = [ character ( len = max ( len_trim ( value ), 2 )) :: ] endif ii = max ( len_trim ( value ), len ( list ), 2 ) end = size ( list ) if ( end . eq . 0 ) then ! empty array list = [ character ( len = ii ) :: value ] elseif ( place . eq . 1 ) then ! put in front of array kludge = [ character ( len = ii ) :: value , list ] list = kludge elseif ( place . gt . end ) then ! put at end of array kludge = [ character ( len = ii ) :: list , value ] list = kludge elseif ( place . ge . 2. and . place . le . end ) then ! put in middle of array kludge = [ character ( len = ii ) :: list (: place - 1 ), value , list ( place :) ] list = kludge else ! index out of range write ( stderr , * ) '*insert* error: index out of range. end=' , end , ' index=' , place , ' value=' , value endif end subroutine insert end module M_attr","tags":"","loc":"sourcefile/m_attr.f90.html"},{"title":"light.f90 – M_attr","text":"Contents Programs demo_attr Source Code light.f90 Source Code program demo_attr ! read stdin and run it through M_attr::attr to display color use M_attr , only : attr , attr_update implicit none character ( len = 1024 ) :: line character ( len = :), allocatable :: expanded integer :: ios line = '' call attr_update ( 'Z' , char ( 27 ) // '[1m' ) do read ( * , '(a)' , iostat = ios ) line expanded = attr ( trim ( line )) write ( * , '(a)' ) expanded if ( ios . ne . 0 ) exit enddo write ( * , '(a)' , advance = 'no' ) attr ( '<reset>' ) end program demo_attr","tags":"","loc":"sourcefile/light.f90.html"},{"title":"main.f90 – M_attr","text":"Contents Programs roots Source Code main.f90 Source Code program roots use , intrinsic :: iso_fortran_env , only : stdin => input_unit , stdout => output_unit , stderr => error_unit use M_attr , only : attr , attr_mode , attr_update ! Calculate and print the roots of a quadratic formula even if they are complex implicit none integer , parameter :: dp = kind ( 0.0d0 ) real ( kind = dp ) :: a , b , c , discriminant real ( kind = dp ) :: x1 , x2 , x ! Real roots of the equation real ( kind = dp ) :: x_real ! Real part of complex root of the equation REAL ( kind = dp ) :: x_complex ! Imaginary part of complex root of the equation character ( len = :), allocatable :: line character ( len = 256 ) :: message integer :: ios character ( len = 1 ) :: paws if ( isatty ( stdout )) then ! ISATTY() is an extension, but found in Intel, GNU, PGI, ... compiler call attr_mode ( 'color' ) else call attr_mode ( 'plain' ) endif INFINITE : do ! clear screen, set attributes and print messages line = \"<clear><B><w><bo>Enter the quadratic equation coefficients a, b and c\" write ( * , '(*(a))' , advance = 'no' ) attr ( '<B><w><bo>' // repeat ( '_' , len ( line )) // '<' ), char ( 13 ), attr ( '<B><y>ENTER>' ) read ( * , * , iostat = ios , iomsg = message ) a , b , c !write(*,'(a)',advance='no')attr('reset') if ( ios . ne . 0 ) then write ( * , '(*(g0))' ) ios , ' ' , trim ( message ) else ! Given the equation \"A*x**2 + B*x + C = 0\" ! Use the quadratic formula to determine the root values of the equation. ! prompt for new value WRITE ( * , '(*(g0))' ) 'for ' , a , '*x**2 + ' , b , '*x + ' , c , ' = 0' discriminant = b ** 2 - 4 * a * c IF ( discriminant > 0 ) THEN write ( * , * ) 'the roots (ie. \"x intercepts\") are real so the parabola crosses the x-axis at two points:' x1 = ( - b + sqrt ( discriminant )) / ( 2 * a ) x2 = ( - b - sqrt ( discriminant )) / ( 2 * a ) PRINT * , \"Real roots:\" , x1 , x2 ELSEIF ( discriminant == 0 ) THEN PRINT * , 'the roots (ie. \"x intercepts\") are repeated (real and equal) so the parabola just touches the x-axis at:' x = ( - b ) / ( 2 * a ) PRINT * , \"Two identical Real roots\" , x ELSE PRINT * , 'the roots(ie. \"x intercepts\")  are complex:' x_real = ( - b ) / ( 2 * a ) x_complex = sqrt ( abs ( discriminant )) / ( 2 * a ) PRINT * , x_real , \"+i\" , x_complex , x_real , \"-i\" , x_complex ENDIF PRINT * , \"discriminant =\" , discriminant endif write ( * , '(*(g0))' ) 'press <return> to continue, <q> to quit' read ( * , advance = 'yes' , iostat = ios , fmt = '(a)' , iomsg = message ) paws if ( paws . ne . '' ) exit INFINITE enddo INFINITE END PROGRAM roots","tags":"","loc":"sourcefile/main.f90.html"},{"title":"plain.f90 – M_attr","text":"Contents Programs demo_attr Source Code plain.f90 Source Code program demo_attr ! read stdin and run it through M_attr::attr to display without color use M_attr , only : attr , attr_mode implicit none character ( len = 1024 ) :: line integer :: ios line = '' call attr_mode ( manner = 'plain' ) do read ( * , '(a)' , iostat = ios ) line write ( * , '(a)' ) attr ( trim ( line )) if ( ios . ne . 0 ) exit enddo write ( * , '(a)' , advance = 'no' ) attr ( '<reset>' ) end program demo_attr","tags":"","loc":"sourcefile/plain.f90.html"},{"title":"demo_M_attr.f90 – M_attr","text":"Contents Programs demo_M_attr Source Code demo_M_attr.f90 Source Code program demo_M_attr use M_attr , only : attr , attr_mode implicit none character ( len = 256 ) :: line real :: value write ( * , '(a)' )& & attr ( '<r><W>ERROR:</W> red text on a white background</y>' ) value = 3.4567 write ( line , fmt = & & '(\"<w><G>GREAT</G></w>:& &The new value <Y><b>\",f8.4,\"</b></Y> is in range\")' ) value write ( * , '(a)' ) attr ( trim ( line )) ! write same string as plain text call attr_mode ( manner = 'plain' ) write ( * , '(a)' ) attr ( trim ( line )) end program demo_M_attr","tags":"","loc":"sourcefile/demo_m_attr.f90.html"},{"title":"demo_attr.f90 – M_attr","text":"Contents Programs demo_esc Source Code demo_attr.f90 Source Code program demo_esc use M_attr , only : attr , attr_mode , attr_update call printstuff ( 'defaults' ) call attr_mode ( manner = 'plain' ) call printstuff ( 'plain:' ) call printstuff ( 'raw:' ) call attr_mode ( manner = 'color' ) call printstuff ( '' ) write ( * , '(a)' ) attr ( 'TEST ADDING A CUSTOM SEQUENCE:' ) call attr_update ( 'blink' , char ( 27 ) // '[5m' ) call attr_update ( '/blink' , char ( 27 ) // '[38m' ) write ( * , '(a)' ) attr ( '<blink>Items for Friday</blink>' ) contains subroutine printstuff ( label ) character ( len =* ), intent ( in ) :: label call attr_mode ( manner = label ) write ( * , '(a)' ) attr ( 'TEST MANNER=' // label ) write ( * , '(a)' ) attr ( '<r>RED</r>,<g>GREEN</g>,<b>BLUE</b>' ) write ( * , '(a)' ) attr ( '<c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y>' ) write ( * , '(a)' ) attr ( '<w>WHITE</w> and <e>EBONY</e>' ) write ( * , '(a)' ) attr ( 'Adding <bo>bold</bo>' ) write ( * , '(a)' ) attr ( '<bo><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></bo>' ) write ( * , '(a)' ) attr ( '<bo><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y></bo>' ) write ( * , '(a)' ) attr ( '<bo><w>WHITE</w> and <e>EBONY</e></bo>' ) write ( * , '(a)' ) attr ( 'Adding <ul>underline</ul>' ) write ( * , '(a)' ) attr (& & '<bo><ul><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></ul></bo>' ) write ( * , '(a)' ) attr (& & '<bo><ul><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><w>WHITE</w> and <e>EBONY</e></ul></bo>' ) write ( * , '(a)' ) attr ( 'Adding <ul>italic</ul>' ) write ( * , '(a)' ) attr (& & '<bo><ul><it><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></it></ul></bo>' ) write ( * , '(a)' ) attr (& & '<bo><ul><it><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</it></y></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><it><w>WHITE</w> and <e>EBONY</e></ul></bo>' ) write ( * , '(a)' ) attr ( 'Adding <in>inverse</in>' ) write ( * , '(a)' ) attr (& & '<in><bo><ul><it><r>RED</r>,<g>GREEN</g>,& &<b>BLUE</b></it></ul></bo></in>' ) write ( * , '(a)' ) attr (& & '<in><bo><ul><it><c>CYAN</c>,<m>MAGENTA</g>,& &<y>YELLOW</it></y></ul></bo></in>' ) write ( * , '(a)' ) attr (& & '<in><bo><ul><it><w>WHITE</w> and <e>EBONY</e></ul></bo></in>' ) end subroutine printstuff end program demo_esc","tags":"","loc":"sourcefile/demo_attr.f90.html"},{"title":"demo_update.f90 – M_attr","text":"Contents Programs demo_update Source Code demo_update.f90 Source Code program demo_update use M_attr , only : attr , attr_update write ( * , '(a)' ) attr ( '<clear>TEST CUSTOMIZED:' ) ! add custom keywords call attr_update ( 'blink' , char ( 27 ) // '[5m' ) call attr_update ( '/blink' , char ( 27 ) // '[38m' ) write ( * , '(a)' ) attr ( '<blink>Items for Friday</blink>' ) write ( * , '(a)' , advance = 'no' ) attr ( '<r>RED</r>,' ) write ( * , '(a)' , advance = 'no' ) attr ( '<b>BLUE</b>,' ) write ( * , '(a)' , advance = 'yes' ) attr ( '<g>GREEN</g>' ) ! delete call attr_update ( 'r' ) call attr_update ( '/r' ) ! replace call attr_update ( 'b' , '<<<<' ) call attr_update ( '/b' , '>>>>' ) write ( * , '(a)' , advance = 'no' ) attr ( '<r>RED</r>,' ) write ( * , '(a)' , advance = 'no' ) attr ( '<b>BLUE</b>,' ) write ( * , '(a)' , advance = 'yes' ) attr ( '<g>GREEN</g>' ) end program demo_update","tags":"","loc":"sourcefile/demo_update.f90.html"},{"title":"demo_attr_mode.f90 – M_attr","text":"Contents Programs demo_attr_mode Source Code demo_attr_mode.f90 Source Code program demo_attr_mode use M_attr , only : attr , attr_mode implicit none character ( len = 1024 ) :: line real :: value value = 3.4567 if ( ( value > 0.0 ) . and . ( value < 10 0.0 )) then write ( line , fmt = '(\"& &<w><G>GREAT</G></w>: The value <Y><b>\",f8.4,\"</b></Y> is in range & &\")' ) value else write ( line , fmt = '(\"& &<R><e>ERROR</e></R>:The new value <Y><b>\",g0,\"</b></Y> is out of range& & \")' ) value endif write ( * , '(a)' ) attr ( trim ( line )) call attr_mode ( manner = 'plain' ) ! write as plain text write ( * , '(a)' ) attr ( trim ( line )) call attr_mode ( manner = 'raw' ) ! write as-is write ( * , '(a)' ) attr ( trim ( line )) call attr_mode ( manner = 'ansi' ) ! return to default mode write ( * , '(a)' ) attr ( trim ( line )) end program demo_attr_mode","tags":"","loc":"sourcefile/demo_attr_mode.f90.html"},{"title":"custom.f90 – M_attr","text":"Contents Programs demo_M_attr Source Code custom.f90 Source Code program demo_M_attr use M_attr , only : attr , attr_update write ( * , '(a)' ) attr ( '<clear>TEST CUSTOMIZED:' ) ! add custom keywords call attr_update ( 'blink' , char ( 27 ) // '[5m' ) call attr_update ( '/blink' , char ( 27 ) // '[38m' ) write ( * , '(a)' ) attr ( '<blink>Items for Friday</blink>' ) write ( * , '(a)' , advance = 'no' ) attr ( '<r>RED</r>,' ) write ( * , '(a)' , advance = 'no' ) attr ( '<b>BLUE</b>,' ) write ( * , '(a)' , advance = 'yes' ) attr ( '<g>GREEN</g>' ) ! delete call attr_update ( 'r' ) call attr_update ( '/r' ) ! replace call attr_update ( 'b' , '<<<<' ) call attr_update ( '/b' , '>>>>' ) write ( * , '(a)' , advance = 'no' ) attr ( '<r>RED</r>,' ) write ( * , '(a)' , advance = 'no' ) attr ( '<b>BLUE</b>,' ) write ( * , '(a)' , advance = 'yes' ) attr ( '<g>GREEN</g>' ) end program demo_M_attr","tags":"","loc":"sourcefile/custom.f90.html"},{"title":"mixed.f90 – M_attr","text":"Contents Programs demo_M_attrape Source Code mixed.f90 Source Code program demo_M_attrape use M_attr , only : attr , attr_mode , attr_update write ( * , '(a)' ) attr ( '<clear>TEST DEFAULTS:' ) call printstuff () write ( * , '(a)' ) attr ( 'TEST MANNER=PLAIN:' ) call attr_mode ( manner = 'plain' ) call printstuff () write ( * , '(a)' ) attr ( 'TEST MANNER=RAW:' ) call attr_mode ( manner = 'raw' ) call printstuff () write ( * , '(a)' ) attr ( 'TEST MANNER=VT102:' ) call attr_mode ( manner = 'vt102' ) call printstuff () write ( * , '(a)' ) attr ( 'TEST ADDING A CUSTOM SEQUENCE:' ) call attr_update ( 'blink' , char ( 27 ) // '[5m' ) call attr_update ( '/blink' , char ( 27 ) // '[38m' ) write ( * , '(a)' ) attr ( '<blink>Items for Friday</blink>' ) contains subroutine printstuff () write ( * , '(a)' ) attr ( '<r>RED</r>,<g>GREEN</g>,<b>BLUE</b>' ) write ( * , '(a)' ) attr ( '<c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y>' ) write ( * , '(a)' ) attr ( '<w>WHITE</w> and <e>EBONY</e>' ) write ( * , '(a)' ) attr ( 'Adding <bo>bold</bo>' ) write ( * , '(a)' ) attr ( '<bo><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></bo>' ) write ( * , '(a)' ) attr ( '<bo><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y></bo>' ) write ( * , '(a)' ) attr ( '<bo><w>WHITE</w> and <e>EBONY</e></bo>' ) write ( * , '(a)' ) attr ( 'Adding <ul>underline</ul>' ) write ( * , '(a)' ) attr ( '<bo><ul><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><w>WHITE</w> and <e>EBONY</e></ul></bo>' ) write ( * , '(a)' ) attr ( 'Adding <ul>italic</ul>' ) write ( * , '(a)' ) attr ( '<bo><ul><it><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></it></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><it><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</it></y></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><it><w>WHITE</w> and <e>EBONY</e></ul></bo>' ) write ( * , '(a)' ) attr ( 'Adding <in>inverse</in>' ) write ( * , '(a)' ) attr ( '<in><bo><ul><it><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></it></ul></bo></in>' ) write ( * , '(a)' ) attr ( '<in><bo><ul><it><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</it></y></ul></bo></in>' ) write ( * , '(a)' ) attr ( '<in><bo><ul><it><w>WHITE</w> and <e>EBONY</e></ul></bo></in>' ) end subroutine printstuff end program demo_M_attrape","tags":"","loc":"sourcefile/mixed.f90.html"},{"title":"dump.f90 – M_attr","text":"Contents Programs demo_dump Source Code dump.f90 Source Code program demo_dump use M_attr , only : attr write ( * , '(a)' , advance = 'no' ) attr ( '<dump>' ) end program demo_dump","tags":"","loc":"sourcefile/dump.f90.html"},{"title":"functional.f90 – M_attr","text":"Contents Programs mode Source Code functional.f90 Source Code program mode use M_attr , only : attr , attr_mode implicit none call printme ( 'color' ) call printme ( 'plain' ) call printme ( 'raw' ) contains subroutine printme ( mymode ) character ( len =* ), intent ( in ) :: mymode call attr_mode ( mymode ) write ( * , '(a)' ) mymode write ( * , '(*(g0))' , advance = 'no' ) attr ( 'red:BLUE:bold' ), 'Hello!' , & & attr ( '/BLUE' ), ' Well, this is boring without a nice background color.' , attr ( 'reset' ) write ( * , '(*(g0))' , advance = 'yes' ) ' Back to a normal write statement.' end subroutine printme end program mode","tags":"","loc":"sourcefile/functional.f90.html"},{"title":"default.f90 – M_attr","text":"Contents Programs demo_M_attr Source Code default.f90 Source Code program demo_M_attr use M_attr , only : attr , attr_mode , attr_update write ( * , '(a)' ) attr ( 'TEST MANNER=DEFAULT:' ) write ( * , '(a)' ) attr ( '<r>RED</r>,<g>GREEN</g>,<b>BLUE</b>' ) write ( * , '(a)' ) attr ( '<c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y>' ) write ( * , '(a)' ) attr ( '<w>WHITE</w> and <e>EBONY</e>' ) write ( * , '(a)' ) attr ( 'Adding <bo>bold</bo>' ) write ( * , '(a)' ) attr ( '<bo><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></bo>' ) write ( * , '(a)' ) attr ( '<bo><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y></bo>' ) write ( * , '(a)' ) attr ( '<bo><w>WHITE</w> and <e>EBONY</e></bo>' ) write ( * , '(a)' ) attr ( 'Adding <ul>underline</ul>' ) write ( * , '(a)' ) attr ( '<bo><ul><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><w>WHITE</w> and <e>EBONY</e></ul></bo>' ) write ( * , '(a)' ) attr ( 'Adding <ul>italic</ul>' ) write ( * , '(a)' ) attr ( '<bo><ul><it><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></it></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><it><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</it></y></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><it><w>WHITE</w> and <e>EBONY</e></ul></bo>' ) write ( * , '(a)' ) attr ( 'Adding <in>inverse</in>' ) write ( * , '(a)' ) attr ( '<in><bo><ul><it><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></it></ul></bo></in>' ) write ( * , '(a)' ) attr ( '<in><bo><ul><it><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</it></y></ul></bo></in>' ) write ( * , '(a)' ) attr ( '<in><bo><ul><it><w>WHITE</w> and <e>EBONY</e></ul></bo></in>' ) end program demo_M_attr","tags":"","loc":"sourcefile/default.f90.html"},{"title":"attr_mode – M_attr","text":"public subroutine attr_mode(manner) !> NAME attr_mode ( 3 f ) - [ M_attr ] select processing mode for output from attr ( 3 f ) ( LICENSE : MIT ) SYNOPSIS subroutine attr_mode(manner)\n\n    character(len=*),intent(in) :: manner DESCRIPTION Turn off the generation of strings associated with the HTML keywords in the string generated by the attr ( 3 f ) function , or display the text in raw mode as it was passed to attr ( 3 f ) or return to ANSI escape control sequence generation . OPTIONS MANNER The current manners or modes supported via the attr_mode ( 3 f ) procedure are plain suppress the output associated with keywords color ( default ) commonly supported escape sequences raw echo the input to attr ( 3 f ) as its output reload restore original keyword meanings deleted or replaced by calls to attr_update ( 3 f ) . EXAMPLE Sample program\n\n program demo_attr_mode\n use M_attr, only : attr, attr_mode\n implicit none\n character(len=1024) :: line\n real :: value\n\n   value=3.4567\n   if( (value>0.0) .and. (value <100.0 ))then write(line, fmt= '(\"& &<w><G>GREAT</G></w>: The value <Y><b>\",f8.4,\"</b></Y> is in range & &\")' )value else write(line, fmt= '(\"& &<R><e>ERROR</e></R>:The new value <Y><b>\",g0,\"</b></Y> is out of range& & \")' )value endif write(*,'(a)')attr(trim(line)) call attr_mode( manner= 'plain' ) ! write as plain text write(*,'(a)')attr(trim(line)) call attr_mode( manner= 'raw' ) ! write as-is write(*,'(a)')attr(trim(line)) call attr_mode( manner= 'ansi' ) ! return to default mode write(*,'(a)')attr(trim(line)) end program demo_attr_mode AUTHOR John S. Urban, 2020 LICENSE MIT Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: manner Contents Variables i Source Code attr_mode Variables Type Visibility Attributes Name Initial integer, public :: i Source Code subroutine attr_mode ( manner ) character ( len =* ), intent ( in ) :: manner integer :: i if (. not . allocated ( mode )) then ! set substitution mode mode = 'color' call vt102 () endif select case ( manner ) case ( 'vt102' , 'ANSI' , 'ansi' , 'color' , 'COLOR' ) mode = 'color' case ( 'reload' , 'default' , 'defaults' , '' ) call vt102 () mode = 'color' case ( 'raw' ) mode = 'raw' case ( 'dump' ) ! dump dictionary for debugging if ( allocated ( keywords )) then if ( size ( keywords ). gt . 0 ) then write ( stderr , '(*(a,t30,a))' ) 'KEYWORD' , 'VALUE' write ( stderr , '(*(a,t30,2(\"[\",a,\"]\"),/))' )( trim ( keywords ( i )), values ( i ), mono_values ( i ), i = 1 , size ( keywords )) endif endif case ( 'dummy' , 'plain' , 'text' ) mode = 'plain' case default write ( * , * ) 'unknown manner. Try color|raw|plain' mode = 'color' end select end subroutine attr_mode","tags":"","loc":"proc/attr_mode.html"},{"title":"attr_update – M_attr","text":"public subroutine attr_update(key, valin, mono_valin) !> NAME attr_update ( 3 f ) - [ M_attr ] update internal dictionary given keyword and value ( LICENSE : MIT ) SYNOPSIS subroutine attr_update(key,val)\n\n character(len=*),intent(in)           :: key\n character(len=*),intent(in),optional  :: val\n character(len=*),intent(in),optional  :: mono_val DESCRIPTION Update internal dictionary in M_attr(3fm) module. OPTIONS key name of keyword to add , replace , or delete from dictionary val if present add or replace value associated with keyword . If not present remove keyword entry from dictionary . mono_val if present add or replace second value associated with keyword used for plain text mode . Must only be specified if VAL is also specified . KEYWORDS The following keywords are defined by default colors : r , red c , cyan w , white g , green m , magenta e , ebony b , blue y , yellow If the color keywords are capitalized they control the text background instead of the text color . attributes : ul , underline it , italics ( often produces inverse colors on many devices EXAMPLE Sample program\n\n program demo_update\n use M_attr, only : attr, attr_update\n    write(*,'(a)') attr(' <clear> TEST CUSTOMIZED:')\n    ! add custom keywords\n    call attr_update('blink',char(27)//'[5m')\n    call attr_update('/blink',char(27)//'[38m')\n\n    write(*,'(a)') attr(' <blink> Items for Friday </blink> ')\n\n    write(*,'(a)',advance='no') attr(' <r> RED </r> ,')\n    write(*,'(a)',advance='no') attr(' <b> BLUE </b> ,')\n    write(*,'(a)',advance='yes') attr(' <g> GREEN </g> ')\n\n    ! delete\n    call attr_update('r')\n    call attr_update('/r')\n    ! replace\n    call attr_update('b',' <<<< ')\n    call attr_update('/b','>>>>')\n    write(*,'(a)',advance='no') attr(' <r> RED </r> ,')\n    write(*,'(a)',advance='no') attr(' <b> BLUE </b> ,')\n    write(*,'(a)',advance='yes') attr(' <g> GREEN </g> ')\n\n end program demo_update AUTHOR John S. Urban, 2020 LICENSE MIT Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: key character(len=*), intent(in), optional :: valin character(len=*), intent(in), optional :: mono_valin Contents Variables mono_val place val Source Code attr_update Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: mono_val integer, public :: place character(len=:), public, allocatable :: val Source Code subroutine attr_update ( key , valin , mono_valin ) character ( len =* ), intent ( in ) :: key character ( len =* ), intent ( in ), optional :: valin character ( len =* ), intent ( in ), optional :: mono_valin integer :: place character ( len = :), allocatable :: val character ( len = :), allocatable :: mono_val if ( present ( mono_valin )) then mono_val = mono_valin else mono_val = '' endif if ( present ( valin )) then val = valin ! find where string is or should be call locate ( keywords , key , place ) ! if string was not found insert it if ( place . lt . 1 ) then call insert ( keywords , key , iabs ( place )) call insert ( values , val , iabs ( place )) call insert ( mono_values , mono_val , iabs ( place )) else call replace ( values , val , place ) call replace ( values , mono_val , place ) endif else call locate ( keywords , key , place ) if ( place . gt . 0 ) then call remove ( keywords , place ) call remove ( values , place ) call remove ( mono_values , place ) endif endif end subroutine attr_update","tags":"","loc":"proc/attr_update.html"},{"title":"attr – M_attr","text":"public interface attr Contents Module Procedures attr_scalar attr_matrix Module Procedures private function attr_scalar(string, clear_at_end) result(expanded) Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string logical, intent(in), optional :: clear_at_end Return Value character(len=:),\n  allocatable private function attr_matrix(string, clear_at_end) result(expanded) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string (:) logical, intent(in), optional :: clear_at_end Return Value character(len=:),\n  allocatable, (:)","tags":"","loc":"interface/attr.html"},{"title":"printstuff – M_attr","text":"subroutine printstuff(label) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: label Contents Source Code printstuff Source Code subroutine printstuff ( label ) character ( len =* ), intent ( in ) :: label call attr_mode ( manner = label ) write ( * , '(a)' ) attr ( 'TEST MANNER=' // label ) write ( * , '(a)' ) attr ( '<r>RED</r>,<g>GREEN</g>,<b>BLUE</b>' ) write ( * , '(a)' ) attr ( '<c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y>' ) write ( * , '(a)' ) attr ( '<w>WHITE</w> and <e>EBONY</e>' ) write ( * , '(a)' ) attr ( 'Adding <bo>bold</bo>' ) write ( * , '(a)' ) attr ( '<bo><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></bo>' ) write ( * , '(a)' ) attr ( '<bo><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y></bo>' ) write ( * , '(a)' ) attr ( '<bo><w>WHITE</w> and <e>EBONY</e></bo>' ) write ( * , '(a)' ) attr ( 'Adding <ul>underline</ul>' ) write ( * , '(a)' ) attr (& & '<bo><ul><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></ul></bo>' ) write ( * , '(a)' ) attr (& & '<bo><ul><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><w>WHITE</w> and <e>EBONY</e></ul></bo>' ) write ( * , '(a)' ) attr ( 'Adding <ul>italic</ul>' ) write ( * , '(a)' ) attr (& & '<bo><ul><it><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></it></ul></bo>' ) write ( * , '(a)' ) attr (& & '<bo><ul><it><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</it></y></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><it><w>WHITE</w> and <e>EBONY</e></ul></bo>' ) write ( * , '(a)' ) attr ( 'Adding <in>inverse</in>' ) write ( * , '(a)' ) attr (& & '<in><bo><ul><it><r>RED</r>,<g>GREEN</g>,& &<b>BLUE</b></it></ul></bo></in>' ) write ( * , '(a)' ) attr (& & '<in><bo><ul><it><c>CYAN</c>,<m>MAGENTA</g>,& &<y>YELLOW</it></y></ul></bo></in>' ) write ( * , '(a)' ) attr (& & '<in><bo><ul><it><w>WHITE</w> and <e>EBONY</e></ul></bo></in>' ) end subroutine printstuff","tags":"","loc":"proc/printstuff.html"},{"title":"printstuff – M_attr","text":"subroutine printstuff() Arguments None Contents Source Code printstuff Source Code subroutine printstuff () write ( * , '(a)' ) attr ( '<r>RED</r>,<g>GREEN</g>,<b>BLUE</b>' ) write ( * , '(a)' ) attr ( '<c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y>' ) write ( * , '(a)' ) attr ( '<w>WHITE</w> and <e>EBONY</e>' ) write ( * , '(a)' ) attr ( 'Adding <bo>bold</bo>' ) write ( * , '(a)' ) attr ( '<bo><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></bo>' ) write ( * , '(a)' ) attr ( '<bo><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y></bo>' ) write ( * , '(a)' ) attr ( '<bo><w>WHITE</w> and <e>EBONY</e></bo>' ) write ( * , '(a)' ) attr ( 'Adding <ul>underline</ul>' ) write ( * , '(a)' ) attr ( '<bo><ul><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><w>WHITE</w> and <e>EBONY</e></ul></bo>' ) write ( * , '(a)' ) attr ( 'Adding <ul>italic</ul>' ) write ( * , '(a)' ) attr ( '<bo><ul><it><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></it></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><it><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</it></y></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><it><w>WHITE</w> and <e>EBONY</e></ul></bo>' ) write ( * , '(a)' ) attr ( 'Adding <in>inverse</in>' ) write ( * , '(a)' ) attr ( '<in><bo><ul><it><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></it></ul></bo></in>' ) write ( * , '(a)' ) attr ( '<in><bo><ul><it><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</it></y></ul></bo></in>' ) write ( * , '(a)' ) attr ( '<in><bo><ul><it><w>WHITE</w> and <e>EBONY</e></ul></bo></in>' ) end subroutine printstuff","tags":"","loc":"proc/printstuff~2.html"},{"title":"printme – M_attr","text":"subroutine printme(mymode) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: mymode Contents Source Code printme Source Code subroutine printme ( mymode ) character ( len =* ), intent ( in ) :: mymode call attr_mode ( mymode ) write ( * , '(a)' ) mymode write ( * , '(*(g0))' , advance = 'no' ) attr ( 'red:BLUE:bold' ), 'Hello!' , & & attr ( '/BLUE' ), ' Well, this is boring without a nice background color.' , attr ( 'reset' ) write ( * , '(*(g0))' , advance = 'yes' ) ' Back to a normal write statement.' end subroutine printme","tags":"","loc":"proc/printme.html"},{"title":"M_attr – M_attr","text":"NAME M_attr ( 3 f ) - [ M_attr ] control text attributes on terminals ( LICENSE : MIT ) SYNOPSIS use M_attr, only : attr, attr_mode, attr_update DESCRIPTION M_attr ( 3 f ) is a Fortran module for adding attributes to terminal output such as color on devices that recognize ANSI escape sequences . MAJOR FEATURES o Add text attributes with an HTML-like syntax using attr(3f).\n   o suppress the escape sequence output with attr_mode(3f).\n   o customize what strings are produced using attr_update(3f). LIMITATIONS o colors are not nestable.\n   o keywords are case-sensitive,\n   o ANSI escape sequences are not universally supported by\n     all terminal emulators; and normally should be suppressed\n     when not going to a tty device. Therefore, you should use\n     M_system::system_istty(3f) or the common Fortran extension\n     ISATTY() to set the default to “plain” instead of “color”\n     when the output file is not a conforming terminal. On basic\n     MSWindows console windows, it is best to use Windows 10+ and/or\n     the Linux mode; you may have to enable ANSI escape sequence\n     mode on MSWindows. It does work as-is with CygWin and MinGW and\n     Putty windows and mintty(1) as tested. EXAMPLE Sample program\n\n program demo_M_attr\n use M_attr, only : attr, attr_mode\n implicit none\n character(len=256) :: line\n real :: value\n    write(*,'(a)') & & attr(' <r><W> ERROR: </W> red text on a white background </y> ')\n\n    value=3.4567\n    write(line,fmt= & & '(\" <w><G> GREAT </G></w> : & & The new value <Y><b> \",f8.4,\" </b></Y> is in range\")')value\n    write(*,'(a)')attr(trim(line))\n\n    ! write same string as plain text\n    call attr_mode(manner='plain')\n    write(*,'(a)')attr(trim(line))\n\n end program demo_M_attr AUTHOR John S. Urban, 2020 LICENSE MIT SEE ALSO attr(3f), attr_mode(3f), attr_update(3f)\n\nRelated information:\n\n terminfo(3c), termlib(3c), tput(1), reset(1), clear(1),\n console_codes(4), ECMA-48,\n https://en.wikipedia.org/wiki/ANSI_escape_code Uses iso_fortran_env iso_c_binding Contents Variables bg_black bg_blue bg_cyan bg_default bg_ebony bg_green bg_magenta bg_red bg_white bg_yellow bold clear fg_black fg_blue fg_cyan fg_default fg_ebony fg_green fg_magenta fg_red fg_white fg_yellow inverse italic reset unbold underline uninverse unitalic ununderline Interfaces attr Subroutines attr_mode attr_update Variables Type Visibility Attributes Name Initial character(len=*), public, parameter :: bg_black = CODE_START//BG//BLACK//CODE_END character(len=*), public, parameter :: bg_blue = CODE_START//BG//BLUE//CODE_END character(len=*), public, parameter :: bg_cyan = CODE_START//BG//CYAN//CODE_END character(len=*), public, parameter :: bg_default = CODE_START//BG//DEFAULT//CODE_END character(len=*), public, parameter :: bg_ebony = CODE_START//BG//BLACK//CODE_END character(len=*), public, parameter :: bg_green = CODE_START//BG//GREEN//CODE_END character(len=*), public, parameter :: bg_magenta = CODE_START//BG//MAGENTA//CODE_END character(len=*), public, parameter :: bg_red = CODE_START//BG//RED//CODE_END character(len=*), public, parameter :: bg_white = CODE_START//BG//WHITE//CODE_END character(len=*), public, parameter :: bg_yellow = CODE_START//BG//YELLOW//CODE_END character(len=*), public, parameter :: bold = CODE_START//ON//AT_BOLD//CODE_END character(len=*), public, parameter :: clear = HOME_DISPLAY//CLEAR_DISPLAY character(len=*), public, parameter :: fg_black = CODE_START//FG//BLACK//CODE_END character(len=*), public, parameter :: fg_blue = CODE_START//FG//BLUE//CODE_END character(len=*), public, parameter :: fg_cyan = CODE_START//FG//CYAN//CODE_END character(len=*), public, parameter :: fg_default = CODE_START//FG//DEFAULT//CODE_END character(len=*), public, parameter :: fg_ebony = CODE_START//FG//BLACK//CODE_END character(len=*), public, parameter :: fg_green = CODE_START//FG//GREEN//CODE_END character(len=*), public, parameter :: fg_magenta = CODE_START//FG//MAGENTA//CODE_END character(len=*), public, parameter :: fg_red = CODE_START//FG//RED//CODE_END character(len=*), public, parameter :: fg_white = CODE_START//FG//WHITE//CODE_END character(len=*), public, parameter :: fg_yellow = CODE_START//FG//YELLOW//CODE_END character(len=*), public, parameter :: inverse = CODE_START//ON//AT_INVERSE//CODE_END character(len=*), public, parameter :: italic = CODE_START//ON//AT_ITALIC//CODE_END character(len=*), public, parameter :: reset = CODE_RESET character(len=*), public, parameter :: unbold = CODE_START//OFF//AT_BOLD//CODE_END character(len=*), public, parameter :: underline = CODE_START//ON//AT_UNDERLINE//CODE_END character(len=*), public, parameter :: uninverse = CODE_START//OFF//AT_INVERSE//CODE_END character(len=*), public, parameter :: unitalic = CODE_START//OFF//AT_ITALIC//CODE_END character(len=*), public, parameter :: ununderline = CODE_START//OFF//AT_UNDERLINE//CODE_END Interfaces public interface attr private function attr_scalar(string, clear_at_end) result(expanded) Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string logical, intent(in), optional :: clear_at_end Return Value character(len=:),\n  allocatable private function attr_matrix(string, clear_at_end) result(expanded) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string (:) logical, intent(in), optional :: clear_at_end Return Value character(len=:),\n  allocatable, (:) Subroutines public subroutine attr_mode (manner) !> Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: manner public subroutine attr_update (key, valin, mono_valin) !> Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: key character(len=*), intent(in), optional :: valin character(len=*), intent(in), optional :: mono_valin","tags":"","loc":"module/m_attr.html"},{"title":"demo_attr – M_attr","text":"Uses M_attr Contents Variables expanded ios line Source Code demo_attr Variables Type Attributes Name Initial character(len=:), allocatable :: expanded integer :: ios character(len=1024) :: line Source Code program demo_attr ! read stdin and run it through M_attr::attr to display color use M_attr , only : attr , attr_update implicit none character ( len = 1024 ) :: line character ( len = :), allocatable :: expanded integer :: ios line = '' call attr_update ( 'Z' , char ( 27 ) // '[1m' ) do read ( * , '(a)' , iostat = ios ) line expanded = attr ( trim ( line )) write ( * , '(a)' ) expanded if ( ios . ne . 0 ) exit enddo write ( * , '(a)' , advance = 'no' ) attr ( '<reset>' ) end program demo_attr","tags":"","loc":"program/demo_attr.html"},{"title":"roots – M_attr","text":"Uses iso_fortran_env M_attr Contents Variables a b c discriminant dp ios line message paws x x1 x2 x_complex x_real Source Code roots Variables Type Attributes Name Initial real(kind=dp) :: a real(kind=dp) :: b real(kind=dp) :: c real(kind=dp) :: discriminant integer, parameter :: dp = kind(0.0d0) integer :: ios character(len=:), allocatable :: line character(len=256) :: message character(len=1) :: paws real(kind=dp) :: x real(kind=dp) :: x1 real(kind=dp) :: x2 real(kind=dp) :: x_complex real(kind=dp) :: x_real Source Code program roots use , intrinsic :: iso_fortran_env , only : stdin => input_unit , stdout => output_unit , stderr => error_unit use M_attr , only : attr , attr_mode , attr_update ! Calculate and print the roots of a quadratic formula even if they are complex implicit none integer , parameter :: dp = kind ( 0.0d0 ) real ( kind = dp ) :: a , b , c , discriminant real ( kind = dp ) :: x1 , x2 , x ! Real roots of the equation real ( kind = dp ) :: x_real ! Real part of complex root of the equation REAL ( kind = dp ) :: x_complex ! Imaginary part of complex root of the equation character ( len = :), allocatable :: line character ( len = 256 ) :: message integer :: ios character ( len = 1 ) :: paws if ( isatty ( stdout )) then ! ISATTY() is an extension, but found in Intel, GNU, PGI, ... compiler call attr_mode ( 'color' ) else call attr_mode ( 'plain' ) endif INFINITE : do ! clear screen, set attributes and print messages line = \"<clear><B><w><bo>Enter the quadratic equation coefficients a, b and c\" write ( * , '(*(a))' , advance = 'no' ) attr ( '<B><w><bo>' // repeat ( '_' , len ( line )) // '<' ), char ( 13 ), attr ( '<B><y>ENTER>' ) read ( * , * , iostat = ios , iomsg = message ) a , b , c !write(*,'(a)',advance='no')attr('reset') if ( ios . ne . 0 ) then write ( * , '(*(g0))' ) ios , ' ' , trim ( message ) else ! Given the equation \"A*x**2 + B*x + C = 0\" ! Use the quadratic formula to determine the root values of the equation. ! prompt for new value WRITE ( * , '(*(g0))' ) 'for ' , a , '*x**2 + ' , b , '*x + ' , c , ' = 0' discriminant = b ** 2 - 4 * a * c IF ( discriminant > 0 ) THEN write ( * , * ) 'the roots (ie. \"x intercepts\") are real so the parabola crosses the x-axis at two points:' x1 = ( - b + sqrt ( discriminant )) / ( 2 * a ) x2 = ( - b - sqrt ( discriminant )) / ( 2 * a ) PRINT * , \"Real roots:\" , x1 , x2 ELSEIF ( discriminant == 0 ) THEN PRINT * , 'the roots (ie. \"x intercepts\") are repeated (real and equal) so the parabola just touches the x-axis at:' x = ( - b ) / ( 2 * a ) PRINT * , \"Two identical Real roots\" , x ELSE PRINT * , 'the roots(ie. \"x intercepts\")  are complex:' x_real = ( - b ) / ( 2 * a ) x_complex = sqrt ( abs ( discriminant )) / ( 2 * a ) PRINT * , x_real , \"+i\" , x_complex , x_real , \"-i\" , x_complex ENDIF PRINT * , \"discriminant =\" , discriminant endif write ( * , '(*(g0))' ) 'press <return> to continue, <q> to quit' read ( * , advance = 'yes' , iostat = ios , fmt = '(a)' , iomsg = message ) paws if ( paws . ne . '' ) exit INFINITE enddo INFINITE END PROGRAM roots","tags":"","loc":"program/roots.html"},{"title":"demo_attr – M_attr","text":"Uses M_attr Contents Variables ios line Source Code demo_attr Variables Type Attributes Name Initial integer :: ios character(len=1024) :: line Source Code program demo_attr ! read stdin and run it through M_attr::attr to display without color use M_attr , only : attr , attr_mode implicit none character ( len = 1024 ) :: line integer :: ios line = '' call attr_mode ( manner = 'plain' ) do read ( * , '(a)' , iostat = ios ) line write ( * , '(a)' ) attr ( trim ( line )) if ( ios . ne . 0 ) exit enddo write ( * , '(a)' , advance = 'no' ) attr ( '<reset>' ) end program demo_attr","tags":"","loc":"program/demo_attr~2.html"},{"title":"demo_M_attr – M_attr","text":"Uses M_attr Contents Variables line value Source Code demo_M_attr Variables Type Attributes Name Initial character(len=256) :: line real :: value Source Code program demo_M_attr use M_attr , only : attr , attr_mode implicit none character ( len = 256 ) :: line real :: value write ( * , '(a)' )& & attr ( '<r><W>ERROR:</W> red text on a white background</y>' ) value = 3.4567 write ( line , fmt = & & '(\"<w><G>GREAT</G></w>:& &The new value <Y><b>\",f8.4,\"</b></Y> is in range\")' ) value write ( * , '(a)' ) attr ( trim ( line )) ! write same string as plain text call attr_mode ( manner = 'plain' ) write ( * , '(a)' ) attr ( trim ( line )) end program demo_M_attr","tags":"","loc":"program/demo_m_attr.html"},{"title":"demo_esc – M_attr","text":"Uses M_attr Contents Subroutines printstuff Source Code demo_esc Subroutines subroutine printstuff (label) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: label Source Code program demo_esc use M_attr , only : attr , attr_mode , attr_update call printstuff ( 'defaults' ) call attr_mode ( manner = 'plain' ) call printstuff ( 'plain:' ) call printstuff ( 'raw:' ) call attr_mode ( manner = 'color' ) call printstuff ( '' ) write ( * , '(a)' ) attr ( 'TEST ADDING A CUSTOM SEQUENCE:' ) call attr_update ( 'blink' , char ( 27 ) // '[5m' ) call attr_update ( '/blink' , char ( 27 ) // '[38m' ) write ( * , '(a)' ) attr ( '<blink>Items for Friday</blink>' ) contains subroutine printstuff ( label ) character ( len =* ), intent ( in ) :: label call attr_mode ( manner = label ) write ( * , '(a)' ) attr ( 'TEST MANNER=' // label ) write ( * , '(a)' ) attr ( '<r>RED</r>,<g>GREEN</g>,<b>BLUE</b>' ) write ( * , '(a)' ) attr ( '<c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y>' ) write ( * , '(a)' ) attr ( '<w>WHITE</w> and <e>EBONY</e>' ) write ( * , '(a)' ) attr ( 'Adding <bo>bold</bo>' ) write ( * , '(a)' ) attr ( '<bo><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></bo>' ) write ( * , '(a)' ) attr ( '<bo><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y></bo>' ) write ( * , '(a)' ) attr ( '<bo><w>WHITE</w> and <e>EBONY</e></bo>' ) write ( * , '(a)' ) attr ( 'Adding <ul>underline</ul>' ) write ( * , '(a)' ) attr (& & '<bo><ul><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></ul></bo>' ) write ( * , '(a)' ) attr (& & '<bo><ul><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><w>WHITE</w> and <e>EBONY</e></ul></bo>' ) write ( * , '(a)' ) attr ( 'Adding <ul>italic</ul>' ) write ( * , '(a)' ) attr (& & '<bo><ul><it><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></it></ul></bo>' ) write ( * , '(a)' ) attr (& & '<bo><ul><it><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</it></y></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><it><w>WHITE</w> and <e>EBONY</e></ul></bo>' ) write ( * , '(a)' ) attr ( 'Adding <in>inverse</in>' ) write ( * , '(a)' ) attr (& & '<in><bo><ul><it><r>RED</r>,<g>GREEN</g>,& &<b>BLUE</b></it></ul></bo></in>' ) write ( * , '(a)' ) attr (& & '<in><bo><ul><it><c>CYAN</c>,<m>MAGENTA</g>,& &<y>YELLOW</it></y></ul></bo></in>' ) write ( * , '(a)' ) attr (& & '<in><bo><ul><it><w>WHITE</w> and <e>EBONY</e></ul></bo></in>' ) end subroutine printstuff end program demo_esc","tags":"","loc":"program/demo_esc.html"},{"title":"demo_update – M_attr","text":"Uses M_attr Contents Source Code demo_update Source Code program demo_update use M_attr , only : attr , attr_update write ( * , '(a)' ) attr ( '<clear>TEST CUSTOMIZED:' ) ! add custom keywords call attr_update ( 'blink' , char ( 27 ) // '[5m' ) call attr_update ( '/blink' , char ( 27 ) // '[38m' ) write ( * , '(a)' ) attr ( '<blink>Items for Friday</blink>' ) write ( * , '(a)' , advance = 'no' ) attr ( '<r>RED</r>,' ) write ( * , '(a)' , advance = 'no' ) attr ( '<b>BLUE</b>,' ) write ( * , '(a)' , advance = 'yes' ) attr ( '<g>GREEN</g>' ) ! delete call attr_update ( 'r' ) call attr_update ( '/r' ) ! replace call attr_update ( 'b' , '<<<<' ) call attr_update ( '/b' , '>>>>' ) write ( * , '(a)' , advance = 'no' ) attr ( '<r>RED</r>,' ) write ( * , '(a)' , advance = 'no' ) attr ( '<b>BLUE</b>,' ) write ( * , '(a)' , advance = 'yes' ) attr ( '<g>GREEN</g>' ) end program demo_update","tags":"","loc":"program/demo_update.html"},{"title":"demo_attr_mode – M_attr","text":"Uses M_attr Contents Variables line value Source Code demo_attr_mode Variables Type Attributes Name Initial character(len=1024) :: line real :: value Source Code program demo_attr_mode use M_attr , only : attr , attr_mode implicit none character ( len = 1024 ) :: line real :: value value = 3.4567 if ( ( value > 0.0 ) . and . ( value < 10 0.0 )) then write ( line , fmt = '(\"& &<w><G>GREAT</G></w>: The value <Y><b>\",f8.4,\"</b></Y> is in range & &\")' ) value else write ( line , fmt = '(\"& &<R><e>ERROR</e></R>:The new value <Y><b>\",g0,\"</b></Y> is out of range& & \")' ) value endif write ( * , '(a)' ) attr ( trim ( line )) call attr_mode ( manner = 'plain' ) ! write as plain text write ( * , '(a)' ) attr ( trim ( line )) call attr_mode ( manner = 'raw' ) ! write as-is write ( * , '(a)' ) attr ( trim ( line )) call attr_mode ( manner = 'ansi' ) ! return to default mode write ( * , '(a)' ) attr ( trim ( line )) end program demo_attr_mode","tags":"","loc":"program/demo_attr_mode.html"},{"title":"demo_M_attr – M_attr","text":"Uses M_attr Contents Source Code demo_M_attr Source Code program demo_M_attr use M_attr , only : attr , attr_update write ( * , '(a)' ) attr ( '<clear>TEST CUSTOMIZED:' ) ! add custom keywords call attr_update ( 'blink' , char ( 27 ) // '[5m' ) call attr_update ( '/blink' , char ( 27 ) // '[38m' ) write ( * , '(a)' ) attr ( '<blink>Items for Friday</blink>' ) write ( * , '(a)' , advance = 'no' ) attr ( '<r>RED</r>,' ) write ( * , '(a)' , advance = 'no' ) attr ( '<b>BLUE</b>,' ) write ( * , '(a)' , advance = 'yes' ) attr ( '<g>GREEN</g>' ) ! delete call attr_update ( 'r' ) call attr_update ( '/r' ) ! replace call attr_update ( 'b' , '<<<<' ) call attr_update ( '/b' , '>>>>' ) write ( * , '(a)' , advance = 'no' ) attr ( '<r>RED</r>,' ) write ( * , '(a)' , advance = 'no' ) attr ( '<b>BLUE</b>,' ) write ( * , '(a)' , advance = 'yes' ) attr ( '<g>GREEN</g>' ) end program demo_M_attr","tags":"","loc":"program/demo_m_attr~2.html"},{"title":"demo_M_attrape – M_attr","text":"Uses M_attr Contents Subroutines printstuff Source Code demo_M_attrape Subroutines subroutine printstuff () Arguments None Source Code program demo_M_attrape use M_attr , only : attr , attr_mode , attr_update write ( * , '(a)' ) attr ( '<clear>TEST DEFAULTS:' ) call printstuff () write ( * , '(a)' ) attr ( 'TEST MANNER=PLAIN:' ) call attr_mode ( manner = 'plain' ) call printstuff () write ( * , '(a)' ) attr ( 'TEST MANNER=RAW:' ) call attr_mode ( manner = 'raw' ) call printstuff () write ( * , '(a)' ) attr ( 'TEST MANNER=VT102:' ) call attr_mode ( manner = 'vt102' ) call printstuff () write ( * , '(a)' ) attr ( 'TEST ADDING A CUSTOM SEQUENCE:' ) call attr_update ( 'blink' , char ( 27 ) // '[5m' ) call attr_update ( '/blink' , char ( 27 ) // '[38m' ) write ( * , '(a)' ) attr ( '<blink>Items for Friday</blink>' ) contains subroutine printstuff () write ( * , '(a)' ) attr ( '<r>RED</r>,<g>GREEN</g>,<b>BLUE</b>' ) write ( * , '(a)' ) attr ( '<c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y>' ) write ( * , '(a)' ) attr ( '<w>WHITE</w> and <e>EBONY</e>' ) write ( * , '(a)' ) attr ( 'Adding <bo>bold</bo>' ) write ( * , '(a)' ) attr ( '<bo><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></bo>' ) write ( * , '(a)' ) attr ( '<bo><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y></bo>' ) write ( * , '(a)' ) attr ( '<bo><w>WHITE</w> and <e>EBONY</e></bo>' ) write ( * , '(a)' ) attr ( 'Adding <ul>underline</ul>' ) write ( * , '(a)' ) attr ( '<bo><ul><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><w>WHITE</w> and <e>EBONY</e></ul></bo>' ) write ( * , '(a)' ) attr ( 'Adding <ul>italic</ul>' ) write ( * , '(a)' ) attr ( '<bo><ul><it><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></it></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><it><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</it></y></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><it><w>WHITE</w> and <e>EBONY</e></ul></bo>' ) write ( * , '(a)' ) attr ( 'Adding <in>inverse</in>' ) write ( * , '(a)' ) attr ( '<in><bo><ul><it><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></it></ul></bo></in>' ) write ( * , '(a)' ) attr ( '<in><bo><ul><it><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</it></y></ul></bo></in>' ) write ( * , '(a)' ) attr ( '<in><bo><ul><it><w>WHITE</w> and <e>EBONY</e></ul></bo></in>' ) end subroutine printstuff end program demo_M_attrape","tags":"","loc":"program/demo_m_attrape.html"},{"title":"demo_dump – M_attr","text":"Uses M_attr Contents Source Code demo_dump Source Code program demo_dump use M_attr , only : attr write ( * , '(a)' , advance = 'no' ) attr ( '<dump>' ) end program demo_dump","tags":"","loc":"program/demo_dump.html"},{"title":"mode – M_attr","text":"Uses M_attr Contents Subroutines printme Source Code mode Subroutines subroutine printme (mymode) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: mymode Source Code program mode use M_attr , only : attr , attr_mode implicit none call printme ( 'color' ) call printme ( 'plain' ) call printme ( 'raw' ) contains subroutine printme ( mymode ) character ( len =* ), intent ( in ) :: mymode call attr_mode ( mymode ) write ( * , '(a)' ) mymode write ( * , '(*(g0))' , advance = 'no' ) attr ( 'red:BLUE:bold' ), 'Hello!' , & & attr ( '/BLUE' ), ' Well, this is boring without a nice background color.' , attr ( 'reset' ) write ( * , '(*(g0))' , advance = 'yes' ) ' Back to a normal write statement.' end subroutine printme end program mode","tags":"","loc":"program/mode.html"},{"title":"demo_M_attr – M_attr","text":"Uses M_attr Contents Source Code demo_M_attr Source Code program demo_M_attr use M_attr , only : attr , attr_mode , attr_update write ( * , '(a)' ) attr ( 'TEST MANNER=DEFAULT:' ) write ( * , '(a)' ) attr ( '<r>RED</r>,<g>GREEN</g>,<b>BLUE</b>' ) write ( * , '(a)' ) attr ( '<c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y>' ) write ( * , '(a)' ) attr ( '<w>WHITE</w> and <e>EBONY</e>' ) write ( * , '(a)' ) attr ( 'Adding <bo>bold</bo>' ) write ( * , '(a)' ) attr ( '<bo><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></bo>' ) write ( * , '(a)' ) attr ( '<bo><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y></bo>' ) write ( * , '(a)' ) attr ( '<bo><w>WHITE</w> and <e>EBONY</e></bo>' ) write ( * , '(a)' ) attr ( 'Adding <ul>underline</ul>' ) write ( * , '(a)' ) attr ( '<bo><ul><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><w>WHITE</w> and <e>EBONY</e></ul></bo>' ) write ( * , '(a)' ) attr ( 'Adding <ul>italic</ul>' ) write ( * , '(a)' ) attr ( '<bo><ul><it><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></it></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><it><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</it></y></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><it><w>WHITE</w> and <e>EBONY</e></ul></bo>' ) write ( * , '(a)' ) attr ( 'Adding <in>inverse</in>' ) write ( * , '(a)' ) attr ( '<in><bo><ul><it><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></it></ul></bo></in>' ) write ( * , '(a)' ) attr ( '<in><bo><ul><it><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</it></y></ul></bo></in>' ) write ( * , '(a)' ) attr ( '<in><bo><ul><it><w>WHITE</w> and <e>EBONY</e></ul></bo></in>' ) end program demo_M_attr","tags":"","loc":"program/demo_m_attr~3.html"}]}