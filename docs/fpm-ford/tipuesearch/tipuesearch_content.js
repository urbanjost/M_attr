var tipuesearch = {"pages":[{"title":" M_attr ","text":"M_attr Developer Info John S. Urban","tags":"home","loc":"index.html"},{"title":"M_attr.f90 – M_attr","text":"Contents Modules M_attr Source Code M_attr.f90 Source Code !> !!##NAME !!    M_attr(3f) - [M_attr] control text attributes on terminals !!    (LICENSE:MIT) !! !!##SYNOPSIS !! !!   core functions !! !!      ! Add text attributes like color with an HTML-like syntax !!      use M_attr, only : attr !!      ! suppress the escape sequence output !!      use M_attr, only : attr_mode !!      ! customize what output strings are produced !!      use M_attr, only : attr_update !! !!   for generating standard messages !! !!      use M_attr, only : advice !! !! !!##DESCRIPTION !!    M_attr(3f) is a Fortran module that writes common ANSI escape sequences !!    which control terminal text attributes. It is designed to allow the !!    sequences to be suppressed when desired and for the user program to !!    completely customize the keywords -- the user can add, delete and !!    replace the sequences associated with a keyword without changing !!    the code. !! !!    Attributes are specified by writing lines with HTML-like structure. !! !!    The advantage of the approach of replacing in-band escape sequences !!    with formatting directives contained on each line is that it is easy !!    to turn off when running batch, but more importantly your program can !!    be run in \"raw\" mode and write a clean text file with the directives in !!    it that can then be read back in by a simple filter program that strips !!    it back to plain text( see app/plain.f90), or displays it to a screen !!    in color(see app/light.f90) or perhaps converts it to another format. !! !!    By making each line self-contained (by default) this can still be done !!    with any arbitrarily selected group of lines from the file. !! !!    So this module makes it trivial to read specially-formatted data !!    from a file like a message catalog (perhaps with various versions !!    in different languages) and colorize it or display it as plain text !!    using the attr(3f) procedure. !! !!##LIMITATIONS !!   o colors are not nestable. !!   o keywords are case-sensitive, !!   o ANSI escape sequences are not universally supported by !!     all terminal emulators; and normally should be suppressed !!     when not going to a tty device. Therefore, you should use !!     M_system::system_istty(3f) or the common Fortran extension !!     ISATTY() to set the default to \"plain\" instead of \"color\" !!     when the output file is not a conforming terminal. On basic !!     MSWindows console windows, it is best to use Windows 10+ and/or !!     the Linux mode; you may have to enable ANSI escape sequence !!     mode on MSWindows. It does work as-is with CygWin and MinGW and !!     Putty windows and mintty(1) as tested. !! !!##EXAMPLE !! !!    Sample program !! !!     program demo_M_attr !!     use M_attr, only : attr, attr_mode, attr_update !!     implicit none !!     character(len=256) :: line !!     character(len=*),parameter :: f='( & !!      &\"   <bo><w><G> GREAT: </G></w>& !!      &The new value <Y><b>\",f8.4,1x,\"</b></Y> is in range\"& !!      &)' !!     real :: value !! !!        write(*,'(a)')& !!        &attr('   <r><W><bo> ERROR: </W>red text on a white background</y>') !! !!        value=3.4567 !!        write(line,fmt=f) value !!        write(*,'(a)')attr(trim(line)) !! !!        ! write same string as plain text !!        write(*,*) !!        call attr_mode(manner='plain') !!        write(*,'(a)')attr(trim(line)) !! !!        call attr_mode(manner='color') !!        ! use pre-defined or user defined strings !!        write(*,*) !!        write(*,'(a)')attr('<ERROR> Woe is nigh.') !!        write(*,'(a)')attr('<WARNING> The night is young.') !!        write(*,'(a)')attr('<INFO> It is Monday') !! !!        ! create a custom mneumonic !!        call attr_update('MYERROR',attr(& !!        ' <R><e> E<w>-<e>R<w>-<e>R<w>-<e>O<w>-<e>R: </e></R></bo>'& !!        )) !!        write(*,*) !!        write(*,'(a)')attr('<MYERROR> my custom message style') !! !!     end program demo_M_attr !! !!##AUTHOR !!    John S. Urban, 2021 !! !!##LICENSE !!    MIT !! !!##SEE ALSO !!    attr(3f), attr_mode(3f), attr_update(3f) !! !!    Related information: !! !!     terminfo(3c), termlib(3c), tput(1), reset(1), clear(1), !!     console_codes(4), ECMA-48, !!     https://en.wikipedia.org/wiki/ANSI_escape_code module M_attr use , intrinsic :: iso_fortran_env , only : stderr => ERROR_UNIT , stdin => INPUT_UNIT , stdout => OUTPUT_UNIT use , intrinsic :: iso_c_binding , only : c_int implicit none private public :: attr public :: attr_mode public :: attr_update public :: advice private :: attr_matrix private :: attr_scalar private :: attr_scalar_width private :: get private :: locate ! find PLACE in sorted character array where value can be found or should be placed private :: insert ! insert entry into a sorted allocatable array at specified position private :: replace ! replace entry by index from a sorted allocatable array if it is present private :: remove ! delete entry by index from a sorted allocatable array if it is present private :: wipe_dictionary private :: vt102 interface attr module procedure attr_scalar module procedure attr_matrix module procedure attr_scalar_width end interface ! direct use of constant strings character ( len = :), allocatable , save :: keywords (:) character ( len = :), allocatable , save :: values (:) character ( len = :), allocatable , save :: mono_values (:) character ( len = :), allocatable , save :: mode ! mnemonics character ( len =* ), parameter :: NL = new_line ( 'a' ) ! New line character. ! DECIMAL ! *-------*-------*-------*-------*-------*-------*-------*-------* ! | 00 nul| 01 soh| 02 stx| 03 etx| 04 eot| 05 enq| 06 ack| 07 bel| ! | 08 bs | 09 ht | 10 nl | 11 vt | 12 np | 13 cr | 14 so | 15 si | ! | 16 dle| 17 dc1| 18 dc2| 19 dc3| 20 dc4| 21 nak| 22 syn| 23 etb| ! | 24 can| 25 em | 26 sub| 27 esc| 28 fs | 29 gs | 30 rs | 31 us | ! | 32 sp | 33  ! | 34  \" | 35  # | 36  $ | 37  % | 38  & | 39  ' | ! | 40  ( | 41  ) | 42  * | 43  + | 44  , | 45  - | 46  . | 47  / | ! | 48  0 | 49  1 | 50  2 | 51  3 | 52  4 | 53  5 | 54  6 | 55  7 | ! | 56  8 | 57  9 | 58  : | 59  ; | 60  < | 61  = | 62  > | 63  ? | ! | 64  @ | 65  A | 66  B | 67  C | 68  D | 69  E | 70  F | 71  G | ! | 72  H | 73  I | 74  J | 75  K | 76  L | 77  M | 78  N | 79  O | ! | 80  P | 81  Q | 82  R | 83  S | 84  T | 85  U | 86  V | 87  W | ! | 88  X | 89  Y | 90  Z | 91  [ | 92  \\ | 93  ] | 94  &#94; | 95  _ | ! | 96  ` | 97  a | 98  b | 99  c |100  d |101  e |102  f |103  g | ! |104  h |105  i |106  j |107  k |108  l |109  m |110  n |111  o | ! |112  p |113  q |114  r |115  s |116  t |117  u |118  v |119  w | ! |120  x |121  y |122  z |123  { |124  | |125  } |126  ~ |127 del| ! *-------*-------*-------*-------*-------*-------*-------*-------* character ( len =* ), parameter :: nul = achar ( 0 ) character ( len =* ), parameter :: bel = achar ( 7 ) ! &#94;G beeps; character ( len =* ), parameter :: bs = achar ( 8 ) ! &#94;H backspaces one column (but not past the beginning of the line); character ( len =* ), parameter :: ht = achar ( 9 ) ! &#94;I goes to next tab stop or to the end of the line if there is no earlier tab stop character ( len =* ), parameter :: lf = achar ( 10 ) ! &#94;J character ( len =* ), parameter :: vt = achar ( 11 ) ! &#94;K character ( len =* ), parameter :: ff = achar ( 12 ) ! &#94;L all give a linefeed, and if LF/NL (new-line mode) is set also a carriage return character ( len =* ), parameter :: cr = achar ( 13 ) ! &#94;M gives a carriage return; character ( len =* ), parameter :: so = achar ( 14 ) ! &#94;N activates the G1 character set; character ( len =* ), parameter :: si = achar ( 15 ) ! &#94;O activates the G0 character set; character ( len =* ), parameter :: can = achar ( 24 ) ! &#94;X interrupt escape sequences; character ( len =* ), parameter :: sub = achar ( 26 ) ! &#94;Z interrupt escape sequences; character ( len =* ), parameter :: esc = achar ( 27 ) ! &#94;[ starts an escape sequence; character ( len =* ), parameter :: del = achar ( 127 ) ! is ignored; ! codes character ( len =* ), parameter :: CODE_START = esc // '[' ! Start ANSI code, \"\". character ( len =* ), parameter :: CODE_END = 'm' ! End ANSI code, \"m\". character ( len =* ), parameter :: CODE_RESET = CODE_START // '0' // CODE_END ! Clear all styles, \"0m\". character ( len =* ), parameter :: CLEAR_DISPLAY = CODE_START // '2J' character ( len =* ), parameter :: HOME_DISPLAY = CODE_START // 'H' character ( len =* ), parameter :: BELL = achar ( 7 ) character ( len =* ), parameter :: AT_BOLD = '1' , AT_ITALIC = '3' , AT_UNDERLINE = '4' , AT_INVERSE = '7' character ( len =* ), parameter :: BLACK = '0' , RED = '1' , GREEN = '2' , YELLOW = '3' , BLUE = '4' , MAGENTA = '5' , CYAN = '6' , WHITE = '7' , DEFAULT = '9' !prefixes character ( len =* ), parameter :: FG = '3' character ( len =* ), parameter :: BG = '4' character ( len =* ), parameter :: FG_INTENSE = '9' character ( len =* ), parameter :: BG_INTENSE = '10' character ( len =* ), parameter :: ON = '' character ( len =* ), parameter :: OFF = '2' ! foreground colors character ( len =* ), parameter , public :: fg_red = CODE_START // FG // RED // CODE_END character ( len =* ), parameter , public :: fg_cyan = CODE_START // FG // CYAN // CODE_END character ( len =* ), parameter , public :: fg_magenta = CODE_START // FG // MAGENTA // CODE_END character ( len =* ), parameter , public :: fg_blue = CODE_START // FG // BLUE // CODE_END character ( len =* ), parameter , public :: fg_green = CODE_START // FG // GREEN // CODE_END character ( len =* ), parameter , public :: fg_yellow = CODE_START // FG // YELLOW // CODE_END character ( len =* ), parameter , public :: fg_white = CODE_START // FG // WHITE // CODE_END character ( len =* ), parameter , public :: fg_ebony = CODE_START // FG // BLACK // CODE_END character ( len =* ), parameter , public :: fg_black = CODE_START // FG // BLACK // CODE_END character ( len =* ), parameter , public :: fg_default = CODE_START // FG // DEFAULT // CODE_END ! background colors character ( len =* ), parameter , public :: bg_red = CODE_START // BG // RED // CODE_END character ( len =* ), parameter , public :: bg_cyan = CODE_START // BG // CYAN // CODE_END character ( len =* ), parameter , public :: bg_magenta = CODE_START // BG // MAGENTA // CODE_END character ( len =* ), parameter , public :: bg_blue = CODE_START // BG // BLUE // CODE_END character ( len =* ), parameter , public :: bg_green = CODE_START // BG // GREEN // CODE_END character ( len =* ), parameter , public :: bg_yellow = CODE_START // BG // YELLOW // CODE_END character ( len =* ), parameter , public :: bg_white = CODE_START // BG // WHITE // CODE_END character ( len =* ), parameter , public :: bg_ebony = CODE_START // BG // BLACK // CODE_END character ( len =* ), parameter , public :: bg_black = CODE_START // BG // BLACK // CODE_END character ( len =* ), parameter , public :: bg_default = CODE_START // BG // DEFAULT // CODE_END ! attributes character ( len =* ), parameter , public :: bold = CODE_START // ON // AT_BOLD // CODE_END character ( len =* ), parameter , public :: italic = CODE_START // ON // AT_ITALIC // CODE_END character ( len =* ), parameter , public :: inverse = CODE_START // ON // AT_INVERSE // CODE_END character ( len =* ), parameter , public :: underline = CODE_START // ON // AT_UNDERLINE // CODE_END character ( len =* ), parameter , public :: unbold = CODE_START // '22' // CODE_END character ( len =* ), parameter , public :: unitalic = CODE_START // OFF // AT_ITALIC // CODE_END character ( len =* ), parameter , public :: uninverse = CODE_START // OFF // AT_INVERSE // CODE_END character ( len =* ), parameter , public :: ununderline = CODE_START // OFF // AT_UNDERLINE // CODE_END character ( len =* ), parameter , public :: reset = CODE_RESET character ( len =* ), parameter , public :: clear = HOME_DISPLAY // CLEAR_DISPLAY contains !> !!##NAME !!    attr(3f) - [M_attr] substitute escape sequences for HTML-like syntax !!               in strings !!    (LICENSE:MIT) !! !!##SYNOPSIS !! !!      function attr(string,reset) result (expanded) !! !!        ! scalar !!        character(len=*),intent(in)  :: string !!        logical,intent(in),optional  :: reset !!        character(len=:),allocatable :: expanded !!        ! or array !!        character(len=*),intent(in)  :: string(:) !!        logical,intent(in),optional  :: reset !!        character(len=:),allocatable :: expanded(:) !!        integer,intent(in),optional  :: chars !! !!##DESCRIPTION !!    Use HTML-like syntax to add attributes to terminal output such as color !!    on devices that recognize ANSI escape sequences. !! !!##OPTIONS !!    string        input string  of form !! !!                    \"<attribute_name>string</attribute_name> ...\". !! !!                   where the current attributes are color names, !!                   bold, italic, underline, ... !! !!    reset          By default, a sequence to clear all text attributes !!                   is sent at the end of each returned line if an escape !!                   character appears in the output string. This can be !!                   turned off by setting RESET to .false. . !! !!                   Note if turning off the reset attributes may be !!                   continued accross lines, but if each line is not !!                   self-contained attributes may not display properly !!                   when filtered with commands such as grep(1). !! !!    chars          For arrays, a reset will be placed after the Nth !!                   displayable column count in order to make it easier !!                   to generate consistent right borders for non-default !!                   background colors for a text block. !!##KEYWORDS !!    primary default keywords !! !!      colors: !!        r,         red,       R,  RED !!        g,         green,     G,  GREEN !!        b,         blue,      B,  BLUE !!        m,         magenta,   M,  MAGENTA !!        c,         cyan,      C,  CYAN !!        y,         yellow,    Y,  YELLOW !!        e,         ebony,     E,  EBONY !!        w,         white,     W,  WHITE !! !!      attributes: !!        it,        italic !!        bo,        bold !!        un,        underline !! !!      basic control characters: !!       nul !!       bel  (0x07, &#94;G) beeps; !!       bs   (0x08, &#94;H) backspaces one column (but not past the beginning of !!                       the line); !!       ht   (0x09, &#94;I) goes to the next tab stop or to the end of the line if !!                       there is no earlier tab stop; !!       lf   (0x0A, &#94;J), !!       vt   (0x0B, &#94;K) !!       ff   (0x0C, &#94;L) all give a linefeed, and if LF/NL (new-line mode) is !!                       set also a carriage return !!       cr   (0x0D, &#94;M) gives a carriage return; !!       so   (0x0E, &#94;N) activates the G1 character set; !!       si   (0x0F, &#94;O) activates the G0 character set; !!       can  (0x18, &#94;X) and SUB (0x1A, &#94;Z) interrupt escape sequences; !!       sub !!       esc  (0x1B, &#94;[) starts an escape sequence; !!       del  (0x7F) is ignored; !! !!      other: !!        clear !!        default !!        reset !!        gt !!        lt !!        save,DECSC     Save  current state (cursor coordinates, attributes, !!                       character sets pointed at by G0, G1). !!        restore,DECRC  Restore state most recently saved by ESC 7. !!        CSI            \"Control Sequence Introducer\"(0x9B) is equivalent to !!                       \"ESC [\". !! !!      dual-value (one for color, one for mono): !! !!        write(*,*)attr('<ERROR>an error message') !!        write(*,*)attr('<WARNING>a warning message') !!        write(*,*)attr('<INFO>an informational message') !! !!    By default, if the color mnemonics (ie. the keywords) are uppercase !!    they change the background color. If lowercase, the foreground color. !!    When preceded by a \"/\" character the attribute is returned to the default. !! !!    The \"default\" keyword is typically used explicitly when !!    reset=.false, and sets all text attributes to their initial defaults. !! !!##LIMITATIONS !!    o colors are not nestable, keywords are case-sensitive, !!    o not all terminals obey the sequences. On Windows, it is best if !!      you use Windows 10+ and/or the Linux mode; although it has worked !!      with all CygWin and MinGW and Putty windows and mintty. !!    o you should use \"<gt>\" and \"<lt>\" instead of \">\" and \"<\" in a string !!      processed by attr(3f) instead of in any plain text output so that !!      the raw mode will create correct input for the attr(3f) function !!      if read back in. !! !!##EXAMPLE !! !!    Sample program !! !!     program demo_esc !!     use M_attr, only : attr, attr_mode, attr_update !!        call printstuff('defaults') !! !!        call attr_mode(manner='plain') !!        call printstuff('plain:') !! !!        call printstuff('raw') !! !!        call attr_mode(manner='color') !!        call printstuff('') !! !!        write(*,'(a)') attr('TEST ADDING A CUSTOM SEQUENCE:') !!        call attr_update('blink',char(27)//'[5m') !!        call attr_update('/blink',char(27)//'[38m') !!        write(*,'(a)') attr('<blink>Items for Friday</blink>') !! !!     contains !!     subroutine printstuff(label) !!     character(len=*),intent(in)  :: label !!     character(len=:),allocatable :: array(:) !!       call attr_mode(manner=label) !! !!       array=[character(len=60) ::    & !!        'TEST MANNER='//label,                      & !!        '<r>RED</r>,<g>GREEN</g>,<b>BLUE</b>',      & !!        '<c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y>', & !!        '<w>WHITE</w> and <e>EBONY</e>'] !!       write(*,'(a)') attr(array) !! !!       write(*,'(a)') attr('Adding <bo>bold</bo>') !!       write(*,'(a)') attr('<bo><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></bo>') !!       write(*,'(a)') attr('<bo><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y></bo>') !!       write(*,'(a)') attr('<bo><w>WHITE</w> and <e>EBONY</e></bo>') !! !!       write(*,'(a)') attr('Adding <ul>underline</ul>') !!       write(*,'(a)') attr(& !!        &'<bo><ul><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></ul></bo>') !!       write(*,'(a)') attr(& !!        &'<bo><ul><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y></ul></bo>') !!       write(*,'(a)') attr('<bo><ul><w>WHITE</w> and <e>EBONY</e></ul></bo>') !! !!       write(*,'(a)') attr('Adding <ul>italic</ul>') !!       write(*,'(a)') attr(& !!        &'<bo><ul><it><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></it></ul></bo>') !!       write(*,'(a)') attr(& !!        &'<bo><ul><it><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</it></y></ul></bo>') !!       write(*,'(a)') attr('<bo><ul><it><w>WHITE</w> and <e>EBONY</e></ul></bo>') !! !!       write(*,'(a)') attr('Adding <in>inverse</in>') !!       write(*,'(a)') attr('<in><bo><ul><it><r>RED</r>,<g>GREEN</g>,& !!        &<b>BLUE</b></it></ul></bo></in>') !!       write(*,'(a)') attr('<in><bo><ul><it><c>CYAN</c>,<m>MAGENTA</g>,& !!        &<y>YELLOW</it></y></ul></bo></in>') !!       write(*,'(a)') attr(& !!        &'<in><bo><ul><it><w>WHITE</w> and <e>EBONY</e></ul></bo></in>') !!     end subroutine printstuff !!     end program demo_esc !! !!##AUTHOR !!    John S. Urban, 2021 !! !!##LICENSE !!    MIT !! !!##SEE ALSO !!    attr_mode(3f), attr_update(3f) function attr_scalar ( string , reset ) result ( expanded ) character ( len =* ), intent ( in ) :: string logical , intent ( in ), optional :: reset logical :: clear_at_end character ( len = :), allocatable :: padded character ( len = :), allocatable :: expanded character ( len = :), allocatable :: name integer :: i integer :: ii integer :: maxlen integer :: place if ( present ( reset )) then clear_at_end = reset else clear_at_end = . true . endif if (. not . allocated ( mode )) then ! set substitution mode mode = 'color' ! 'color'|'raw'|'plain' call vt102 () endif if ( mode == 'raw' ) then expanded = string return endif maxlen = len ( string ) padded = string // ' ' i = 1 expanded = '' do select case ( padded ( i : i )) case ( '>' ) ! should not get here unless unmatched i = i + 1 expanded = expanded // '>' case ( '<' ) ! assuming not nested for now ii = index ( padded ( i + 1 :), '>' ) if ( ii . eq . 0 ) then expanded = expanded // '<' i = i + 1 else name = padded ( i + 1 : i + ii - 1 ) name = trim ( adjustl ( name )) call locate ( keywords , name , place ) if ( mode . eq . 'plain' ) then expanded = expanded // get ( name ) elseif ( place . le . 0 ) then ! unknown name; print what you found expanded = expanded // padded ( i : i + ii ) else expanded = expanded // get ( name ) endif i = ii + i + 1 endif case default expanded = expanded // padded ( i : i ) i = i + 1 end select if ( i >= maxlen + 1 ) exit enddo if ( ( index ( expanded , esc ). ne . 0 ). and .( clear_at_end )) then if (( mode . ne . 'raw' ). and .( mode . ne . 'plain' )) then expanded = expanded // CODE_RESET ! Clear all styles endif endif expanded = trim ( expanded ) end function attr_scalar function attr_matrix ( string , reset , chars ) result ( expanded ) character ( len =* ), intent ( in ) :: string (:) logical , intent ( in ), optional :: reset integer , intent ( in ), optional :: chars character ( len = :), allocatable :: expanded (:) ! gfortran does not return allocatable array from a function properly, but works with subroutine call kludge_bug ( string , reset , chars , expanded ) end function attr_matrix subroutine kludge_bug ( string , reset , chars , expanded ) character ( len =* ), intent ( in ) :: string (:) logical , intent ( in ), optional :: reset integer , intent ( in ), optional :: chars character ( len = :), allocatable :: expanded (:) integer :: width character ( len = :), allocatable :: hold integer :: i integer :: right integer :: len_local integer :: len_local2 allocate ( character ( len = 0 ) :: expanded ( 0 )) if ( present ( chars )) then right = chars else right = len ( string ) endif if (. not . allocated ( mode )) then ! set substitution mode mode = 'color' ! 'color'|'raw'|'plain' call vt102 () endif do i = 1 , size ( string ) if ( mode . eq . 'color' ) then len_local2 = len_trim ( attr_scalar ( string ( i ))) mode = 'plain' len_local = len_trim ( attr_scalar ( string ( i ))) hold = trim ( string ( i )) // repeat ( ' ' , max ( 0 , right - len_local )) mode = 'color' else hold = string ( i ) endif hold = trim ( attr_scalar ( hold , reset = reset )) width = max ( len ( hold ), len ( expanded )) expanded = [ character ( len = width ) :: expanded , hold ] enddo end subroutine kludge_bug function attr_scalar_width ( string , reset , chars ) result ( expanded ) character ( len =* ), intent ( in ) :: string logical , intent ( in ), optional :: reset integer , intent ( in ) :: chars character ( len = :), allocatable :: expanded_arr (:) character ( len = :), allocatable :: expanded expanded_arr = attr_matrix ([ string ], reset , chars ) expanded = expanded_arr ( 1 ) end function attr_scalar_width subroutine vt102 () ! create a dictionary with character keywords, values, and value lengths ! using the routines for maintaining a list call wipe_dictionary () ! insert and replace entries call attr_update ( 'bold' , bold ) call attr_update ( '/bold' , unbold ) call attr_update ( 'bo' , bold ) call attr_update ( '/bo' , unbold ) call attr_update ( 'italic' , italic ) call attr_update ( '/italic' , unitalic ) call attr_update ( 'it' , italic ) call attr_update ( '/it' , unitalic ) call attr_update ( 'inverse' , inverse ) call attr_update ( '/inverse' , uninverse ) call attr_update ( 'in' , inverse ) call attr_update ( '/in' , uninverse ) call attr_update ( 'underline' , underline ) call attr_update ( '/underline' , ununderline ) call attr_update ( 'un' , underline ) call attr_update ( '/un' , ununderline ) call attr_update ( 'ul' , underline ) call attr_update ( '/ul' , ununderline ) call attr_update ( 'bell' , BELL ) call attr_update ( 'nul' , nul ) call attr_update ( 'bel' , bel ) call attr_update ( 'bs' , bs ) call attr_update ( 'ht' , ht ) call attr_update ( 'lf' , lf ) call attr_update ( 'vt' , vt ) call attr_update ( 'ff' , ff ) call attr_update ( 'cr' , cr ) call attr_update ( 'so' , so ) call attr_update ( 'si' , si ) call attr_update ( 'can' , can ) call attr_update ( 'sub' , sub ) call attr_update ( 'esc' , esc ) call attr_update ( 'escape' , esc ) call attr_update ( 'del' , del ) call attr_update ( 'save' , esc // '7' ) call attr_update ( 'DECSC' , esc // '7' ) call attr_update ( 'restore' , esc // '8' ) call attr_update ( 'DECRC' , esc // '8' ) call attr_update ( 'CSI' , esc // '[' ) call attr_update ( 'clear' , clear ) call attr_update ( 'reset' , reset ) call attr_update ( 'gt' , '>' ) call attr_update ( 'lt' , '<' ) ! foreground colors call attr_update ( 'r' , fg_red ) call attr_update ( '/r' , fg_default ) call attr_update ( 'red' , fg_red ) call attr_update ( '/red' , fg_default ) call attr_update ( 'c' , fg_cyan ) call attr_update ( '/c' , fg_default ) call attr_update ( 'cyan' , fg_cyan ) call attr_update ( '/cyan' , fg_default ) call attr_update ( 'm' , fg_magenta ) call attr_update ( '/m' , fg_default ) call attr_update ( 'magenta' , fg_magenta ) call attr_update ( '/magenta' , fg_default ) call attr_update ( 'b' , fg_blue ) call attr_update ( '/b' , fg_default ) call attr_update ( 'blue' , fg_blue ) call attr_update ( '/blue' , fg_default ) call attr_update ( 'g' , fg_green ) call attr_update ( '/g' , fg_default ) call attr_update ( 'green' , fg_green ) call attr_update ( '/green' , fg_default ) call attr_update ( 'y' , fg_yellow ) call attr_update ( '/y' , fg_default ) call attr_update ( 'yellow' , fg_yellow ) call attr_update ( '/yellow' , fg_default ) call attr_update ( 'w' , fg_white ) call attr_update ( '/w' , fg_default ) call attr_update ( 'white' , fg_white ) call attr_update ( '/white' , fg_default ) call attr_update ( 'e' , fg_ebony ) call attr_update ( '/e' , fg_default ) call attr_update ( 'ebony' , fg_ebony ) call attr_update ( '/ebony' , fg_default ) call attr_update ( 'x' , fg_ebony ) call attr_update ( '/x' , fg_default ) call attr_update ( 'black' , fg_ebony ) call attr_update ( '/black' , fg_default ) ! background colors call attr_update ( 'R' , bg_red ) call attr_update ( '/R' , bg_default ) call attr_update ( 'RED' , bg_red ) call attr_update ( '/RED' , bg_default ) call attr_update ( 'C' , bg_cyan ) call attr_update ( '/C' , bg_default ) call attr_update ( 'CYAN' , bg_cyan ) call attr_update ( '/CYAN' , bg_default ) call attr_update ( 'M' , bg_magenta ) call attr_update ( '/M' , bg_default ) call attr_update ( 'MAGENTA' , bg_magenta ) call attr_update ( '/MAGENTA' , bg_default ) call attr_update ( 'B' , bg_blue ) call attr_update ( '/B' , bg_default ) call attr_update ( 'BLUE' , bg_blue ) call attr_update ( '/BLUE' , bg_default ) call attr_update ( 'G' , bg_green ) call attr_update ( '/G' , bg_default ) call attr_update ( 'GREEN' , bg_green ) call attr_update ( '/GREEN' , bg_default ) call attr_update ( 'Y' , bg_yellow ) call attr_update ( '/Y' , bg_default ) call attr_update ( 'YELLOW' , bg_yellow ) call attr_update ( '/YELLOW' , bg_default ) call attr_update ( 'W' , bg_white ) call attr_update ( '/W' , bg_default ) call attr_update ( 'WHITE' , bg_white ) call attr_update ( '/WHITE' , bg_default ) call attr_update ( 'E' , bg_ebony ) call attr_update ( '/E' , bg_default ) call attr_update ( 'EBONY' , bg_ebony ) call attr_update ( '/EBONY' , bg_default ) call attr_update ( 'X' , bg_ebony ) call attr_update ( '/X' , bg_default ) call attr_update ( 'BLACK' , bg_ebony ) call attr_update ( '/BLACK' , bg_default ) ! compound call attr_update ( 'ERROR' , fg_red // bold // bg_ebony // ':error:  ' // bg_default // fg_default , ':error:' ) call attr_update ( 'WARNING' , fg_yellow // bold // bg_ebony // ':warning:' // bg_default // fg_default , ':warning:' ) call attr_update ( 'INFO' , fg_green // bold // bg_ebony // ':info:   ' // bg_default // fg_default , ':info:' ) end subroutine vt102 !> !! !> !!##NAME !!    attr_mode(3f) - [M_attr] select processing mode for output from attr(3f) !!    (LICENSE:MIT) !! !!##SYNOPSIS !! !!     subroutine attr_mode(manner) !! !!        character(len=*),intent(in) :: manner !! !!##DESCRIPTION !!    Turn off the generation of strings associated with the HTML keywords !!    in the string generated by the attr(3f) function, or display the !!    text in raw mode as it was passed to attr(3f) or return to ANSI !!    escape control sequence generation. !! !!##OPTIONS !!    MANNER  The current manners or modes supported via the attr_mode(3f) !!             procedure are !! !!         plain          suppress the output associated with keywords !!         color(default) commonly supported escape sequences !!         raw            echo the input to attr(3f) as its output !!         reload         restore original keyword meanings deleted or !!                        replaced by calls to attr_update(3f). !! !!##EXAMPLE !! !!    Sample program !! !!     program demo_attr_mode !!     use M_attr, only : attr, attr_mode !!     implicit none !!     character(len=:),allocatable :: lines(:) !!     character(len=:),allocatable :: outlines(:) !!     integer :: i !!        lines=[character(len=110):: & !!        '<B><y>',& !!        '<B><y>  Suffice it to say that <W><e>black</e></W><B><y>& !!        & and <E><w>white</w></E><B><y> are also colors',& !!        '<B><y>  for their simultaneous contrast is as striking as that ',& !!        '<B><y>  of <R><g>green</g></R><B><y> and <G><r>red</r></G><B><y>,& !!        & for instance. --- <bo>Vincent van Gogh',& !!        '<B><y>',& !!        ' '] !! !!        outlines=attr(lines,chars=57) !!        write(*,'(a)')(trim(outlines(i)),i=1,size(outlines)) !! !!        call attr_mode(manner='plain') ! write as plain text !!        write(*,'(a)')attr(lines) !!        call attr_mode(manner='raw')   ! write as-is !!        write(*,'(a)')attr(lines) !! !!        call attr_mode(manner='ansi')  ! return to default mode !!        outlines=attr(lines,chars=80) !!        write(*,'(a)')(trim(outlines(i)),i=1,size(outlines)) !! !!     end program demo_attr_mode !! !!##AUTHOR !!    John S. Urban, 2021 !! !!##LICENSE !!    MIT subroutine attr_mode ( manner ) character ( len =* ), intent ( in ) :: manner integer :: i if (. not . allocated ( mode )) then ! set substitution mode mode = 'color' call vt102 () endif select case ( manner ) case ( 'vt102' , 'ANSI' , 'ansi' , 'color' , 'COLOR' ) mode = 'color' case ( 'reload' , 'default' , 'defaults' , '' ) call vt102 () mode = 'color' case ( 'raw' ) mode = 'raw' case ( 'dump' ) ! dump dictionary for debugging if ( allocated ( keywords )) then if ( size ( keywords ). gt . 0 ) then write ( stderr , '(*(a,t30,a))' ) 'KEYWORD' , 'VALUE' write ( stderr , '(*(a,t30,2(\"[\",a,\"]\"),/))' )( trim ( keywords ( i )), values ( i ), mono_values ( i ), i = 1 , size ( keywords )) endif endif case ( 'dummy' , 'plain' , 'text' ) mode = 'plain' case default write ( * , * ) 'unknown manner. Try color|raw|plain' mode = 'color' end select end subroutine attr_mode subroutine wipe_dictionary () if ( allocated ( keywords )) deallocate ( keywords ) allocate ( character ( len = 0 ) :: keywords ( 0 )) if ( allocated ( values )) deallocate ( values ) allocate ( character ( len = 0 ) :: values ( 0 )) if ( allocated ( mono_values )) deallocate ( mono_values ) allocate ( character ( len = 0 ) :: mono_values ( 0 )) end subroutine wipe_dictionary !> !! !> !!##NAME !!    attr_update(3f) - [M_attr] update internal dictionary given keyword and value !!    (LICENSE:MIT) !! !!##SYNOPSIS !! !!    subroutine attr_update(key,val) !! !!     character(len=*),intent(in)           :: key !!     character(len=*),intent(in),optional  :: val !!     character(len=*),intent(in),optional  :: mono_val !! !!##DESCRIPTION !!    Update internal dictionary in M_attr(3fm) module. !! !!##OPTIONS !!    key       name of keyword to add, replace, or delete from dictionary !!    val       if present add or replace value associated with keyword. If !!              not present remove keyword entry from dictionary. !!    mono_val  if present add or replace second value associated with !!              keyword used for plain text mode. !!              Must only be specified if VAL is also specified. !! !!##KEYWORDS !!    The following keywords are defined by default !! !!    colors: !! !!      r,red     c,cyan     w,white !!      g,green   m,magenta  e,ebony !!      b,blue    y,yellow !! !!    If the color keywords are capitalized they control the text background !!    instead of the text color. !! !!    attributes: !! !!      ul,underline !!      it,italics (often produces inverse colors on many devices !! !!##EXAMPLE !! !!    Sample program !! !!      program demo_update !!      use M_attr, only : attr, attr_update !!         write(*,'(a)') attr('<clear>TEST CUSTOMIZATIONS:') !!         ! add custom keywords !!         call attr_update('blink',char(27)//'[5m') !!         call attr_update('/blink',char(27)//'[38m') !!         write(*,*) !!         write(*,'(a)') attr('<blink>Items for Friday</blink>') !!         call attr_update('ouch',attr( & !!         ' <R><bo><w>BIG mistake!</R></w> ')) !!         write(*,*) !!         write(*,'(a)') attr('<ouch> Did not see that coming.') !!         write(*,*) !!         write(*,'(a)') attr( & !!         'ORIGINALLY: <r>Apple</r>, <b>Sky</b>, <g>Grass</g>') !!         ! delete !!         call attr_update('r') !!         call attr_update('/r') !!         ! replace (or create) !!         call attr_update('b','<<<<') !!         call attr_update('/b','>>>>') !!         write(*,*) !!         write(*,'(a)') attr( & !!         'CUSTOMIZED: <r>Apple</r>, <b>Sky</b>, <g>Grass</g>') !!      end program demo_update !! !!##AUTHOR !!    John S. Urban, 2021 !! !!##LICENSE !!    MIT subroutine attr_update ( key , valin , mono_valin ) character ( len =* ), intent ( in ) :: key character ( len =* ), intent ( in ), optional :: valin character ( len =* ), intent ( in ), optional :: mono_valin integer :: place character ( len = :), allocatable :: val character ( len = :), allocatable :: mono_val if (. not . allocated ( mode )) then ! set substitution mode mode = 'color' ! 'color'|'raw'|'plain' call vt102 () endif if ( present ( mono_valin )) then mono_val = mono_valin else mono_val = '' endif if ( present ( valin )) then val = valin ! find where string is or should be call locate ( keywords , key , place ) ! if string was not found insert it if ( place . lt . 1 ) then call insert ( keywords , key , iabs ( place )) call insert ( values , val , iabs ( place )) call insert ( mono_values , mono_val , iabs ( place )) else call replace ( values , val , place ) call replace ( mono_values , mono_val , place ) endif else call locate ( keywords , key , place ) if ( place . gt . 0 ) then call remove ( keywords , place ) call remove ( values , place ) call remove ( mono_values , place ) endif endif end subroutine attr_update function get ( key ) result ( valout ) character ( len =* ), intent ( in ) :: key character ( len = :), allocatable :: valout integer :: place ! find where string is or should be call locate ( keywords , key , place ) if ( place . lt . 1 ) then valout = '' else if ( mode . eq . 'plain' ) then valout = trim ( mono_values ( place )) else valout = trim ( values ( place )) endif endif end function get subroutine locate ( list , value , place , ier , errmsg ) character ( len =* ), intent ( in ) :: value integer , intent ( out ) :: place character ( len = :), allocatable :: list (:) integer , intent ( out ), optional :: ier character ( len =* ), intent ( out ), optional :: errmsg integer :: i character ( len = :), allocatable :: message integer :: arraysize integer :: maxtry integer :: imin , imax integer :: error if (. not . allocated ( list )) then list = [ character ( len = max ( len_trim ( value ), 2 )) :: ] endif arraysize = size ( list ) error = 0 if ( arraysize . eq . 0 ) then maxtry = 0 place =- 1 else maxtry = int ( log ( float ( arraysize )) / log ( 2.0 ) + 1.0 ) place = ( arraysize + 1 ) / 2 endif imin = 1 imax = arraysize message = '' LOOP : block do i = 1 , maxtry if ( value . eq . list ( PLACE )) then exit LOOP else if ( value . gt . list ( place )) then imax = place - 1 else imin = place + 1 endif if ( imin . gt . imax ) then place =- imin if ( iabs ( place ). gt . arraysize ) then ! ran off end of list. Where new value should go or an unsorted input array' exit LOOP endif exit LOOP endif place = ( imax + imin ) / 2 if ( place . gt . arraysize . or . place . le . 0 ) then message = '*locate* error: search is out of bounds of list. Probably an unsorted input array' error =- 1 exit LOOP endif enddo message = '*locate* exceeded allowed tries. Probably an unsorted input array' endblock LOOP if ( present ( ier )) then ier = error else if ( error . ne . 0 ) then write ( stderr , * ) message // ' VALUE=' , trim ( value ) // ' PLACE=' , place stop 1 endif if ( present ( errmsg )) then errmsg = message endif end subroutine locate subroutine remove ( list , place ) character ( len = :), allocatable :: list (:) integer , intent ( in ) :: place integer :: ii , end if (. not . allocated ( list )) then list = [ character ( len = 2 ) :: ] endif ii = len ( list ) end = size ( list ) if ( place . le . 0. or . place . gt . end ) then ! index out of bounds of array elseif ( place . eq . end ) then ! remove from array list = [ character ( len = ii ) :: list (: place - 1 ) ] else list = [ character ( len = ii ) :: list (: place - 1 ), list ( place + 1 :) ] endif end subroutine remove subroutine replace ( list , value , place ) character ( len =* ), intent ( in ) :: value character ( len = :), allocatable :: list (:) character ( len = :), allocatable :: kludge (:) integer , intent ( in ) :: place integer :: ii integer :: tlen integer :: end if (. not . allocated ( list )) then list = [ character ( len = max ( len_trim ( value ), 2 )) :: ] endif tlen = len_trim ( value ) end = size ( list ) if ( place . lt . 0. or . place . gt . end ) then write ( stderr , * ) '*replace* error: index out of range. end=' , end , ' index=' , place elseif ( len_trim ( value ). le . len ( list )) then list ( place ) = value else ! increase length of variable ii = max ( tlen , len ( list )) kludge = [ character ( len = ii ) :: list ] list = kludge list ( place ) = value endif end subroutine replace subroutine insert ( list , value , place ) character ( len =* ), intent ( in ) :: value character ( len = :), allocatable :: list (:) character ( len = :), allocatable :: kludge (:) integer , intent ( in ) :: place integer :: ii integer :: end if (. not . allocated ( list )) then list = [ character ( len = max ( len_trim ( value ), 2 )) :: ] endif ii = max ( len_trim ( value ), len ( list ), 2 ) end = size ( list ) if ( end . eq . 0 ) then ! empty array list = [ character ( len = ii ) :: value ] elseif ( place . eq . 1 ) then ! put in front of array kludge = [ character ( len = ii ) :: value , list ] list = kludge elseif ( place . gt . end ) then ! put at end of array kludge = [ character ( len = ii ) :: list , value ] list = kludge elseif ( place . ge . 2. and . place . le . end ) then ! put in middle of array kludge = [ character ( len = ii ) :: list (: place - 1 ), value , list ( place :) ] list = kludge else ! index out of range write ( stderr , * ) '*insert* error: index out of range. end=' , end , ' index=' , place , ' value=' , value endif end subroutine insert !> !! !> !!##NAME !!    advice(3f) - [M_attr] print messages using a standard format including time and program name !!    (LICENSE:MIT) !! !!##SYNOPSIS !! !!     subroutine advice(message) !! !!        character(len=*),intent(in),optional :: type !!        character(len=*),intent(in),optional :: message !! !!##DESCRIPTION !!    Display a message to stderr prefixed with the name of the !!    calling program and a timestamp when the TYPE is specified as !!    any of 'error','warn', or 'info'.  It also allows the keywords !!    <ARG0>,<TZ>,<YE>,<MO>,<DA>,<HR>,<MI>,<SE>,<MS> to be used in !!    the message (which is passed to ATTR(3f)). Note that time stamp !!    keywords will only be updated when using ADVICE(3f). !! !!##OPTIONS !!    TYPE     if present and one of 'warn','message','info' a predefined !!             message is written to stderr of the form !! !!              ** (<ARG0>): type **: <HR>:<MI>:<SE>.<MS>: message !! !!    MESSAGE  the user-supplied message to display via a call to ATTR(3f) !! !!    if no parameters are supplied the macros are updated but no output is generated. !! !!##EXAMPLE !! !!    Sample program !! !!     program demo_advice !!     use M_attr, only : advice, attr !!     implicit none !!        call advice(\"error\", \"Say you didn't!\") !!        call advice(\"warn\",  \"I wouldn't if I were you, Will Robinson.\") !!        call advice(\"info\",  \"I fixed that for you, but it was a bad idea.\") !!        call advice(\"???    \",  \"not today you don't\") !!        ! call to just update the macros !!        call advice() !!        ! conventional call to ATTR(3f) using the ADVICE(3f)-defined macros !!        write(*,*)attr('<bo>The year was <g><YE></g>, the month was <g><MO></g>') !!     end program demo_advice !!   Results: !! !!    ** (demo_advice): error   **: 16:33:50.0300: Say you didn't! !!    ** (demo_advice): warning **: 16:33:50.0301: I wouldn't if I were you, Will Robinson. !!    ** (demo_advice): info    **: 16:33:50.0301: I fixed that for you, but it was a bad idea. !!    ** (demo_advice): ???     **: 16:33:50.0301: not today you don't !!        The year was 2021, the month was 7 !! !!##AUTHOR !!    John S. Urban, 2021 !! !!##LICENSE !!    MIT subroutine advice ( type , message ) ! TODO: could add a warning level to ignore info, or info|warning, or all implicit none character ( len =* ), intent ( in ), optional :: type character ( len =* ), intent ( in ), optional :: message character ( len = 8 ) :: dt character ( len = 10 ) :: tm character ( len = 5 ) :: zone integer , dimension ( 8 ) :: values character ( len = 4096 ) :: arg0 character ( len = 4096 ) :: new_message call date_and_time ( dt , tm , zone , values ) call attr_update ( 'YE' , dt ( 1 : 4 )) call attr_update ( 'MO' , dt ( 5 : 6 )) call attr_update ( 'DA' , dt ( 7 : 8 )) call attr_update ( 'HR' , tm ( 1 : 2 )) call attr_update ( 'MI' , tm ( 3 : 4 )) call attr_update ( 'SE' , tm ( 5 : 6 )) call attr_update ( 'MS' , tm ( 8 : 10 )) call attr_update ( 'TZ' , zone ) call get_command_argument ( 0 , arg0 ) if ( index ( arg0 , '/' ). ne . 0 ) arg0 = arg0 ( index ( arg0 , '/' , back = . true .) + 1 :) if ( index ( arg0 , '\\').ne.0) arg0=arg0(index(arg0,' \\ ',back=.true.)+1:) call attr_update(' ARG0 ',arg0) if(present(type))then new_message= ' < b > '//tm(1:2)//' : '//tm(3:4)//' : '//tm(5:6)//' . '//tm(8:10)//' </ b > : '//message select case(type) case(' warn ',' WARN ',' warning ',' WARNING ') new_message= ' ** ( '//trim(arg0)//' ): < bo >< y > warning </ y > ** : '//new_message case(' info ',' INFO ',' information ',' INFORMATION ') new_message= ' ** ( '//trim(arg0)//' ): < bo >< g > info </ g > ** : '//new_message case(' error ',' ERROR ') new_message= ' ** ( '//trim(arg0)//' ): < bo >< r > error </ r > ** : '//new_message case default new_message= ' ** ( '//trim(arg0)//' ): < bo >< c > '//type//' </ c > ** : '//new_message end select write(stderr,' ( a ) ')attr(trim(new_message)) elseif(present(message))then write(stderr,' ( a ) ' ) attr ( trim ( message )) endif end subroutine advice end module M_attr","tags":"","loc":"sourcefile/m_attr.f90.html"},{"title":"redirect.F90 – M_attr","text":"Contents Programs roots Source Code redirect.F90 Source Code program roots use , intrinsic :: iso_fortran_env , only : stdin => input_unit , stdout => output_unit , stderr => error_unit use M_attr , only : attr , attr_mode , attr_update ! Calculate and print the roots of a quadratic formula even if they are complex implicit none integer , parameter :: dp = kind ( 0.0d0 ) real ( kind = dp ) :: a , b , c , discriminant real ( kind = dp ) :: x1 , x2 , x ! Real roots of the equation real ( kind = dp ) :: x_real ! Real part of complex root of the equation REAL ( kind = dp ) :: x_complex ! Imaginary part of complex root of the equation character ( len = 256 ) :: message integer :: ios character ( len = 1 ) :: paws character ( len = 1024 ) :: buffer character ( len =* ), parameter :: numbers = '(\"<B><w><bo>   \",*(\"(\",g0.8,\",\",g0.8,\")\":,1x))' character ( len = :), allocatable :: TERM if ( system_isatty ( stdout )) then ! ISATTY() is an extension, but found in Intel, GNU, PGI, ... compiler call attr_mode ( 'color' ) else call attr_mode ( 'plain' ) endif TERM = system_getenv ( 'TERM' , 'vt102' ) ! perhaps change or add strings based on terminal type select case ( TERM ) case ( 'xterm' ) call attr_update ( 'mono' , attr ( '<esc>]11;black<bel><esc>]10;white<bel>' )) ! change default bg and fg case ( 'screen' ) end select INFINITE : do ! clear screen, set attributes and print messages call text ( \"<reset><clear>\" ) call text ( \"For the quadratic equation <m>A</m><g>*x**2 +<m>B</m><g>*x + <m>C</m> \" ) write ( stdout , '(*(a))' , advance = 'no' ) & & attr ( '<B><w><bo>' // repeat ( '_' , 78 ) // '  ' ), & & char ( 13 ),& & attr ( '<B><g><bo>enter coefficients <m>A,B,C</m><g>:<y><gt><ul>' ,& & reset = . false .) read ( stdin , * , iostat = ios , iomsg = message ) a , b , c write ( stdout , '(a)' , advance = 'no' ) attr ( '<reset>' ) if ( ios . ne . 0 ) then write ( stdout , * ) write ( stdout , '(*(g0))' ) ios , ' ' , trim ( message ) rewind ( unit = stdin , iostat = ios ) backspace ( unit = stdin , iostat = ios ) else ! Given the equation \"A*X**2 + B*X + C = 0\" ! Use the quadratic formula to determine the root values of the equation. ! prompt for new value call text () call text ( 'Given the equation' ) call text () write ( buffer , '(*(g0.8))' ) '<B><w><bo>   ' , a , '<m>*X**2</m><w> + ' , b , '<m>*X</m><w> + ' , c , ' = 0' call text ( buffer ) call text () discriminant = b ** 2 - 4 * a * c if ( a . eq . 0 ) then call text ( '<ERROR> <m>If <m>a</m><g> is zero this is a linear, not quadratic equation' ) elseif ( discriminant > 0 ) then call text ( 'the <m>roots</m><g> (ie. \"x intercepts\") are <m>real<m><g> so the parabola ' ) call text ( 'crosses the x-axis at <m>two points</m><g>:' ) call text () x1 = ( - b + sqrt ( discriminant )) / ( 2 * a ) x2 = ( - b - sqrt ( discriminant )) / ( 2 * a ) write ( buffer , numbers ) x1 , 0.0d0 call text ( buffer ) write ( buffer , numbers ) x2 , 0.0d0 call text ( buffer ) call text () elseif ( discriminant == 0 ) then call text ( 'the <m>roots</m><g> (ie. \"x intercepts\") are repeated <m>(real and equal)</m><g>' ) call text ( 'so the parabola just touches the x-axis at:' ) call text () if ( b . ne . 0 ) then x = ( - b ) / ( 2 * a ) else x = 0.0d0 endif write ( buffer , numbers ) x , 0.0d0 call text ( buffer ) call text () else call text ( 'the <m>roots</m><g>(ie. \"x intercepts\")  are <m>complex</m><g>:' ) x_real = ( - b ) / ( 2 * a ) x_complex = sqrt ( abs ( discriminant )) / ( 2 * a ) call text () WRITE ( buffer , '(a,*(\"(\",g0.8,\", +i\",g0.8,\")\",:,1x))' ) '<B><w><bo>   ' , x_real , x_complex call text ( buffer ) WRITE ( buffer , '(a,*(\"(\",g0.8,\", -i\",g0.8,\")\",:,1x))' ) '<B><w><bo>   ' , x_real , x_complex call text ( buffer ) call text () endif call text ( 'with' ) call text () write ( buffer , '(g0,*(g0.8,1x))' ) \"<B><w><bo>   <m>discriminate</m><w> = \" , discriminant call text ( buffer ) call text () endif write ( stdout , '(*(g0))' , advance = 'no' ) attr ( '<B><e>press <g>return</g><e> to continue, \"<g>q</g><e>\" to quit:' , chars = 79 ) read ( stdin , advance = 'yes' , iostat = ios , fmt = '(a)' , iomsg = message ) paws if ( paws . ne . '' ) exit INFINITE enddo INFINITE contains subroutine text ( string ) character ( len =* ), intent ( in ), optional :: string if ( present ( string )) then write ( stdout , '(*(g0))' ) attr ( '<B><g><bo>' // string , chars = 80 ) else write ( stdout , '(*(g0))' ) attr ( '<B><g><bo>' , chars = 80 ) endif end subroutine text !>  call compiler-specific ISATTY() function or return .FALSE. #undef ISATTY #ifdef __INTEL_COMPILER function system_isatty ( lun ) use IFPORT integer , intent ( in ) :: lun logical :: system_isatty system_isatty = isatty ( lun ) end function system_isatty #define ISATTY #endif #ifdef __NVCOMPILER_MAJOR__X ! __NVCOMPILER_MAJOR__ __NVCOMPILER_MINOR__ __NVCOMPILER_PATCHLEVEL__ function system_isatty ( lun ) use DFPORT integer , intent ( in ) :: lun logical :: system_isatty system_isatty = isatty ( lun ) end function system_isatty #define ISATTY #endif #ifdef __GFORTRAN__ function system_isatty ( lun ) integer , intent ( in ) :: lun logical :: system_isatty system_isatty = isatty ( lun ) end function system_isatty #define ISATTY #endif #ifndef ISATTY function system_isatty ( lun ) integer , intent ( in ) :: lun logical :: system_isatty system_isatty = . false . end function system_isatty #define ISATTY #endif function system_getenv ( name , default ) result ( value ) !$@(#) M_system::system_getenv(3f): call get_environment_variable as a function with a default value(3f) character ( len =* ), intent ( in ) :: name character ( len =* ), intent ( in ), optional :: default integer :: howbig integer :: stat character ( len = :), allocatable :: value if ( NAME . ne . '' ) then call get_environment_variable ( name , length = howbig , status = stat , trim_name = . true .) ! get length required to hold value if ( howbig . ne . 0 ) then select case ( stat ) case ( 1 ) ! print *, NAME, \" is not defined in the environment. Strange...\" value = '' case ( 2 ) ! print *, \"This processor doesn't support environment variables. Boooh!\" value = '' case default ! make string to hold value of sufficient size and get value if ( allocated ( value )) deallocate ( value ) allocate ( character ( len = max ( howbig , 1 )) :: VALUE ) call get_environment_variable ( name , value , status = stat , trim_name = . true .) if ( stat . ne . 0 ) VALUE = '' end select else value = '' endif else value = '' endif if ( value . eq . '' . and . present ( default )) value = default end function system_getenv END PROGRAM roots","tags":"","loc":"sourcefile/redirect.f90.html"},{"title":"light.f90 – M_attr","text":"Contents Programs demo_attr Source Code light.f90 Source Code program demo_attr ! read stdin and run it through M_attr::attr to display color use M_attr , only : attr , attr_update implicit none character ( len = 1024 ) :: line character ( len = :), allocatable :: expanded integer :: icount integer :: ios line = '' call attr_update ( 'Z' , char ( 27 ) // '[1m' ) icount = command_argument_count () ! get number of arguments ! if command arguments use those instead of reading stdin ! example: light '<clear><B><w><bo><CSI>12;36f Good Morning! ' if ( icount . gt . 0 ) then call args () else do read ( * , '(a)' , iostat = ios ) line if ( ios . ne . 0 ) exit expanded = attr ( trim ( line )) write ( * , '(a)' ) expanded enddo write ( * , '(a)' , advance = 'no' ) attr ( '<reset>' ) endif contains subroutine args () implicit none integer :: i integer :: istat integer :: argument_length character ( len = :), allocatable :: argument do i = 1 , icount call get_command_argument ( number = i , length = argument_length ) ! allocate string array big enough to hold command line argument if ( allocated ( argument )) deallocate ( argument ) allocate ( character ( len = argument_length ) :: argument ) ! read the argument call get_command_argument ( i , argument , status = istat ) expanded = attr ( trim ( argument )) write ( * , '(a)' ) expanded enddo end subroutine args end program demo_attr","tags":"","loc":"sourcefile/light.f90.html"},{"title":"plain.f90 – M_attr","text":"Contents Programs demo_attr Source Code plain.f90 Source Code program demo_attr ! read stdin and run it through M_attr::attr to display without color use M_attr , only : attr , attr_mode implicit none character ( len = 1024 ) :: line integer :: ios line = '' call attr_mode ( manner = 'plain' ) do read ( * , '(a)' , iostat = ios ) line if ( ios . ne . 0 ) exit write ( * , '(a)' ) attr ( trim ( line )) enddo write ( * , '(a)' , advance = 'no' ) attr ( '<reset>' ) end program demo_attr","tags":"","loc":"sourcefile/plain.f90.html"},{"title":"custom.f90 – M_attr","text":"Contents Programs demo_M_attr Source Code custom.f90 Source Code program demo_M_attr use M_attr , only : attr , attr_update write ( * , '(a)' ) attr ( '<clear>TEST CUSTOMIZED:' ) ! add custom keywords call attr_update ( 'blink' , char ( 27 ) // '[5m' ) call attr_update ( '/blink' , char ( 27 ) // '[25m' ) write ( * , '(a)' ) attr ( '<blink>Items for Friday</blink> not before' ) write ( * , '(a)' , advance = 'no' ) attr ( '<r>RED</r>,' ) write ( * , '(a)' , advance = 'no' ) attr ( '<b>BLUE</b>,' ) write ( * , '(a)' , advance = 'yes' ) attr ( '<g>GREEN</g>' ) ! delete call attr_update ( 'r' ) call attr_update ( '/r' ) ! replace call attr_update ( 'b' , '<<<<' ) call attr_update ( '/b' , '>>>>' ) write ( * , '(a)' , advance = 'no' ) attr ( '<r>RED</r>,' ) write ( * , '(a)' , advance = 'no' ) attr ( '<b>BLUE</b>,' ) write ( * , '(a)' , advance = 'yes' ) attr ( '<g>GREEN</g>' ) end program demo_M_attr","tags":"","loc":"sourcefile/custom.f90.html"},{"title":"dots.f90 – M_attr","text":"Contents Programs dots Source Code dots.f90 Source Code !---------------------------------------------------------------------------------------- program dots ! @(#) random dots on screen till ctrl-C use M_attr , only : attr implicit none integer :: x , y integer :: z character ( len = 1 ) :: p integer :: fg , bg real :: r real :: c integer :: icount character ( len = 10 ), parameter :: colors ( 8 ) = [ character ( len = 10 ) :: 'RED' , 'GREEN' , 'BLUE' , 'CYAN' , 'MAGENTA' , 'YELLOW' , 'BLACK' , 'WHITE' ] fg = 8 bg = 7 r = 80 c = 24 icount = 0 INFINITE : do x = int (( c * ranf ()) + 1 ) y = int (( r * ranf ()) + 1 ) if ( ranf () > 0.9 ) then p = \"*\" else p = \" \" endif write ( * , '(*(g0))' , advance = 'no' ) attr ( '<CSI>' , reset = . false .), x , ';' , y , 'f' , p z = min ( 8 , int ( ranf () * 8 + 1 )) write ( * , '(a)' , advance = 'no' ) attr ( '<' // trim ( colors ( z )) // '>' , reset = . false .) icount = icount + 1 write ( * , '(*(g0))' , advance = 'no' ) attr ( '<CSI>1;1f' , reset = . false .), icount if ( icount . gt . 24 * 80 * 250 ) exit enddo INFINITE write ( * , * ) attr ( \"<reset>That was two hundred and fifty pages worth of dots\" ) CONTAINS !---------------------------------------------------------------------------------------- FUNCTION ranf () result ( r ) IMPLICIT NONE REAL :: r LOGICAL , SAVE :: already_run = . TRUE . IF (. NOT . already_run ) THEN CALL init_random_seed_by_clock () already_run = . TRUE . ENDIF CALL random_number ( r ) END FUNCTION ranf !---------------------------------------------------------------------------------------- SUBROUTINE init_random_seed_by_clock () implicit none INTEGER :: i , n , clock INTEGER , DIMENSION (:), ALLOCATABLE :: seed CALL RANDOM_SEED ( size = n ) ALLOCATE ( seed ( n )) CALL SYSTEM_CLOCK ( COUNT = clock ) seed = clock + 37 * ( / ( i - 1 , i = 1 , n ) / ) CALL RANDOM_SEED ( PUT = seed ) DEALLOCATE ( seed ) END SUBROUTINE init_random_seed_by_clock !---------------------------------------------------------------------------------------- END PROGRAM dots","tags":"","loc":"sourcefile/dots.f90.html"},{"title":"message.f90 – M_attr","text":"Contents Programs mode Source Code message.f90 Source Code program mode use M_attr , only : attr , attr_mode implicit none call printme ( 'color' ) call printme ( 'plain' ) call printme ( 'raw' ) contains subroutine printme ( mymode ) character ( len =* ), intent ( in ) :: mymode call attr_mode ( mymode ) write ( * , '(a)' ) mymode write ( * , '(a)' ) attr ( '<ERROR>Woe is nigh.' ) write ( * , '(a)' ) attr ( '<WARNING>The night is young.' ) write ( * , '(a)' ) attr ( '<INFO>It is Monday' ) end subroutine printme end program mode","tags":"","loc":"sourcefile/message.f90.html"},{"title":"version.f90 – M_attr","text":"Contents Programs version Source Code version.f90 Source Code program version use M_attr , only : attr , attr_update , attr_mode ! shows a limitation if periods are replaced with spaces the CHAR= option does not ! count the colored blanks so if no text after the blanks too much padding is appended to the line ! need to count last character with a background attribute or something different implicit none integer :: i !nvfortran bug!character(len=*),parameter :: text(*)= [character(len=132) :: & character ( len =* ), parameter :: text ( 23 ) = [ character ( len = 132 ) :: & '<E><e>                                                     ' ,& '<E><e>        <C>                                   </W><E><end>' ,& '<E><e>        <C>      LLL        </C><E> <bo><w>F</bo>ortran   </w></E><C>       <E><e></bo><end>' ,& '<E><e>        <C>     LL LL       </C><E>  <bo><w>P</bo>ackage  </w></E><C>       <E><e></bo><end>' ,& '<E><e>        <C>     LL          </C><E>   <bo><w>M</bo>anager </w></E><C>       <E><e></bo><end>' ,& '<E><e>        <C>   LLLLLL                          <E><end>' ,& '<E><e>        <C>     LL                            <E><end>' ,& '<E><e>        <C>     LL               LLLLL LLL    <E><end>' ,& '<E><e>        <C>     LL     LLLLLL     LL  L  LL   <E><end>' ,& '<E><e>        <C>     LL    LL     L    LL  L  LL   <E><end>' ,& '<E><e>        <C>     LL    LL     L    LL  L  LL   <E><end>' ,& '<E><e>        <C>     LL    LLLLLLL     LL  L  LL   <E><end>' ,& '<E><e>        <C>           LL                      <E><end>' ,& '<E><e>        <C>           LL                      <E><end>' ,& '<E><e>        <C>           LL                      <E><end>' ,& '<E><e>        <C>                                   <E><end>' ,& '<E><e>                                                     ' ,& '<E><bo><b>Program:</b><w>     fpm(1)                                     ' ,& '<E><bo><b>Description:</b><w> A Fortran package manager and build system ' ,& '<E><bo><b>Version:</b><w>     0.3.0, alpha                               ' ,& '<E><bo><b>License:</b><w>     MIT                                        ' ,& '<E><bo><b>Home Page:</b><w>   https://github.com/fortran-lang/fpm        ' ,& '<E><bo>' ] ! add custom keywords call attr_update ( 'end' , '.' , ' ' ) call attr_mode ( manner = 'plain' ) write ( * , '(a)' )( attr ( trim ( text ( i )), chars = 80 ), i = 1 , size ( text )) call attr_update ( 'end' , '.' , char ( 0 )) call attr_mode ( manner = 'color' ) write ( * , '(a)' )( attr ( trim ( text ( i )), chars = 80 ), i = 1 , size ( text )) end program version","tags":"","loc":"sourcefile/version.f90.html"},{"title":"help.f90 – M_attr","text":"Contents Programs fancy Source Code help.f90 Source Code program fancy use , intrinsic :: iso_fortran_env , only : stderr => ERROR_UNIT , stdin => INPUT_UNIT , stdout => OUTPUT_UNIT use M_attr , only : attr , attr_update , attr_mode implicit none integer :: i character ( len = 256 ), parameter :: help_list_nodash ( * ) = [ character ( len = 256 ) :: & !'<clear>', & '<E><w><b><bo>F</bo>ortran <bo>P</bo>ackage <bo>M</bo>anager:</b>' , & '<E><w>                                                                        ' , & '<E><w><bo>USAGE: <r><un>fpm</un></r><w> [ <r><un>SUBCOMMAND</un></r> <w>[<m>SUBCOMMAND_OPTIONS</m><w>] ]|& &<bo>[<g>--list</g><w>|<g>--help</g><w>|<g>--version</g><w>]' , & '<E><w>                                                                        ' , & '<E><w> where <r><un><bo>SUBCOMMAND</bo></un></r> <w>is commonly one of & &<bo><g>new</g><w>|<g>build</g><w>|<g>run</g><w>|<g>test</g></bo> <w>but may be any of' , & '<E><w>                                                                        ' , & '<E><w>  <bo><g>build</g></bo>     <w>Compile the package placing results in the \"build\" directory' , & '<E><w>  <bo><g>help</g></bo>      <w>Display help                                                ' , & '<E><w>  <bo><g>list</g></bo>      <w>Display this list of subcommand descriptions                ' , & '<E><w>  <bo><g>new</g></bo>       <w>Create a new Fortran package directory with sample files    ' , & '<E><w>  <bo><g>run</g></bo>       <w>Run the local package application programs                  ' , & '<E><w>  <bo><g>test</g></bo>      <w>Run the test programs                                       ' , & '<E><w>  <bo><g>update</g></bo>    <w>Update and manage project dependencies                      ' , & '<E><w>  <bo><g>install</g></bo>   <w>Install project                                             ' , & '<E><w>                                                                        ' , & '<E><w> <bo>Enter \"<r><un>fpm</un></r> <g>--list</g><w></bo>\" for a brief list of subcommand options. Enter' , & '<E><w> \"<bo><r><un>fpm</un></r> <g>--help</g></bo><w>\" or & &\"<bo><r><un>fpm</un> <un>SUBCOMMAND</un></r> <g>--help</g><w></bo>\" for detailed descriptions.' , & '<E><w>                                                                        ' , & '<E><w> <bo>Note:</bo> color mode is controlled by the environment variable FPM_COLOR. The' , & '<E><w>       set of allowable values is {<g><bo>always,never,auto</bo></g><w>}. The default is \"<g><bo>auto</bo></g><w>\". ' , & '<E><w> ' ] character ( len = 256 ), parameter :: help_list_dash ( * ) = [ character ( len = 256 ) :: & !'<clear>', & '<E><w><b><bo>F</bo>ortran </bo>P</bo>ackage <bo>M</bo>anager:</b>' , & '<E><w>                                                           ' , & '<E><w> <bo><g>build</g><w> [<g>--compiler</g> <m>COMPILER_NAME</m><w>] & &[<g>--profile</g> <m>PROF</m><w>] [<g>--flag</g> <m>FFLAGS</m><w>] [<g>--list</g><w>]' , & '<E><w>                                                           ' , & '<E><w> <bo><g>help</g><w> [<r><un>NAME(s)</un></r><w>]                       ' , & '<E><w>                                                           ' , & '<E><w> <bo><g>new</g><w> <r><un>NAME</un></r><w> [[<g>--lib</g><w>|<g>--src</g><w>] [<g>--app</g><w>] & &[<g>--test</g><w>] [<g>--example</g><w>]]|' , & '<E><w> <bo>         [<g>--full</g><w>|<g>--bare</g><w>][<g>--backfill</g><w>]' , & '<E><w>                                                           ' , & '<E><w> <bo><g>update</g><w> <w>[<r><un>NAME(s)</un></r><w>] [<g>--fetch-only</g><w>] [<g>--clean</g><w>] [<g>--verbose</g><w>]' , & '<E><w>                                                           ' , & '<E><w> <bo><g>list</g><w> [<g>--list</g><w>]' , & '<E><w>                                                           ' , & '<E><w> <bo><g>run</g><w>  [[<g>--target</g><w>] <r><un>NAME(s)</un></r> <w>[<g>--example</g><w>]& &[<g>--profile</g><w> <m>PROF</m><w>] [<g>--flag</g><w> <m>FFLAGS</m><w>] [<g>--all</g><w>]' , & '<E><w> <bo>     [<g>--runner</g><w> <m>\"CMD\"</m><w>] [<g>--compiler</g><w> <m>COMPILER_NAME</m><w>] & &[<g>--list</g><w>] [-- <m>ARGS</m><w>]' , & '<E><w>                                                           ' , & '<E><w> <bo><g>test</g><w> [[<g>--target</g><w>] <r><un>NAME(s)</un></r><w>] [<g>--profile</g><w> <m>PROF</m><w>] & &[<g>--flag</g><w> <m>FFLAGS</m><w>] [<g>--runner</g><w> <m>\"CMD\"</m><w>]' , & '<E><w> <bo>     [<g>--list</g><w>] [<g>--compiler</g><w> <m>COMPILER_NAME</m><w>] [-- <m>ARGS</m><w>]' , & '<E><w>                                                           ' , & '<E><w> <bo><g>install</g><w> [<g>--profile</g><w> <m>PROF</m>] [<g>--flag</g><w> <m>FFLAGS</m>] & &[<g>--no-rebuild</g><w>] [<g>--prefix</g><w> <m>PATH</m><w>] ' , & '<E><w> <bo>        <w>[<m>OPTIONS</m><w>]' , & '<E><w> ' ] ! shows a limitation if periods are replaced with spaces the CHAR= option does not ! count the colored blanks so if no text after the blanks too much padding is appended to the line ! need to count last character with a background attribute or something different !nvfortran bug!character(len=*),parameter :: text(*)= [character(len=132) :: & character ( len =* ), parameter :: text ( 22 ) = [ character ( len = 132 ) :: & '<E><e>                                                     ' ,& '<E><w><bo>       <C>                                   </C><E></bo><e><end>' ,& '<E><w><bo>       <C>      LLL   </C><bo><B><w> F</bo>ortran   </B><C>            </bo><W> <e></C><E><end>' ,& '<E><w><bo>       <C>     LL LL  </C><bo><B><w>  P</bo>ackage  </B><C>            </bo><W> <e></C><E><end>' ,& '<E><w><bo>       <C>     LL     </C><bo><B><w>   M</bo>anager </B><C>            </bo><W> <e></C><E><end>' ,& '<E><w><bo>       <C>   LLLLLL                          <W> <E></bo><e><end>' ,& '<E><w><bo>       <C>     LL                            <W> <E></bo><e><end>' ,& '<E><w><bo>       <C>     LL               LLLLL LLL    <W> <E></bo><e><end>' ,& '<E><w><bo>       <C>     LL     LLLLLL     LL  L  LL   <W> <E></bo><e><end>' ,& '<E><w><bo>       <C>     LL    LL     L    LL  L  LL   <W> <E></bo><e><end>' ,& '<E><w><bo>       <C>     LL    LL     L    LL  L  LL   <W> <E></bo><e><end>' ,& '<E><w><bo>       <C>     LL    LLLLLLL     LL  L  LL   <W> <E></bo><e><end>' ,& '<E><w><bo>       <C>           LL                      <W> <E></bo><e><end>' ,& '<E><w><bo>       <C>           LL                      <W> <E></bo><e><end>' ,& '<E><w><bo>       <C>           LL                      <W> <E></bo><e><end>' ,& '<E><w><bo>       <C>                                   <W> <E></bo><e><end>' ,& '<E><w><bo>        <W>                                   <E></bo><e>    <end>' ,& '<E><bo><b>Program:</b><w>     fpm(1)                                     ' ,& '<E><bo><b>Description:</b><w> package manager and build system for Fortran' ,& '<E><bo><b>Version:</b><w>     0.3.0, alpha                               ' ,& '<E><bo><b>License:</b><w>     MIT                                        ' ,& '<E><bo><b>Home Page:</b><w>   https://github.com/fortran-lang/fpm        ' ] call attr_mode ( manner = 'color' ) write ( * , '(a)' )( attr ( trim ( help_list_nodash ( i )), chars = 80 ), i = 1 , size ( help_list_nodash )) call paws () write ( * , '(a)' )( attr ( trim ( help_list_dash ( i )), chars = 80 ), i = 1 , size ( help_list_dash )) call paws () ! add custom keywords IF (. FALSE .) THEN call attr_mode ( manner = 'plain' ) call attr_update ( 'end' , '.' , ' ' ) write ( * , '(a)' )( attr ( trim ( text ( i )), chars = 80 ), i = 1 , size ( text )) call paws () ENDIF call attr_mode ( manner = 'color' ) call attr_update ( 'end' , '.' , char ( 0 )) write ( * , '(a)' )( attr ( trim ( text ( i )), chars = 80 ), i = 1 , size ( text )) call paws () contains subroutine paws () character ( len = 1 ) :: letter integer :: ios write ( stdout , '(a)' , advance = 'no' , iostat = ios ) 'Enter [RETURN] to continue ...' read ( * , '(a)' , iostat = ios ) letter write ( stdout , '(a)' ) attr ( '<clear>' ) flush ( unit = stdout , iostat = ios ) end subroutine paws end program fancy","tags":"","loc":"sourcefile/help.f90.html"},{"title":"mixed.f90 – M_attr","text":"Contents Programs demo_M_attrape Source Code mixed.f90 Source Code program demo_M_attrape use M_attr , only : attr , attr_mode , attr_update write ( * , '(a)' ) attr ( '<clear>TEST DEFAULTS:' ) call printstuff () write ( * , '(a)' ) attr ( 'TEST MANNER=PLAIN:' ) call attr_mode ( manner = 'plain' ) call printstuff () write ( * , '(a)' ) attr ( 'TEST MANNER=RAW:' ) call attr_mode ( manner = 'raw' ) call printstuff () write ( * , '(a)' ) attr ( 'TEST MANNER=VT102:' ) call attr_mode ( manner = 'vt102' ) call printstuff () write ( * , '(a)' ) attr ( 'TEST ADDING A CUSTOM SEQUENCE:' ) call attr_update ( 'blink' , char ( 27 ) // '[5m' ) call attr_update ( '/blink' , char ( 27 ) // '[38m' ) write ( * , '(a)' ) attr ( '<blink>Items for Friday</blink>' ) contains subroutine printstuff () write ( * , '(a)' ) attr ( '<r>RED</r>,<g>GREEN</g>,<b>BLUE</b>' ) write ( * , '(a)' ) attr ( '<c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y>' ) write ( * , '(a)' ) attr ( '<w>WHITE</w> and <e>EBONY</e>' ) write ( * , '(a)' ) attr ( 'Adding <bo>bold</bo>' ) write ( * , '(a)' ) attr ( '<bo><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></bo>' ) write ( * , '(a)' ) attr ( '<bo><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y></bo>' ) write ( * , '(a)' ) attr ( '<bo><w>WHITE</w> and <e>EBONY</e></bo>' ) write ( * , '(a)' ) attr ( 'Adding <ul>underline</ul>' ) write ( * , '(a)' ) attr ( '<bo><ul><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><w>WHITE</w> and <e>EBONY</e></ul></bo>' ) write ( * , '(a)' ) attr ( 'Adding <ul>italic</ul>' ) write ( * , '(a)' ) attr ( '<bo><ul><it><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></it></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><it><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</it></y></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><it><w>WHITE</w> and <e>EBONY</e></ul></bo>' ) write ( * , '(a)' ) attr ( 'Adding <in>inverse</in>' ) write ( * , '(a)' ) attr ( '<in><bo><ul><it><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></it></ul></bo></in>' ) write ( * , '(a)' ) attr ( '<in><bo><ul><it><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</it></y></ul></bo></in>' ) write ( * , '(a)' ) attr ( '<in><bo><ul><it><w>WHITE</w> and <e>EBONY</e></ul></bo></in>' ) end subroutine printstuff end program demo_M_attrape","tags":"","loc":"sourcefile/mixed.f90.html"},{"title":"dump.f90 – M_attr","text":"Contents Programs demo_dump Source Code dump.f90 Source Code program demo_dump use M_attr , only : attr write ( * , '(a)' , advance = 'no' ) attr ( '<dump>' ) end program demo_dump","tags":"","loc":"sourcefile/dump.f90.html"},{"title":"position.f90 – M_attr","text":"Contents Programs position Source Code position.f90 Source Code program position use M_attr , only : attr write ( * , '(a)' ) attr ( '<clear><B><w><bo><CSI>12;36f Good Morning! ' ) end program position","tags":"","loc":"sourcefile/position.f90.html"},{"title":"default.f90 – M_attr","text":"Contents Programs demo_M_attr Source Code default.f90 Source Code program demo_M_attr use M_attr , only : attr , attr_mode , attr_update write ( * , '(a)' ) attr ( 'TEST MANNER=DEFAULT:' ) write ( * , '(a)' ) attr ( '<r>RED</r>,<g>GREEN</g>,<b>BLUE</b>' ) write ( * , '(a)' ) attr ( '<c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y>' ) write ( * , '(a)' ) attr ( '<w>WHITE</w> and <e>EBONY</e>' ) write ( * , '(a)' ) attr ( 'Adding <bo>bold</bo>' ) write ( * , '(a)' ) attr ( '<bo><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></bo>' ) write ( * , '(a)' ) attr ( '<bo><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y></bo>' ) write ( * , '(a)' ) attr ( '<bo><w>WHITE</w> and <e>EBONY</e></bo>' ) write ( * , '(a)' ) attr ( 'Adding <ul>underline</ul>' ) write ( * , '(a)' ) attr ( '<bo><ul><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><w>WHITE</w> and <e>EBONY</e></ul></bo>' ) write ( * , '(a)' ) attr ( 'Adding <ul>italic</ul>' ) write ( * , '(a)' ) attr ( '<bo><ul><it><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></it></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><it><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</it></y></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><it><w>WHITE</w> and <e>EBONY</e></ul></bo>' ) write ( * , '(a)' ) attr ( 'Adding <in>inverse</in>' ) write ( * , '(a)' ) attr ( '<in><bo><ul><it><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></it></ul></bo></in>' ) write ( * , '(a)' ) attr ( '<in><bo><ul><it><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</it></y></ul></bo></in>' ) write ( * , '(a)' ) attr ( '<in><bo><ul><it><w>WHITE</w> and <e>EBONY</e></ul></bo></in>' ) end program demo_M_attr","tags":"","loc":"sourcefile/default.f90.html"},{"title":"demo_attr_update.f90 – M_attr","text":"Contents Programs demo_update Source Code demo_attr_update.f90 Source Code program demo_update use M_attr , only : attr , attr_update write ( * , '(a)' ) attr ( '<clear>TEST CUSTOMIZATIONS:' ) ! add custom keywords call attr_update ( 'blink' , char ( 27 ) // '[5m' ) call attr_update ( '/blink' , char ( 27 ) // '[38m' ) write ( * , * ) write ( * , '(a)' ) attr ( '<blink>Items for Friday</blink>' ) call attr_update ( 'ouch' , attr ( & ' <R><bo><w>BIG mistake!</R></w> ' )) write ( * , * ) write ( * , '(a)' ) attr ( '<ouch> Did not see that coming.' ) write ( * , * ) write ( * , '(a)' ) attr ( & 'ORIGINALLY: <r>Apple</r>, <b>Sky</b>, <g>Grass</g>' ) ! delete call attr_update ( 'r' ) call attr_update ( '/r' ) ! replace (or create) call attr_update ( 'b' , '<<<<' ) call attr_update ( '/b' , '>>>>' ) write ( * , * ) write ( * , '(a)' ) attr ( & 'CUSTOMIZED: <r>Apple</r>, <b>Sky</b>, <g>Grass</g>' ) end program demo_update","tags":"","loc":"sourcefile/demo_attr_update.f90.html"},{"title":"demo_M_attr.f90 – M_attr","text":"Contents Programs demo_M_attr Source Code demo_M_attr.f90 Source Code program demo_M_attr use M_attr , only : attr , attr_mode , attr_update implicit none character ( len = 256 ) :: line character ( len =* ), parameter :: f = '( & &\"   <bo><w><G> GREAT: </G></w>& &The new value <Y><b>\",f8.4,1x,\"</b></Y> is in range\"& &)' real :: value write ( * , '(a)' )& & attr ( '   <r><W><bo> ERROR: </W>red text on a white background</y>' ) value = 3.4567 write ( line , fmt = f ) value write ( * , '(a)' ) attr ( trim ( line )) ! write same string as plain text write ( * , * ) call attr_mode ( manner = 'plain' ) write ( * , '(a)' ) attr ( trim ( line )) call attr_mode ( manner = 'color' ) ! use pre-defined or user defined strings write ( * , * ) write ( * , '(a)' ) attr ( '<ERROR> Woe is nigh.' ) write ( * , '(a)' ) attr ( '<WARNING> The night is young.' ) write ( * , '(a)' ) attr ( '<INFO> It is Monday' ) ! create a custom mneumonic call attr_update ( 'MYERROR' , attr (& ' <R><e> E<w>-<e>R<w>-<e>R<w>-<e>O<w>-<e>R: </e></R></bo>' & )) write ( * , * ) write ( * , '(a)' ) attr ( '<MYERROR> my custom message style' ) end program demo_M_attr","tags":"","loc":"sourcefile/demo_m_attr.f90.html"},{"title":"demo_attr_mode.f90 – M_attr","text":"Contents Programs demo_attr_mode Source Code demo_attr_mode.f90 Source Code program demo_attr_mode use M_attr , only : attr , attr_mode implicit none character ( len = :), allocatable :: lines (:) character ( len = :), allocatable :: outlines (:) integer :: i lines = [ character ( len = 110 ) :: & '<B><y>' ,& '<B><y>  Suffice it to say that <W><e>black</e></W><B><y>& & and <E><w>white</w></E><B><y> are also colors' ,& '<B><y>  for their simultaneous contrast is as striking as that ' ,& '<B><y>  of <R><g>green</g></R><B><y> and <G><r>red</r></G><B><y>,& & for instance. --- <bo>Vincent van Gogh' ,& '<B><y>' ,& ' ' ] outlines = attr ( lines , chars = 57 ) write ( * , '(a)' )( trim ( outlines ( i )), i = 1 , size ( outlines )) call attr_mode ( manner = 'plain' ) ! write as plain text write ( * , '(a)' ) attr ( lines ) call attr_mode ( manner = 'raw' ) ! write as-is write ( * , '(a)' ) attr ( lines ) call attr_mode ( manner = 'ansi' ) ! return to default mode outlines = attr ( lines , chars = 80 ) write ( * , '(a)' )( trim ( outlines ( i )), i = 1 , size ( outlines )) end program demo_attr_mode","tags":"","loc":"sourcefile/demo_attr_mode.f90.html"},{"title":"demo_advice.f90 – M_attr","text":"Contents Programs demo_advice Source Code demo_advice.f90 Source Code program demo_advice use M_attr , only : advice , attr implicit none call advice ( \"error\" , \"Say you didn't!\" ) call advice ( \"warn\" , \"I wouldn't if I were you, Will Robinson.\" ) call advice ( \"info\" , \"I fixed that for you, but it was a bad idea.\" ) call advice ( \"???    \" , \"not today you don't\" ) ! call to just update the macros call advice () ! conventional call to ATTR(3f) using the ADVICE(3f)-defined macros write ( * , * ) attr ( '<bo>The year was <g><YE></g>, the month was <g><MO></g>' ) end program demo_advice","tags":"","loc":"sourcefile/demo_advice.f90.html"},{"title":"demo_attr.f90 – M_attr","text":"Contents Programs demo_esc Source Code demo_attr.f90 Source Code program demo_esc use M_attr , only : attr , attr_mode , attr_update call printstuff ( 'defaults' ) call attr_mode ( manner = 'plain' ) call printstuff ( 'plain:' ) call printstuff ( 'raw' ) call attr_mode ( manner = 'color' ) call printstuff ( '' ) write ( * , '(a)' ) attr ( 'TEST ADDING A CUSTOM SEQUENCE:' ) call attr_update ( 'blink' , char ( 27 ) // '[5m' ) call attr_update ( '/blink' , char ( 27 ) // '[38m' ) write ( * , '(a)' ) attr ( '<blink>Items for Friday</blink>' ) contains subroutine printstuff ( label ) character ( len =* ), intent ( in ) :: label character ( len = :), allocatable :: array (:) call attr_mode ( manner = label ) array = [ character ( len = 60 ) :: & 'TEST MANNER=' // label , & '<r>RED</r>,<g>GREEN</g>,<b>BLUE</b>' , & '<c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y>' , & '<w>WHITE</w> and <e>EBONY</e>' ] write ( * , '(a)' ) attr ( array ) write ( * , '(a)' ) attr ( 'Adding <bo>bold</bo>' ) write ( * , '(a)' ) attr ( '<bo><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></bo>' ) write ( * , '(a)' ) attr ( '<bo><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y></bo>' ) write ( * , '(a)' ) attr ( '<bo><w>WHITE</w> and <e>EBONY</e></bo>' ) write ( * , '(a)' ) attr ( 'Adding <ul>underline</ul>' ) write ( * , '(a)' ) attr (& & '<bo><ul><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></ul></bo>' ) write ( * , '(a)' ) attr (& & '<bo><ul><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><w>WHITE</w> and <e>EBONY</e></ul></bo>' ) write ( * , '(a)' ) attr ( 'Adding <ul>italic</ul>' ) write ( * , '(a)' ) attr (& & '<bo><ul><it><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></it></ul></bo>' ) write ( * , '(a)' ) attr (& & '<bo><ul><it><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</it></y></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><it><w>WHITE</w> and <e>EBONY</e></ul></bo>' ) write ( * , '(a)' ) attr ( 'Adding <in>inverse</in>' ) write ( * , '(a)' ) attr ( '<in><bo><ul><it><r>RED</r>,<g>GREEN</g>,& &<b>BLUE</b></it></ul></bo></in>' ) write ( * , '(a)' ) attr ( '<in><bo><ul><it><c>CYAN</c>,<m>MAGENTA</g>,& &<y>YELLOW</it></y></ul></bo></in>' ) write ( * , '(a)' ) attr (& & '<in><bo><ul><it><w>WHITE</w> and <e>EBONY</e></ul></bo></in>' ) end subroutine printstuff end program demo_esc","tags":"","loc":"sourcefile/demo_attr.f90.html"},{"title":"test_suite_M_attr.f90 – M_attr","text":"Contents Programs runtest Modules M_testsuite_M_attr Source Code test_suite_M_attr.f90 Source Code module M_testsuite_M_attr use , intrinsic :: iso_fortran_env , only : standard_in => input_unit , standard_out => output_unit , std_error => error_unit use M_verify use M_attr implicit none character ( len =* ), parameter :: options = ' -section 3 -library libGPF -filename `pwd`/m_attr.FF & & -documentation y -ufpp   y -ccall  n -archive  GPF.a ' contains !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_suite_m_attr () call test_attr () call test_attr_mode () call test_attr_update () call test_advice () end subroutine test_suite_m_attr !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_attr () logical :: allpassed integer :: i call unit_check_start ( 'attr' , ' -description display text with attributes' // OPTIONS ) allpassed = . true . call attr_mode ( 'color' ) allpassed = allpassed . and . test ( '<red>red' , char ( 27 ) // '[31mred' // char ( 27 ) // '[0m' ) allpassed = allpassed . and . test ( '<green>green' , char ( 27 ) // '[32mgreen' // char ( 27 ) // '[0m' ) allpassed = allpassed . and . test ( '<blue>blue' , char ( 27 ) // '[34mblue' // char ( 27 ) // '[0m' ) allpassed = allpassed . and . test ( '<cyan>cyan' , char ( 27 ) // '[36mcyan' // char ( 27 ) // '[0m' ) allpassed = allpassed . and . test ( '<magenta>magenta' , char ( 27 ) // '[35mmagenta' // char ( 27 ) // '[0m' ) allpassed = allpassed . and . test ( '<yellow>yellow' , char ( 27 ) // '[33myellow' // char ( 27 ) // '[0m' ) allpassed = allpassed . and . test ( '<ebony>ebony' , char ( 27 ) // '[30mebony' // char ( 27 ) // '[0m' ) allpassed = allpassed . and . test ( '<white>white' , char ( 27 ) // '[37mwhite' // char ( 27 ) // '[0m' ) allpassed = allpassed . and . test ( '<RED>RED' , char ( 27 ) // '[41mRED' // char ( 27 ) // '[0m' ) allpassed = allpassed . and . test ( '<GREEN>GREEN' , char ( 27 ) // '[42mGREEN' // char ( 27 ) // '[0m' ) allpassed = allpassed . and . test ( '<BLUE>BLUE' , char ( 27 ) // '[44mBLUE' // char ( 27 ) // '[0m' ) allpassed = allpassed . and . test ( '<CYAN>CYAN' , char ( 27 ) // '[46mCYAN' // char ( 27 ) // '[0m' ) allpassed = allpassed . and . test ( '<MAGENTA>MAGENTA' , char ( 27 ) // '[45mMAGENTA' // char ( 27 ) // '[0m' ) allpassed = allpassed . and . test ( '<YELLOW>YELLOW' , char ( 27 ) // '[43mYELLOW' // char ( 27 ) // '[0m' ) allpassed = allpassed . and . test ( '<EBONY>EBONY' , char ( 27 ) // '[40mEBONY' // char ( 27 ) // '[0m' ) allpassed = allpassed . and . test ( '<WHITE>WHITE' , char ( 27 ) // '[47mWHITE' // char ( 27 ) // '[0m' ) call attr_mode ( 'plain' ) allpassed = allpassed . and . test ( '<red>red' , 'red' ) allpassed = allpassed . and . test ( '<green>green' , 'green' ) allpassed = allpassed . and . test ( '<blue>blue' , 'blue' ) allpassed = allpassed . and . test ( '<cyan>cyan' , 'cyan' ) allpassed = allpassed . and . test ( '<magenta>magenta' , 'magenta' ) allpassed = allpassed . and . test ( '<yellow>yellow' , 'yellow' ) allpassed = allpassed . and . test ( '<ebony>ebony' , 'ebony' ) allpassed = allpassed . and . test ( '<white>white' , 'white' ) allpassed = allpassed . and . test ( '<RED>RED' , 'RED' ) allpassed = allpassed . and . test ( '<GREEN>GREEN' , 'GREEN' ) allpassed = allpassed . and . test ( '<BLUE>BLUE' , 'BLUE' ) allpassed = allpassed . and . test ( '<CYAN>CYAN' , 'CYAN' ) allpassed = allpassed . and . test ( '<MAGENTA>MAGENTA' , 'MAGENTA' ) allpassed = allpassed . and . test ( '<YELLOW>YELLOW' , 'YELLOW' ) allpassed = allpassed . and . test ( '<EBONY>EBONY' , 'EBONY' ) allpassed = allpassed . and . test ( '<WHITE>WHITE' , 'WHITE' ) call attr_mode ( 'raw' ) allpassed = allpassed . and . test ( '<red>red' , '<red>red' ) allpassed = allpassed . and . test ( '<green>green' , '<green>green' ) allpassed = allpassed . and . test ( '<blue>blue' , '<blue>blue' ) allpassed = allpassed . and . test ( '<cyan>cyan' , '<cyan>cyan' ) allpassed = allpassed . and . test ( '<magenta>magenta' , '<magenta>magenta' ) allpassed = allpassed . and . test ( '<yellow>yellow' , '<yellow>yellow' ) allpassed = allpassed . and . test ( '<ebony>ebony' , '<ebony>ebony' ) allpassed = allpassed . and . test ( '<white>white' , '<white>white' ) allpassed = allpassed . and . test ( '<RED>RED' , '<RED>RED' ) allpassed = allpassed . and . test ( '<GREEN>GREEN' , '<GREEN>GREEN' ) allpassed = allpassed . and . test ( '<BLUE>BLUE' , '<BLUE>BLUE' ) allpassed = allpassed . and . test ( '<CYAN>CYAN' , '<CYAN>CYAN' ) allpassed = allpassed . and . test ( '<MAGENTA>MAGENTA' , '<MAGENTA>MAGENTA' ) allpassed = allpassed . and . test ( '<YELLOW>YELLOW' , '<YELLOW>YELLOW' ) allpassed = allpassed . and . test ( '<EBONY>EBONY' , '<EBONY>EBONY' ) allpassed = allpassed . and . test ( '<WHITE>WHITE' , '<WHITE>WHITE' ) call unit_check ( 'attr' , allpassed , msg = '' ) call unit_check_done ( 'attr' ) contains function test ( in , ExpectedResult ) result ( passed ) character ( len =* ), intent ( in ) :: in character ( len =* ), intent ( in ) :: ExpectedResult logical :: Passed passed = attr ( in ). eq . ExpectedResult if ( passed ) then write ( std_error , * ) \"Passed on \" , in , \" converted to \" , ExpectedResult else write ( std_error , * ) \"Failed on \" , in , \" got \" , attr ( in ), \" Expected \" , ExpectedResult endif end function test end subroutine test_attr !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_attr_update () character ( len = :), allocatable :: targetline call unit_check_start ( 'attr_update' , ' ' // OPTIONS ) !call unit_check('attr_update',targetline.eq.'a b ab baaa aaCCCC CCCC CCCC a a a aa aaaaaa','example of using RANGE',targetline) if ( unit_check_level . gt . 0 ) then endif call unit_check_done ( 'attr_update' ) end subroutine test_attr_update !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_attr_mode () character ( len =* ), parameter :: in = '<B><bo>Hello!</bo></B> <G><y>Hello Again!</y></G>' character ( len =* ), parameter :: expected_color = & & char ( 27 ) // '[44m' // char ( 27 ) // '[1mHello!' // & & char ( 27 ) // '[22m' // char ( 27 ) // '[49m ' // char ( 27 ) // '[42m' // char ( 27 ) // '[33mHello Again!' // & & char ( 27 ) // '[39m' // char ( 27 ) // '[49m' // char ( 27 ) // '[0m' character ( len =* ), parameter :: expected_plain = 'Hello! Hello Again!' call unit_check_start ( 'attr_mode' , ' ' // OPTIONS ) call attr_mode ( manner = 'color' ) call unit_check ( 'attr_mode' , attr ( in ). eq . expected_color , 'color' ) call attr_mode ( manner = 'plain' ) call unit_check ( 'attr_mode' , attr ( in ). eq . expected_plain , 'plain' ) call attr_mode ( manner = 'raw' ) call unit_check ( 'attr_mode' , attr ( in ). eq . in , 'raw' ) call unit_check_done ( 'attr_mode' ) end subroutine test_attr_mode !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_advice () call unit_check_start ( 'advice' , ' ' // OPTIONS ) !call unit_check('advice',targetline.eq.'a b ab baaa aaCCCC CCCC CCCC a a a aa aaaaaa','example of using RANGE',targetline) call unit_check_done ( 'advice' ) end subroutine test_advice !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT end module M_testsuite_M_attr program runtest use M_msg use M_verify , only : unit_check_command , unit_check_keep_going , unit_check_level use M_testsuite_M_attr unit_check_command = '' unit_check_keep_going = . true . unit_check_level = 0 call test_suite_M_attr () end program runtest !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT","tags":"","loc":"sourcefile/test_suite_m_attr.f90.html"},{"title":"advice – M_attr","text":"public subroutine advice(type, message) !> NAME advice ( 3 f ) - [ M_attr ] print messages using a standard format including time and program name ( LICENSE : MIT ) SYNOPSIS subroutine advice(message)\n\n    character(len=*),intent(in),optional :: type\n    character(len=*),intent(in),optional :: message DESCRIPTION Display a message to stderr prefixed with the name of the\ncalling program and a timestamp when the TYPE is specified as\nany of 'error','warn', or 'info'.  It also allows the keywords\n<ARG0>,<TZ>,<YE>,<MO>,<DA>,<HR>,<MI>,<SE>,<MS> to be used in\nthe message (which is passed to ATTR(3f)). Note that time stamp\nkeywords will only be updated when using ADVICE(3f). OPTIONS TYPE if present and one of ' warn ' , ' message ' , ' info ' a predefined message is written to stderr of the form ** ( < ARG0 > ) : type ** : < HR > : < MI > : < SE > . < MS > : message MESSAGE the user - supplied message to display via a call to ATTR ( 3 f ) if no parameters are supplied the macros are updated but no output is generated . EXAMPLE Sample program\n\n program demo_advice\n use M_attr, only : advice, attr\n implicit none\n    call advice(\"error\", \"Say you didn't!\")\n    call advice(\"warn\",  \"I wouldn't if I were you, Will Robinson.\")\n    call advice(\"info\",  \"I fixed that for you, but it was a bad idea.\")\n    call advice(\"???    \",  \"not today you don't\")\n    ! call to just update the macros\n    call advice()\n    ! conventional call to ATTR(3f) using the ADVICE(3f)-defined macros\n    write(*,*)attr(' <bo> The year was <g><YE></g> , the month was <g><MO></g> ')\n end program demo_advice Results: ** ( demo_advice ) : error ** : 16 : 33 : 50 . 0300 : Say you didn ' t! ** ( demo_advice ) : warning ** : 16 : 33 : 50 . 0301 : I wouldn ' t if I were you, Will Robinson. ** ( demo_advice ) : info ** : 16 : 33 : 50 . 0301 : I fixed that for you , but it was a bad idea . ** ( demo_advice ) : ??? ** : 16 : 33 : 50 . 0301 : not today you don ' t The year was 2021 , the month was 7 AUTHOR John S. Urban, 2021 LICENSE MIT Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: type character(len=*), intent(in), optional :: message Contents Variables arg0 dt new_message tm values zone Source Code advice Variables Type Visibility Attributes Name Initial character(len=4096), public :: arg0 character(len=8), public :: dt character(len=4096), public :: new_message character(len=10), public :: tm integer, public, dimension(8) :: values character(len=5), public :: zone Source Code subroutine advice ( type , message ) ! TODO: could add a warning level to ignore info, or info|warning, or all implicit none character ( len =* ), intent ( in ), optional :: type character ( len =* ), intent ( in ), optional :: message character ( len = 8 ) :: dt character ( len = 10 ) :: tm character ( len = 5 ) :: zone integer , dimension ( 8 ) :: values character ( len = 4096 ) :: arg0 character ( len = 4096 ) :: new_message call date_and_time ( dt , tm , zone , values ) call attr_update ( 'YE' , dt ( 1 : 4 )) call attr_update ( 'MO' , dt ( 5 : 6 )) call attr_update ( 'DA' , dt ( 7 : 8 )) call attr_update ( 'HR' , tm ( 1 : 2 )) call attr_update ( 'MI' , tm ( 3 : 4 )) call attr_update ( 'SE' , tm ( 5 : 6 )) call attr_update ( 'MS' , tm ( 8 : 10 )) call attr_update ( 'TZ' , zone ) call get_command_argument ( 0 , arg0 ) if ( index ( arg0 , '/' ). ne . 0 ) arg0 = arg0 ( index ( arg0 , '/' , back = . true .) + 1 :) if ( index ( arg0 , '\\').ne.0) arg0=arg0(index(arg0,' \\ ',back=.true.)+1:) call attr_update(' ARG0 ',arg0) if(present(type))then new_message= ' < b > '//tm(1:2)//' : '//tm(3:4)//' : '//tm(5:6)//' . '//tm(8:10)//' </ b > : '//message select case(type) case(' warn ',' WARN ',' warning ',' WARNING ') new_message= ' ** ( '//trim(arg0)//' ): < bo >< y > warning </ y > ** : '//new_message case(' info ',' INFO ',' information ',' INFORMATION ') new_message= ' ** ( '//trim(arg0)//' ): < bo >< g > info </ g > ** : '//new_message case(' error ',' ERROR ') new_message= ' ** ( '//trim(arg0)//' ): < bo >< r > error </ r > ** : '//new_message case default new_message= ' ** ( '//trim(arg0)//' ): < bo >< c > '//type//' </ c > ** : '//new_message end select write(stderr,' ( a ) ')attr(trim(new_message)) elseif(present(message))then write(stderr,' ( a ) ' ) attr ( trim ( message )) endif end subroutine advice","tags":"","loc":"proc/advice.html"},{"title":"attr_mode – M_attr","text":"public subroutine attr_mode(manner) !> NAME attr_mode ( 3 f ) - [ M_attr ] select processing mode for output from attr ( 3 f ) ( LICENSE : MIT ) SYNOPSIS subroutine attr_mode(manner)\n\n    character(len=*),intent(in) :: manner DESCRIPTION Turn off the generation of strings associated with the HTML keywords in the string generated by the attr ( 3 f ) function , or display the text in raw mode as it was passed to attr ( 3 f ) or return to ANSI escape control sequence generation . OPTIONS MANNER The current manners or modes supported via the attr_mode ( 3 f ) procedure are plain suppress the output associated with keywords color ( default ) commonly supported escape sequences raw echo the input to attr ( 3 f ) as its output reload restore original keyword meanings deleted or replaced by calls to attr_update ( 3 f ) . EXAMPLE Sample program\n\n program demo_attr_mode\n use M_attr, only : attr, attr_mode\n implicit none\n character(len=:),allocatable :: lines(:)\n character(len=:),allocatable :: outlines(:)\n integer :: i\n    lines=[character(len=110):: & ' <B><y> ', & ' <B><y> Suffice it to say that <W><e> black </e></W><B><y> & & and <E><w> white </w></E><B><y> are also colors', & ' <B><y> for their simultaneous contrast is as striking as that ', & ' <B><y> of <R><g> green </g></R><B><y> and <G><r> red </r></G><B><y> , & & for instance. --- <bo> Vincent van Gogh', & ' <B><y> ', & ' ']\n\n    outlines=attr(lines,chars=57)\n    write(*,'(a)')(trim(outlines(i)),i=1,size(outlines))\n\n    call attr_mode(manner='plain') ! write as plain text\n    write(*,'(a)')attr(lines)\n    call attr_mode(manner='raw')   ! write as-is\n    write(*,'(a)')attr(lines)\n\n    call attr_mode(manner='ansi')  ! return to default mode\n    outlines=attr(lines,chars=80)\n    write(*,'(a)')(trim(outlines(i)),i=1,size(outlines))\n\n end program demo_attr_mode AUTHOR John S. Urban, 2021 LICENSE MIT Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: manner Contents Variables i Source Code attr_mode Variables Type Visibility Attributes Name Initial integer, public :: i Source Code subroutine attr_mode ( manner ) character ( len =* ), intent ( in ) :: manner integer :: i if (. not . allocated ( mode )) then ! set substitution mode mode = 'color' call vt102 () endif select case ( manner ) case ( 'vt102' , 'ANSI' , 'ansi' , 'color' , 'COLOR' ) mode = 'color' case ( 'reload' , 'default' , 'defaults' , '' ) call vt102 () mode = 'color' case ( 'raw' ) mode = 'raw' case ( 'dump' ) ! dump dictionary for debugging if ( allocated ( keywords )) then if ( size ( keywords ). gt . 0 ) then write ( stderr , '(*(a,t30,a))' ) 'KEYWORD' , 'VALUE' write ( stderr , '(*(a,t30,2(\"[\",a,\"]\"),/))' )( trim ( keywords ( i )), values ( i ), mono_values ( i ), i = 1 , size ( keywords )) endif endif case ( 'dummy' , 'plain' , 'text' ) mode = 'plain' case default write ( * , * ) 'unknown manner. Try color|raw|plain' mode = 'color' end select end subroutine attr_mode","tags":"","loc":"proc/attr_mode.html"},{"title":"attr_update – M_attr","text":"public subroutine attr_update(key, valin, mono_valin) !> NAME attr_update ( 3 f ) - [ M_attr ] update internal dictionary given keyword and value ( LICENSE : MIT ) SYNOPSIS subroutine attr_update(key,val)\n\n character(len=*),intent(in)           :: key\n character(len=*),intent(in),optional  :: val\n character(len=*),intent(in),optional  :: mono_val DESCRIPTION Update internal dictionary in M_attr(3fm) module. OPTIONS key name of keyword to add , replace , or delete from dictionary val if present add or replace value associated with keyword . If not present remove keyword entry from dictionary . mono_val if present add or replace second value associated with keyword used for plain text mode . Must only be specified if VAL is also specified . KEYWORDS The following keywords are defined by default colors : r , red c , cyan w , white g , green m , magenta e , ebony b , blue y , yellow If the color keywords are capitalized they control the text background instead of the text color . attributes : ul , underline it , italics ( often produces inverse colors on many devices EXAMPLE Sample program\n\n  program demo_update\n  use M_attr, only : attr, attr_update\n     write(*,'(a)') attr(' <clear> TEST CUSTOMIZATIONS:')\n     ! add custom keywords\n     call attr_update('blink',char(27)//'[5m')\n     call attr_update('/blink',char(27)//'[38m')\n     write(*,*)\n     write(*,'(a)') attr(' <blink> Items for Friday </blink> ')\n     call attr_update('ouch',attr( & ' <R><bo><w> BIG mistake! </R></w> '))\n     write(*,*)\n     write(*,'(a)') attr(' <ouch> Did not see that coming.')\n     write(*,*)\n     write(*,'(a)') attr( & 'ORIGINALLY: <r> Apple </r> , <b> Sky </b> , <g> Grass </g> ')\n     ! delete\n     call attr_update('r')\n     call attr_update('/r')\n     ! replace (or create)\n     call attr_update('b',' <<<< ')\n     call attr_update('/b','>>>>')\n     write(*,*)\n     write(*,'(a)') attr( & 'CUSTOMIZED: <r> Apple </r> , <b> Sky </b> , <g> Grass </g> ')\n  end program demo_update AUTHOR John S. Urban, 2021 LICENSE MIT Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: key character(len=*), intent(in), optional :: valin character(len=*), intent(in), optional :: mono_valin Contents Variables mono_val place val Source Code attr_update Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: mono_val integer, public :: place character(len=:), public, allocatable :: val Source Code subroutine attr_update ( key , valin , mono_valin ) character ( len =* ), intent ( in ) :: key character ( len =* ), intent ( in ), optional :: valin character ( len =* ), intent ( in ), optional :: mono_valin integer :: place character ( len = :), allocatable :: val character ( len = :), allocatable :: mono_val if (. not . allocated ( mode )) then ! set substitution mode mode = 'color' ! 'color'|'raw'|'plain' call vt102 () endif if ( present ( mono_valin )) then mono_val = mono_valin else mono_val = '' endif if ( present ( valin )) then val = valin ! find where string is or should be call locate ( keywords , key , place ) ! if string was not found insert it if ( place . lt . 1 ) then call insert ( keywords , key , iabs ( place )) call insert ( values , val , iabs ( place )) call insert ( mono_values , mono_val , iabs ( place )) else call replace ( values , val , place ) call replace ( mono_values , mono_val , place ) endif else call locate ( keywords , key , place ) if ( place . gt . 0 ) then call remove ( keywords , place ) call remove ( values , place ) call remove ( mono_values , place ) endif endif end subroutine attr_update","tags":"","loc":"proc/attr_update.html"},{"title":"attr – M_attr","text":"public interface attr Contents Module Procedures attr_scalar attr_matrix attr_scalar_width Module Procedures private function attr_scalar(string, reset) result(expanded) Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string logical, intent(in), optional :: reset Return Value character(len=:),\n  allocatable private function attr_matrix(string, reset, chars) result(expanded) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string (:) logical, intent(in), optional :: reset integer, intent(in), optional :: chars Return Value character(len=:),\n  allocatable, (:) private function attr_scalar_width(string, reset, chars) result(expanded) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string logical, intent(in), optional :: reset integer, intent(in) :: chars Return Value character(len=:),\n  allocatable","tags":"","loc":"interface/attr.html"},{"title":"system_getenv – M_attr","text":"function system_getenv(name, default) result(value) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name character(len=*), intent(in), optional :: default Return Value character(len=:),\n  allocatable Contents Variables howbig stat Source Code system_getenv Variables Type Visibility Attributes Name Initial integer, public :: howbig integer, public :: stat Source Code function system_getenv ( name , default ) result ( value ) !$@(#) M_system::system_getenv(3f): call get_environment_variable as a function with a default value(3f) character ( len =* ), intent ( in ) :: name character ( len =* ), intent ( in ), optional :: default integer :: howbig integer :: stat character ( len = :), allocatable :: value if ( NAME . ne . '' ) then call get_environment_variable ( name , length = howbig , status = stat , trim_name = . true .) ! get length required to hold value if ( howbig . ne . 0 ) then select case ( stat ) case ( 1 ) ! print *, NAME, \" is not defined in the environment. Strange...\" value = '' case ( 2 ) ! print *, \"This processor doesn't support environment variables. Boooh!\" value = '' case default ! make string to hold value of sufficient size and get value if ( allocated ( value )) deallocate ( value ) allocate ( character ( len = max ( howbig , 1 )) :: VALUE ) call get_environment_variable ( name , value , status = stat , trim_name = . true .) if ( stat . ne . 0 ) VALUE = '' end select else value = '' endif else value = '' endif if ( value . eq . '' . and . present ( default )) value = default end function system_getenv","tags":"","loc":"proc/system_getenv.html"},{"title":"system_isatty – M_attr","text":"function system_isatty(lun) call compiler-specific ISATTY() function or return .FALSE. Arguments Type Intent Optional Attributes Name integer, intent(in) :: lun Return Value logical Contents Source Code system_isatty Source Code function system_isatty ( lun ) use IFPORT integer , intent ( in ) :: lun logical :: system_isatty system_isatty = isatty ( lun ) end function system_isatty","tags":"","loc":"proc/system_isatty.html"},{"title":"text – M_attr","text":"subroutine text(string) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: string Contents Source Code text Source Code subroutine text ( string ) character ( len =* ), intent ( in ), optional :: string if ( present ( string )) then write ( stdout , '(*(g0))' ) attr ( '<B><g><bo>' // string , chars = 80 ) else write ( stdout , '(*(g0))' ) attr ( '<B><g><bo>' , chars = 80 ) endif end subroutine text","tags":"","loc":"proc/text.html"},{"title":"args – M_attr","text":"subroutine args() Arguments None Contents Variables argument argument_length i istat Source Code args Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: argument integer, public :: argument_length integer, public :: i integer, public :: istat Source Code subroutine args () implicit none integer :: i integer :: istat integer :: argument_length character ( len = :), allocatable :: argument do i = 1 , icount call get_command_argument ( number = i , length = argument_length ) ! allocate string array big enough to hold command line argument if ( allocated ( argument )) deallocate ( argument ) allocate ( character ( len = argument_length ) :: argument ) ! read the argument call get_command_argument ( i , argument , status = istat ) expanded = attr ( trim ( argument )) write ( * , '(a)' ) expanded enddo end subroutine args","tags":"","loc":"proc/args.html"},{"title":"ranf – M_attr","text":"function ranf() result(r) Arguments None Return Value real Contents Variables already_run Source Code ranf Variables Type Visibility Attributes Name Initial logical, public, SAVE :: already_run = .TRUE. Source Code FUNCTION ranf () result ( r ) IMPLICIT NONE REAL :: r LOGICAL , SAVE :: already_run = . TRUE . IF (. NOT . already_run ) THEN CALL init_random_seed_by_clock () already_run = . TRUE . ENDIF CALL random_number ( r ) END FUNCTION ranf","tags":"","loc":"proc/ranf.html"},{"title":"init_random_seed_by_clock – M_attr","text":"subroutine init_random_seed_by_clock() Arguments None Contents Variables clock i n seed Source Code init_random_seed_by_clock Variables Type Visibility Attributes Name Initial integer, public :: clock integer, public :: i integer, public :: n integer, public, DIMENSION(:), ALLOCATABLE :: seed Source Code SUBROUTINE init_random_seed_by_clock () implicit none INTEGER :: i , n , clock INTEGER , DIMENSION (:), ALLOCATABLE :: seed CALL RANDOM_SEED ( size = n ) ALLOCATE ( seed ( n )) CALL SYSTEM_CLOCK ( COUNT = clock ) seed = clock + 37 * ( / ( i - 1 , i = 1 , n ) / ) CALL RANDOM_SEED ( PUT = seed ) DEALLOCATE ( seed ) END SUBROUTINE init_random_seed_by_clock","tags":"","loc":"proc/init_random_seed_by_clock.html"},{"title":"printme – M_attr","text":"subroutine printme(mymode) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: mymode Contents Source Code printme Source Code subroutine printme ( mymode ) character ( len =* ), intent ( in ) :: mymode call attr_mode ( mymode ) write ( * , '(a)' ) mymode write ( * , '(a)' ) attr ( '<ERROR>Woe is nigh.' ) write ( * , '(a)' ) attr ( '<WARNING>The night is young.' ) write ( * , '(a)' ) attr ( '<INFO>It is Monday' ) end subroutine printme","tags":"","loc":"proc/printme.html"},{"title":"paws – M_attr","text":"subroutine paws() Arguments None Contents Variables ios letter Source Code paws Variables Type Visibility Attributes Name Initial integer, public :: ios character(len=1), public :: letter Source Code subroutine paws () character ( len = 1 ) :: letter integer :: ios write ( stdout , '(a)' , advance = 'no' , iostat = ios ) 'Enter [RETURN] to continue ...' read ( * , '(a)' , iostat = ios ) letter write ( stdout , '(a)' ) attr ( '<clear>' ) flush ( unit = stdout , iostat = ios ) end subroutine paws","tags":"","loc":"proc/paws.html"},{"title":"printstuff – M_attr","text":"subroutine printstuff() Arguments None Contents Source Code printstuff Source Code subroutine printstuff () write ( * , '(a)' ) attr ( '<r>RED</r>,<g>GREEN</g>,<b>BLUE</b>' ) write ( * , '(a)' ) attr ( '<c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y>' ) write ( * , '(a)' ) attr ( '<w>WHITE</w> and <e>EBONY</e>' ) write ( * , '(a)' ) attr ( 'Adding <bo>bold</bo>' ) write ( * , '(a)' ) attr ( '<bo><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></bo>' ) write ( * , '(a)' ) attr ( '<bo><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y></bo>' ) write ( * , '(a)' ) attr ( '<bo><w>WHITE</w> and <e>EBONY</e></bo>' ) write ( * , '(a)' ) attr ( 'Adding <ul>underline</ul>' ) write ( * , '(a)' ) attr ( '<bo><ul><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><w>WHITE</w> and <e>EBONY</e></ul></bo>' ) write ( * , '(a)' ) attr ( 'Adding <ul>italic</ul>' ) write ( * , '(a)' ) attr ( '<bo><ul><it><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></it></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><it><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</it></y></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><it><w>WHITE</w> and <e>EBONY</e></ul></bo>' ) write ( * , '(a)' ) attr ( 'Adding <in>inverse</in>' ) write ( * , '(a)' ) attr ( '<in><bo><ul><it><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></it></ul></bo></in>' ) write ( * , '(a)' ) attr ( '<in><bo><ul><it><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</it></y></ul></bo></in>' ) write ( * , '(a)' ) attr ( '<in><bo><ul><it><w>WHITE</w> and <e>EBONY</e></ul></bo></in>' ) end subroutine printstuff","tags":"","loc":"proc/printstuff.html"},{"title":"printstuff – M_attr","text":"subroutine printstuff(label) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: label Contents Variables array Source Code printstuff Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: array (:) Source Code subroutine printstuff ( label ) character ( len =* ), intent ( in ) :: label character ( len = :), allocatable :: array (:) call attr_mode ( manner = label ) array = [ character ( len = 60 ) :: & 'TEST MANNER=' // label , & '<r>RED</r>,<g>GREEN</g>,<b>BLUE</b>' , & '<c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y>' , & '<w>WHITE</w> and <e>EBONY</e>' ] write ( * , '(a)' ) attr ( array ) write ( * , '(a)' ) attr ( 'Adding <bo>bold</bo>' ) write ( * , '(a)' ) attr ( '<bo><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></bo>' ) write ( * , '(a)' ) attr ( '<bo><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y></bo>' ) write ( * , '(a)' ) attr ( '<bo><w>WHITE</w> and <e>EBONY</e></bo>' ) write ( * , '(a)' ) attr ( 'Adding <ul>underline</ul>' ) write ( * , '(a)' ) attr (& & '<bo><ul><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></ul></bo>' ) write ( * , '(a)' ) attr (& & '<bo><ul><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><w>WHITE</w> and <e>EBONY</e></ul></bo>' ) write ( * , '(a)' ) attr ( 'Adding <ul>italic</ul>' ) write ( * , '(a)' ) attr (& & '<bo><ul><it><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></it></ul></bo>' ) write ( * , '(a)' ) attr (& & '<bo><ul><it><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</it></y></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><it><w>WHITE</w> and <e>EBONY</e></ul></bo>' ) write ( * , '(a)' ) attr ( 'Adding <in>inverse</in>' ) write ( * , '(a)' ) attr ( '<in><bo><ul><it><r>RED</r>,<g>GREEN</g>,& &<b>BLUE</b></it></ul></bo></in>' ) write ( * , '(a)' ) attr ( '<in><bo><ul><it><c>CYAN</c>,<m>MAGENTA</g>,& &<y>YELLOW</it></y></ul></bo></in>' ) write ( * , '(a)' ) attr (& & '<in><bo><ul><it><w>WHITE</w> and <e>EBONY</e></ul></bo></in>' ) end subroutine printstuff","tags":"","loc":"proc/printstuff~2.html"},{"title":"test_advice – M_attr","text":"public subroutine test_advice() Arguments None Contents Source Code test_advice Source Code subroutine test_advice () call unit_check_start ( 'advice' , ' ' // OPTIONS ) !call unit_check('advice',targetline.eq.'a b ab baaa aaCCCC CCCC CCCC a a a aa aaaaaa','example of using RANGE',targetline) call unit_check_done ( 'advice' ) end subroutine test_advice","tags":"","loc":"proc/test_advice.html"},{"title":"test_attr – M_attr","text":"public subroutine test_attr() Arguments None Contents Variables allpassed i Functions test Source Code test_attr Variables Type Visibility Attributes Name Initial logical, public :: allpassed integer, public :: i Functions function test(in, ExpectedResult) result(Passed) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: in character(len=*), intent(in) :: ExpectedResult Return Value logical Source Code subroutine test_attr () logical :: allpassed integer :: i call unit_check_start ( 'attr' , ' -description display text with attributes' // OPTIONS ) allpassed = . true . call attr_mode ( 'color' ) allpassed = allpassed . and . test ( '<red>red' , char ( 27 ) // '[31mred' // char ( 27 ) // '[0m' ) allpassed = allpassed . and . test ( '<green>green' , char ( 27 ) // '[32mgreen' // char ( 27 ) // '[0m' ) allpassed = allpassed . and . test ( '<blue>blue' , char ( 27 ) // '[34mblue' // char ( 27 ) // '[0m' ) allpassed = allpassed . and . test ( '<cyan>cyan' , char ( 27 ) // '[36mcyan' // char ( 27 ) // '[0m' ) allpassed = allpassed . and . test ( '<magenta>magenta' , char ( 27 ) // '[35mmagenta' // char ( 27 ) // '[0m' ) allpassed = allpassed . and . test ( '<yellow>yellow' , char ( 27 ) // '[33myellow' // char ( 27 ) // '[0m' ) allpassed = allpassed . and . test ( '<ebony>ebony' , char ( 27 ) // '[30mebony' // char ( 27 ) // '[0m' ) allpassed = allpassed . and . test ( '<white>white' , char ( 27 ) // '[37mwhite' // char ( 27 ) // '[0m' ) allpassed = allpassed . and . test ( '<RED>RED' , char ( 27 ) // '[41mRED' // char ( 27 ) // '[0m' ) allpassed = allpassed . and . test ( '<GREEN>GREEN' , char ( 27 ) // '[42mGREEN' // char ( 27 ) // '[0m' ) allpassed = allpassed . and . test ( '<BLUE>BLUE' , char ( 27 ) // '[44mBLUE' // char ( 27 ) // '[0m' ) allpassed = allpassed . and . test ( '<CYAN>CYAN' , char ( 27 ) // '[46mCYAN' // char ( 27 ) // '[0m' ) allpassed = allpassed . and . test ( '<MAGENTA>MAGENTA' , char ( 27 ) // '[45mMAGENTA' // char ( 27 ) // '[0m' ) allpassed = allpassed . and . test ( '<YELLOW>YELLOW' , char ( 27 ) // '[43mYELLOW' // char ( 27 ) // '[0m' ) allpassed = allpassed . and . test ( '<EBONY>EBONY' , char ( 27 ) // '[40mEBONY' // char ( 27 ) // '[0m' ) allpassed = allpassed . and . test ( '<WHITE>WHITE' , char ( 27 ) // '[47mWHITE' // char ( 27 ) // '[0m' ) call attr_mode ( 'plain' ) allpassed = allpassed . and . test ( '<red>red' , 'red' ) allpassed = allpassed . and . test ( '<green>green' , 'green' ) allpassed = allpassed . and . test ( '<blue>blue' , 'blue' ) allpassed = allpassed . and . test ( '<cyan>cyan' , 'cyan' ) allpassed = allpassed . and . test ( '<magenta>magenta' , 'magenta' ) allpassed = allpassed . and . test ( '<yellow>yellow' , 'yellow' ) allpassed = allpassed . and . test ( '<ebony>ebony' , 'ebony' ) allpassed = allpassed . and . test ( '<white>white' , 'white' ) allpassed = allpassed . and . test ( '<RED>RED' , 'RED' ) allpassed = allpassed . and . test ( '<GREEN>GREEN' , 'GREEN' ) allpassed = allpassed . and . test ( '<BLUE>BLUE' , 'BLUE' ) allpassed = allpassed . and . test ( '<CYAN>CYAN' , 'CYAN' ) allpassed = allpassed . and . test ( '<MAGENTA>MAGENTA' , 'MAGENTA' ) allpassed = allpassed . and . test ( '<YELLOW>YELLOW' , 'YELLOW' ) allpassed = allpassed . and . test ( '<EBONY>EBONY' , 'EBONY' ) allpassed = allpassed . and . test ( '<WHITE>WHITE' , 'WHITE' ) call attr_mode ( 'raw' ) allpassed = allpassed . and . test ( '<red>red' , '<red>red' ) allpassed = allpassed . and . test ( '<green>green' , '<green>green' ) allpassed = allpassed . and . test ( '<blue>blue' , '<blue>blue' ) allpassed = allpassed . and . test ( '<cyan>cyan' , '<cyan>cyan' ) allpassed = allpassed . and . test ( '<magenta>magenta' , '<magenta>magenta' ) allpassed = allpassed . and . test ( '<yellow>yellow' , '<yellow>yellow' ) allpassed = allpassed . and . test ( '<ebony>ebony' , '<ebony>ebony' ) allpassed = allpassed . and . test ( '<white>white' , '<white>white' ) allpassed = allpassed . and . test ( '<RED>RED' , '<RED>RED' ) allpassed = allpassed . and . test ( '<GREEN>GREEN' , '<GREEN>GREEN' ) allpassed = allpassed . and . test ( '<BLUE>BLUE' , '<BLUE>BLUE' ) allpassed = allpassed . and . test ( '<CYAN>CYAN' , '<CYAN>CYAN' ) allpassed = allpassed . and . test ( '<MAGENTA>MAGENTA' , '<MAGENTA>MAGENTA' ) allpassed = allpassed . and . test ( '<YELLOW>YELLOW' , '<YELLOW>YELLOW' ) allpassed = allpassed . and . test ( '<EBONY>EBONY' , '<EBONY>EBONY' ) allpassed = allpassed . and . test ( '<WHITE>WHITE' , '<WHITE>WHITE' ) call unit_check ( 'attr' , allpassed , msg = '' ) call unit_check_done ( 'attr' ) contains function test ( in , ExpectedResult ) result ( passed ) character ( len =* ), intent ( in ) :: in character ( len =* ), intent ( in ) :: ExpectedResult logical :: Passed passed = attr ( in ). eq . ExpectedResult if ( passed ) then write ( std_error , * ) \"Passed on \" , in , \" converted to \" , ExpectedResult else write ( std_error , * ) \"Failed on \" , in , \" got \" , attr ( in ), \" Expected \" , ExpectedResult endif end function test end subroutine test_attr","tags":"","loc":"proc/test_attr.html"},{"title":"test_attr_mode – M_attr","text":"public subroutine test_attr_mode() Arguments None Contents Variables expected_color expected_plain in Source Code test_attr_mode Variables Type Visibility Attributes Name Initial character(len=*), public, parameter :: expected_color = char(27)//'[44m'//char(27)//'[1mHello!'//char(27)//'[22m'//char(27)//'[49m '//char(27)//'[42m'//char(27)//'[33mHello Again!'//char(27)//'[39m'//char(27)//'[49m'//char(27)//'[0m' character(len=*), public, parameter :: expected_plain = 'Hello! Hello Again!' character(len=*), public, parameter :: in = ' Hello! Hello Again! ' Source Code subroutine test_attr_mode () character ( len =* ), parameter :: in = '<B><bo>Hello!</bo></B> <G><y>Hello Again!</y></G>' character ( len =* ), parameter :: expected_color = & & char ( 27 ) // '[44m' // char ( 27 ) // '[1mHello!' // & & char ( 27 ) // '[22m' // char ( 27 ) // '[49m ' // char ( 27 ) // '[42m' // char ( 27 ) // '[33mHello Again!' // & & char ( 27 ) // '[39m' // char ( 27 ) // '[49m' // char ( 27 ) // '[0m' character ( len =* ), parameter :: expected_plain = 'Hello! Hello Again!' call unit_check_start ( 'attr_mode' , ' ' // OPTIONS ) call attr_mode ( manner = 'color' ) call unit_check ( 'attr_mode' , attr ( in ). eq . expected_color , 'color' ) call attr_mode ( manner = 'plain' ) call unit_check ( 'attr_mode' , attr ( in ). eq . expected_plain , 'plain' ) call attr_mode ( manner = 'raw' ) call unit_check ( 'attr_mode' , attr ( in ). eq . in , 'raw' ) call unit_check_done ( 'attr_mode' ) end subroutine test_attr_mode","tags":"","loc":"proc/test_attr_mode.html"},{"title":"test_attr_update – M_attr","text":"public subroutine test_attr_update() Arguments None Contents Variables targetline Source Code test_attr_update Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: targetline Source Code subroutine test_attr_update () character ( len = :), allocatable :: targetline call unit_check_start ( 'attr_update' , ' ' // OPTIONS ) !call unit_check('attr_update',targetline.eq.'a b ab baaa aaCCCC CCCC CCCC a a a aa aaaaaa','example of using RANGE',targetline) if ( unit_check_level . gt . 0 ) then endif call unit_check_done ( 'attr_update' ) end subroutine test_attr_update","tags":"","loc":"proc/test_attr_update.html"},{"title":"test_suite_m_attr – M_attr","text":"public subroutine test_suite_m_attr() Arguments None Contents Source Code test_suite_m_attr Source Code subroutine test_suite_m_attr () call test_attr () call test_attr_mode () call test_attr_update () call test_advice () end subroutine test_suite_m_attr","tags":"","loc":"proc/test_suite_m_attr.html"},{"title":"M_attr – M_attr","text":"NAME M_attr ( 3 f ) - [ M_attr ] control text attributes on terminals ( LICENSE : MIT ) SYNOPSIS core functions ! Add text attributes like color with an HTML-like syntax\n  use M_attr, only : attr\n  ! suppress the escape sequence output\n  use M_attr, only : attr_mode\n  ! customize what output strings are produced\n  use M_attr, only : attr_update for generating standard messages use M_attr, only : advice DESCRIPTION M_attr ( 3 f ) is a Fortran module that writes common ANSI escape sequences which control terminal text attributes . It is designed to allow the sequences to be suppressed when desired and for the user program to completely customize the keywords -- the user can add , delete and replace the sequences associated with a keyword without changing the code . Attributes are specified by writing lines with HTML - like structure . The advantage of the approach of replacing in - band escape sequences with formatting directives contained on each line is that it is easy to turn off when running batch , but more importantly your program can be run in \"raw\" mode and write a clean text file with the directives in it that can then be read back in by a simple filter program that strips it back to plain text ( see app / plain . f90 ), or displays it to a screen in color ( see app / light . f90 ) or perhaps converts it to another format . By making each line self - contained ( by default ) this can still be done with any arbitrarily selected group of lines from the file . So this module makes it trivial to read specially - formatted data from a file like a message catalog ( perhaps with various versions in different languages ) and colorize it or display it as plain text using the attr ( 3 f ) procedure . LIMITATIONS o colors are not nestable.\n   o keywords are case-sensitive,\n   o ANSI escape sequences are not universally supported by\n     all terminal emulators; and normally should be suppressed\n     when not going to a tty device. Therefore, you should use\n     M_system::system_istty(3f) or the common Fortran extension\n     ISATTY() to set the default to “plain” instead of “color”\n     when the output file is not a conforming terminal. On basic\n     MSWindows console windows, it is best to use Windows 10+ and/or\n     the Linux mode; you may have to enable ANSI escape sequence\n     mode on MSWindows. It does work as-is with CygWin and MinGW and\n     Putty windows and mintty(1) as tested. EXAMPLE Sample program\n\n program demo_M_attr\n use M_attr, only : attr, attr_mode, attr_update\n implicit none\n character(len=256) :: line\n character(len=*),parameter :: f='( & & \" <bo><w><G> GREAT: </G></w> & & The new value <Y><b> \",f8.4,1x,\" </b></Y> is in range\" & & )'\n real :: value\n\n    write(*,'(a)') & & attr(' <r><W><bo> ERROR: </W> red text on a white background </y> ')\n\n    value=3.4567\n    write(line,fmt=f) value\n    write(*,'(a)')attr(trim(line))\n\n    ! write same string as plain text\n    write(*,*)\n    call attr_mode(manner='plain')\n    write(*,'(a)')attr(trim(line))\n\n    call attr_mode(manner='color')\n    ! use pre-defined or user defined strings\n    write(*,*)\n    write(*,'(a)')attr(' <ERROR> Woe is nigh.')\n    write(*,'(a)')attr(' <WARNING> The night is young.')\n    write(*,'(a)')attr(' <INFO> It is Monday')\n\n    ! create a custom mneumonic\n    call attr_update('MYERROR',attr( & ' <R><e> E <w> - <e> R <w> - <e> R <w> - <e> O <w> - <e> R: </e></R></bo> ' & ))\n    write(*,*)\n    write(*,'(a)')attr(' <MYERROR> my custom message style')\n\n end program demo_M_attr AUTHOR John S. Urban, 2021 LICENSE MIT SEE ALSO attr(3f), attr_mode(3f), attr_update(3f)\n\nRelated information:\n\n terminfo(3c), termlib(3c), tput(1), reset(1), clear(1),\n console_codes(4), ECMA-48,\n https://en.wikipedia.org/wiki/ANSI_escape_code Uses iso_fortran_env iso_c_binding Contents Variables bg_black bg_blue bg_cyan bg_default bg_ebony bg_green bg_magenta bg_red bg_white bg_yellow bold clear fg_black fg_blue fg_cyan fg_default fg_ebony fg_green fg_magenta fg_red fg_white fg_yellow inverse italic reset unbold underline uninverse unitalic ununderline Interfaces attr Subroutines advice attr_mode attr_update Variables Type Visibility Attributes Name Initial character(len=*), public, parameter :: bg_black = CODE_START//BG//BLACK//CODE_END character(len=*), public, parameter :: bg_blue = CODE_START//BG//BLUE//CODE_END character(len=*), public, parameter :: bg_cyan = CODE_START//BG//CYAN//CODE_END character(len=*), public, parameter :: bg_default = CODE_START//BG//DEFAULT//CODE_END character(len=*), public, parameter :: bg_ebony = CODE_START//BG//BLACK//CODE_END character(len=*), public, parameter :: bg_green = CODE_START//BG//GREEN//CODE_END character(len=*), public, parameter :: bg_magenta = CODE_START//BG//MAGENTA//CODE_END character(len=*), public, parameter :: bg_red = CODE_START//BG//RED//CODE_END character(len=*), public, parameter :: bg_white = CODE_START//BG//WHITE//CODE_END character(len=*), public, parameter :: bg_yellow = CODE_START//BG//YELLOW//CODE_END character(len=*), public, parameter :: bold = CODE_START//ON//AT_BOLD//CODE_END character(len=*), public, parameter :: clear = HOME_DISPLAY//CLEAR_DISPLAY character(len=*), public, parameter :: fg_black = CODE_START//FG//BLACK//CODE_END character(len=*), public, parameter :: fg_blue = CODE_START//FG//BLUE//CODE_END character(len=*), public, parameter :: fg_cyan = CODE_START//FG//CYAN//CODE_END character(len=*), public, parameter :: fg_default = CODE_START//FG//DEFAULT//CODE_END character(len=*), public, parameter :: fg_ebony = CODE_START//FG//BLACK//CODE_END character(len=*), public, parameter :: fg_green = CODE_START//FG//GREEN//CODE_END character(len=*), public, parameter :: fg_magenta = CODE_START//FG//MAGENTA//CODE_END character(len=*), public, parameter :: fg_red = CODE_START//FG//RED//CODE_END character(len=*), public, parameter :: fg_white = CODE_START//FG//WHITE//CODE_END character(len=*), public, parameter :: fg_yellow = CODE_START//FG//YELLOW//CODE_END character(len=*), public, parameter :: inverse = CODE_START//ON//AT_INVERSE//CODE_END character(len=*), public, parameter :: italic = CODE_START//ON//AT_ITALIC//CODE_END character(len=*), public, parameter :: reset = CODE_RESET character(len=*), public, parameter :: unbold = CODE_START//'22'//CODE_END character(len=*), public, parameter :: underline = CODE_START//ON//AT_UNDERLINE//CODE_END character(len=*), public, parameter :: uninverse = CODE_START//OFF//AT_INVERSE//CODE_END character(len=*), public, parameter :: unitalic = CODE_START//OFF//AT_ITALIC//CODE_END character(len=*), public, parameter :: ununderline = CODE_START//OFF//AT_UNDERLINE//CODE_END Interfaces public interface attr private function attr_scalar(string, reset) result(expanded) Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string logical, intent(in), optional :: reset Return Value character(len=:),\n  allocatable private function attr_matrix(string, reset, chars) result(expanded) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string (:) logical, intent(in), optional :: reset integer, intent(in), optional :: chars Return Value character(len=:),\n  allocatable, (:) private function attr_scalar_width(string, reset, chars) result(expanded) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string logical, intent(in), optional :: reset integer, intent(in) :: chars Return Value character(len=:),\n  allocatable Subroutines public subroutine advice (type, message) !> Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: type character(len=*), intent(in), optional :: message public subroutine attr_mode (manner) !> Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: manner public subroutine attr_update (key, valin, mono_valin) !> Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: key character(len=*), intent(in), optional :: valin character(len=*), intent(in), optional :: mono_valin","tags":"","loc":"module/m_attr.html"},{"title":"M_testsuite_M_attr – M_attr","text":"Uses iso_fortran_env M_verify M_attr Contents Variables options Subroutines test_advice test_attr test_attr_mode test_attr_update test_suite_m_attr Variables Type Visibility Attributes Name Initial character(len=*), public, parameter :: options = ' -section 3 -library libGPF -filename `pwd`/m_attr.FF  -documentation y -ufpp   y -ccall  n -archive  GPF.a ' Subroutines public subroutine test_advice () Arguments None public subroutine test_attr () Arguments None public subroutine test_attr_mode () Arguments None public subroutine test_attr_update () Arguments None public subroutine test_suite_m_attr () Arguments None","tags":"","loc":"module/m_testsuite_m_attr.html"},{"title":"roots – M_attr","text":"Uses iso_fortran_env M_attr Contents Variables TERM a b buffer c discriminant dp ios message numbers paws x x1 x2 x_complex x_real Functions system_getenv system_isatty Subroutines text Source Code roots Variables Type Attributes Name Initial character(len=:), allocatable :: TERM real(kind=dp) :: a real(kind=dp) :: b character(len=1024) :: buffer real(kind=dp) :: c real(kind=dp) :: discriminant integer, parameter :: dp = kind(0.0d0) integer :: ios character(len=256) :: message character(len=*), parameter :: numbers = '(\" \",*(\"(\",g0.8,\",\",g0.8,\")\":,1x))' character(len=1) :: paws real(kind=dp) :: x real(kind=dp) :: x1 real(kind=dp) :: x2 real(kind=dp) :: x_complex real(kind=dp) :: x_real Functions function system_getenv (name, default) result(value) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name character(len=*), intent(in), optional :: default Return Value character(len=:),\n  allocatable function system_isatty (lun) call compiler-specific ISATTY() function or return .FALSE. Arguments Type Intent Optional Attributes Name integer, intent(in) :: lun Return Value logical Subroutines subroutine text (string) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: string Source Code program roots use , intrinsic :: iso_fortran_env , only : stdin => input_unit , stdout => output_unit , stderr => error_unit use M_attr , only : attr , attr_mode , attr_update ! Calculate and print the roots of a quadratic formula even if they are complex implicit none integer , parameter :: dp = kind ( 0.0d0 ) real ( kind = dp ) :: a , b , c , discriminant real ( kind = dp ) :: x1 , x2 , x ! Real roots of the equation real ( kind = dp ) :: x_real ! Real part of complex root of the equation REAL ( kind = dp ) :: x_complex ! Imaginary part of complex root of the equation character ( len = 256 ) :: message integer :: ios character ( len = 1 ) :: paws character ( len = 1024 ) :: buffer character ( len =* ), parameter :: numbers = '(\"<B><w><bo>   \",*(\"(\",g0.8,\",\",g0.8,\")\":,1x))' character ( len = :), allocatable :: TERM if ( system_isatty ( stdout )) then ! ISATTY() is an extension, but found in Intel, GNU, PGI, ... compiler call attr_mode ( 'color' ) else call attr_mode ( 'plain' ) endif TERM = system_getenv ( 'TERM' , 'vt102' ) ! perhaps change or add strings based on terminal type select case ( TERM ) case ( 'xterm' ) call attr_update ( 'mono' , attr ( '<esc>]11;black<bel><esc>]10;white<bel>' )) ! change default bg and fg case ( 'screen' ) end select INFINITE : do ! clear screen, set attributes and print messages call text ( \"<reset><clear>\" ) call text ( \"For the quadratic equation <m>A</m><g>*x**2 +<m>B</m><g>*x + <m>C</m> \" ) write ( stdout , '(*(a))' , advance = 'no' ) & & attr ( '<B><w><bo>' // repeat ( '_' , 78 ) // '  ' ), & & char ( 13 ),& & attr ( '<B><g><bo>enter coefficients <m>A,B,C</m><g>:<y><gt><ul>' ,& & reset = . false .) read ( stdin , * , iostat = ios , iomsg = message ) a , b , c write ( stdout , '(a)' , advance = 'no' ) attr ( '<reset>' ) if ( ios . ne . 0 ) then write ( stdout , * ) write ( stdout , '(*(g0))' ) ios , ' ' , trim ( message ) rewind ( unit = stdin , iostat = ios ) backspace ( unit = stdin , iostat = ios ) else ! Given the equation \"A*X**2 + B*X + C = 0\" ! Use the quadratic formula to determine the root values of the equation. ! prompt for new value call text () call text ( 'Given the equation' ) call text () write ( buffer , '(*(g0.8))' ) '<B><w><bo>   ' , a , '<m>*X**2</m><w> + ' , b , '<m>*X</m><w> + ' , c , ' = 0' call text ( buffer ) call text () discriminant = b ** 2 - 4 * a * c if ( a . eq . 0 ) then call text ( '<ERROR> <m>If <m>a</m><g> is zero this is a linear, not quadratic equation' ) elseif ( discriminant > 0 ) then call text ( 'the <m>roots</m><g> (ie. \"x intercepts\") are <m>real<m><g> so the parabola ' ) call text ( 'crosses the x-axis at <m>two points</m><g>:' ) call text () x1 = ( - b + sqrt ( discriminant )) / ( 2 * a ) x2 = ( - b - sqrt ( discriminant )) / ( 2 * a ) write ( buffer , numbers ) x1 , 0.0d0 call text ( buffer ) write ( buffer , numbers ) x2 , 0.0d0 call text ( buffer ) call text () elseif ( discriminant == 0 ) then call text ( 'the <m>roots</m><g> (ie. \"x intercepts\") are repeated <m>(real and equal)</m><g>' ) call text ( 'so the parabola just touches the x-axis at:' ) call text () if ( b . ne . 0 ) then x = ( - b ) / ( 2 * a ) else x = 0.0d0 endif write ( buffer , numbers ) x , 0.0d0 call text ( buffer ) call text () else call text ( 'the <m>roots</m><g>(ie. \"x intercepts\")  are <m>complex</m><g>:' ) x_real = ( - b ) / ( 2 * a ) x_complex = sqrt ( abs ( discriminant )) / ( 2 * a ) call text () WRITE ( buffer , '(a,*(\"(\",g0.8,\", +i\",g0.8,\")\",:,1x))' ) '<B><w><bo>   ' , x_real , x_complex call text ( buffer ) WRITE ( buffer , '(a,*(\"(\",g0.8,\", -i\",g0.8,\")\",:,1x))' ) '<B><w><bo>   ' , x_real , x_complex call text ( buffer ) call text () endif call text ( 'with' ) call text () write ( buffer , '(g0,*(g0.8,1x))' ) \"<B><w><bo>   <m>discriminate</m><w> = \" , discriminant call text ( buffer ) call text () endif write ( stdout , '(*(g0))' , advance = 'no' ) attr ( '<B><e>press <g>return</g><e> to continue, \"<g>q</g><e>\" to quit:' , chars = 79 ) read ( stdin , advance = 'yes' , iostat = ios , fmt = '(a)' , iomsg = message ) paws if ( paws . ne . '' ) exit INFINITE enddo INFINITE contains subroutine text ( string ) character ( len =* ), intent ( in ), optional :: string if ( present ( string )) then write ( stdout , '(*(g0))' ) attr ( '<B><g><bo>' // string , chars = 80 ) else write ( stdout , '(*(g0))' ) attr ( '<B><g><bo>' , chars = 80 ) endif end subroutine text !>  call compiler-specific ISATTY() function or return .FALSE. #undef ISATTY #ifdef __INTEL_COMPILER function system_isatty ( lun ) use IFPORT integer , intent ( in ) :: lun logical :: system_isatty system_isatty = isatty ( lun ) end function system_isatty #define ISATTY #endif #ifdef __NVCOMPILER_MAJOR__X ! __NVCOMPILER_MAJOR__ __NVCOMPILER_MINOR__ __NVCOMPILER_PATCHLEVEL__ function system_isatty ( lun ) use DFPORT integer , intent ( in ) :: lun logical :: system_isatty system_isatty = isatty ( lun ) end function system_isatty #define ISATTY #endif #ifdef __GFORTRAN__ function system_isatty ( lun ) integer , intent ( in ) :: lun logical :: system_isatty system_isatty = isatty ( lun ) end function system_isatty #define ISATTY #endif #ifndef ISATTY function system_isatty ( lun ) integer , intent ( in ) :: lun logical :: system_isatty system_isatty = . false . end function system_isatty #define ISATTY #endif function system_getenv ( name , default ) result ( value ) !$@(#) M_system::system_getenv(3f): call get_environment_variable as a function with a default value(3f) character ( len =* ), intent ( in ) :: name character ( len =* ), intent ( in ), optional :: default integer :: howbig integer :: stat character ( len = :), allocatable :: value if ( NAME . ne . '' ) then call get_environment_variable ( name , length = howbig , status = stat , trim_name = . true .) ! get length required to hold value if ( howbig . ne . 0 ) then select case ( stat ) case ( 1 ) ! print *, NAME, \" is not defined in the environment. Strange...\" value = '' case ( 2 ) ! print *, \"This processor doesn't support environment variables. Boooh!\" value = '' case default ! make string to hold value of sufficient size and get value if ( allocated ( value )) deallocate ( value ) allocate ( character ( len = max ( howbig , 1 )) :: VALUE ) call get_environment_variable ( name , value , status = stat , trim_name = . true .) if ( stat . ne . 0 ) VALUE = '' end select else value = '' endif else value = '' endif if ( value . eq . '' . and . present ( default )) value = default end function system_getenv END PROGRAM roots","tags":"","loc":"program/roots.html"},{"title":"demo_attr – M_attr","text":"Uses M_attr Contents Variables expanded icount ios line Subroutines args Source Code demo_attr Variables Type Attributes Name Initial character(len=:), allocatable :: expanded integer :: icount integer :: ios character(len=1024) :: line Subroutines subroutine args () Arguments None Source Code program demo_attr ! read stdin and run it through M_attr::attr to display color use M_attr , only : attr , attr_update implicit none character ( len = 1024 ) :: line character ( len = :), allocatable :: expanded integer :: icount integer :: ios line = '' call attr_update ( 'Z' , char ( 27 ) // '[1m' ) icount = command_argument_count () ! get number of arguments ! if command arguments use those instead of reading stdin ! example: light '<clear><B><w><bo><CSI>12;36f Good Morning! ' if ( icount . gt . 0 ) then call args () else do read ( * , '(a)' , iostat = ios ) line if ( ios . ne . 0 ) exit expanded = attr ( trim ( line )) write ( * , '(a)' ) expanded enddo write ( * , '(a)' , advance = 'no' ) attr ( '<reset>' ) endif contains subroutine args () implicit none integer :: i integer :: istat integer :: argument_length character ( len = :), allocatable :: argument do i = 1 , icount call get_command_argument ( number = i , length = argument_length ) ! allocate string array big enough to hold command line argument if ( allocated ( argument )) deallocate ( argument ) allocate ( character ( len = argument_length ) :: argument ) ! read the argument call get_command_argument ( i , argument , status = istat ) expanded = attr ( trim ( argument )) write ( * , '(a)' ) expanded enddo end subroutine args end program demo_attr","tags":"","loc":"program/demo_attr.html"},{"title":"demo_attr – M_attr","text":"Uses M_attr Contents Variables ios line Source Code demo_attr Variables Type Attributes Name Initial integer :: ios character(len=1024) :: line Source Code program demo_attr ! read stdin and run it through M_attr::attr to display without color use M_attr , only : attr , attr_mode implicit none character ( len = 1024 ) :: line integer :: ios line = '' call attr_mode ( manner = 'plain' ) do read ( * , '(a)' , iostat = ios ) line if ( ios . ne . 0 ) exit write ( * , '(a)' ) attr ( trim ( line )) enddo write ( * , '(a)' , advance = 'no' ) attr ( '<reset>' ) end program demo_attr","tags":"","loc":"program/demo_attr~2.html"},{"title":"demo_M_attr – M_attr","text":"Uses M_attr Contents Source Code demo_M_attr Source Code program demo_M_attr use M_attr , only : attr , attr_update write ( * , '(a)' ) attr ( '<clear>TEST CUSTOMIZED:' ) ! add custom keywords call attr_update ( 'blink' , char ( 27 ) // '[5m' ) call attr_update ( '/blink' , char ( 27 ) // '[25m' ) write ( * , '(a)' ) attr ( '<blink>Items for Friday</blink> not before' ) write ( * , '(a)' , advance = 'no' ) attr ( '<r>RED</r>,' ) write ( * , '(a)' , advance = 'no' ) attr ( '<b>BLUE</b>,' ) write ( * , '(a)' , advance = 'yes' ) attr ( '<g>GREEN</g>' ) ! delete call attr_update ( 'r' ) call attr_update ( '/r' ) ! replace call attr_update ( 'b' , '<<<<' ) call attr_update ( '/b' , '>>>>' ) write ( * , '(a)' , advance = 'no' ) attr ( '<r>RED</r>,' ) write ( * , '(a)' , advance = 'no' ) attr ( '<b>BLUE</b>,' ) write ( * , '(a)' , advance = 'yes' ) attr ( '<g>GREEN</g>' ) end program demo_M_attr","tags":"","loc":"program/demo_m_attr.html"},{"title":"dots – M_attr","text":"Uses M_attr Contents Variables bg c colors fg icount p r x y z Functions ranf Subroutines init_random_seed_by_clock Source Code dots Variables Type Attributes Name Initial integer :: bg real :: c character(len=10), parameter :: colors (8) = [character(len=10)::'RED', 'GREEN', 'BLUE', 'CYAN', 'MAGENTA', 'YELLOW', 'BLACK', 'WHITE'] integer :: fg integer :: icount character(len=1) :: p real :: r integer :: x integer :: y integer :: z Functions function ranf () result(r) Arguments None Return Value real Subroutines subroutine init_random_seed_by_clock () Arguments None Source Code program dots ! @(#) random dots on screen till ctrl-C use M_attr , only : attr implicit none integer :: x , y integer :: z character ( len = 1 ) :: p integer :: fg , bg real :: r real :: c integer :: icount character ( len = 10 ), parameter :: colors ( 8 ) = [ character ( len = 10 ) :: 'RED' , 'GREEN' , 'BLUE' , 'CYAN' , 'MAGENTA' , 'YELLOW' , 'BLACK' , 'WHITE' ] fg = 8 bg = 7 r = 80 c = 24 icount = 0 INFINITE : do x = int (( c * ranf ()) + 1 ) y = int (( r * ranf ()) + 1 ) if ( ranf () > 0.9 ) then p = \"*\" else p = \" \" endif write ( * , '(*(g0))' , advance = 'no' ) attr ( '<CSI>' , reset = . false .), x , ';' , y , 'f' , p z = min ( 8 , int ( ranf () * 8 + 1 )) write ( * , '(a)' , advance = 'no' ) attr ( '<' // trim ( colors ( z )) // '>' , reset = . false .) icount = icount + 1 write ( * , '(*(g0))' , advance = 'no' ) attr ( '<CSI>1;1f' , reset = . false .), icount if ( icount . gt . 24 * 80 * 250 ) exit enddo INFINITE write ( * , * ) attr ( \"<reset>That was two hundred and fifty pages worth of dots\" ) CONTAINS !---------------------------------------------------------------------------------------- FUNCTION ranf () result ( r ) IMPLICIT NONE REAL :: r LOGICAL , SAVE :: already_run = . TRUE . IF (. NOT . already_run ) THEN CALL init_random_seed_by_clock () already_run = . TRUE . ENDIF CALL random_number ( r ) END FUNCTION ranf !---------------------------------------------------------------------------------------- SUBROUTINE init_random_seed_by_clock () implicit none INTEGER :: i , n , clock INTEGER , DIMENSION (:), ALLOCATABLE :: seed CALL RANDOM_SEED ( size = n ) ALLOCATE ( seed ( n )) CALL SYSTEM_CLOCK ( COUNT = clock ) seed = clock + 37 * ( / ( i - 1 , i = 1 , n ) / ) CALL RANDOM_SEED ( PUT = seed ) DEALLOCATE ( seed ) END SUBROUTINE init_random_seed_by_clock !---------------------------------------------------------------------------------------- END PROGRAM dots","tags":"","loc":"program/dots.html"},{"title":"mode – M_attr","text":"Uses M_attr Contents Subroutines printme Source Code mode Subroutines subroutine printme (mymode) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: mymode Source Code program mode use M_attr , only : attr , attr_mode implicit none call printme ( 'color' ) call printme ( 'plain' ) call printme ( 'raw' ) contains subroutine printme ( mymode ) character ( len =* ), intent ( in ) :: mymode call attr_mode ( mymode ) write ( * , '(a)' ) mymode write ( * , '(a)' ) attr ( '<ERROR>Woe is nigh.' ) write ( * , '(a)' ) attr ( '<WARNING>The night is young.' ) write ( * , '(a)' ) attr ( '<INFO>It is Monday' ) end subroutine printme end program mode","tags":"","loc":"program/mode.html"},{"title":"version – M_attr","text":"Uses M_attr Contents Variables i text Source Code version Variables Type Attributes Name Initial integer :: i character(len=*), parameter :: text (23) = [character(len=132)::' ', ' ', ' LLL F ortran ', ' LL LL P ackage ', ' LL M anager ', ' LLLLLL ', ' LL ', ' LL               LLLLL LLL ', ' LL     LLLLLL     LL  L  LL ', ' LL    LL     L    LL  L  LL ', ' LL    LL     L    LL  L  LL ', ' LL    LLLLLLL     LL  L  LL ', ' LL ', ' LL ', ' LL ', ' ', ' ', ' Program: fpm(1)                                     ', ' Description: A Fortran package manager and build system ', ' Version: 0.3.0, alpha                               ', ' License: MIT                                        ', ' Home Page: https://github.com/fortran-lang/fpm        ', ' '] Source Code program version use M_attr , only : attr , attr_update , attr_mode ! shows a limitation if periods are replaced with spaces the CHAR= option does not ! count the colored blanks so if no text after the blanks too much padding is appended to the line ! need to count last character with a background attribute or something different implicit none integer :: i !nvfortran bug!character(len=*),parameter :: text(*)= [character(len=132) :: & character ( len =* ), parameter :: text ( 23 ) = [ character ( len = 132 ) :: & '<E><e>                                                     ' ,& '<E><e>        <C>                                   </W><E><end>' ,& '<E><e>        <C>      LLL        </C><E> <bo><w>F</bo>ortran   </w></E><C>       <E><e></bo><end>' ,& '<E><e>        <C>     LL LL       </C><E>  <bo><w>P</bo>ackage  </w></E><C>       <E><e></bo><end>' ,& '<E><e>        <C>     LL          </C><E>   <bo><w>M</bo>anager </w></E><C>       <E><e></bo><end>' ,& '<E><e>        <C>   LLLLLL                          <E><end>' ,& '<E><e>        <C>     LL                            <E><end>' ,& '<E><e>        <C>     LL               LLLLL LLL    <E><end>' ,& '<E><e>        <C>     LL     LLLLLL     LL  L  LL   <E><end>' ,& '<E><e>        <C>     LL    LL     L    LL  L  LL   <E><end>' ,& '<E><e>        <C>     LL    LL     L    LL  L  LL   <E><end>' ,& '<E><e>        <C>     LL    LLLLLLL     LL  L  LL   <E><end>' ,& '<E><e>        <C>           LL                      <E><end>' ,& '<E><e>        <C>           LL                      <E><end>' ,& '<E><e>        <C>           LL                      <E><end>' ,& '<E><e>        <C>                                   <E><end>' ,& '<E><e>                                                     ' ,& '<E><bo><b>Program:</b><w>     fpm(1)                                     ' ,& '<E><bo><b>Description:</b><w> A Fortran package manager and build system ' ,& '<E><bo><b>Version:</b><w>     0.3.0, alpha                               ' ,& '<E><bo><b>License:</b><w>     MIT                                        ' ,& '<E><bo><b>Home Page:</b><w>   https://github.com/fortran-lang/fpm        ' ,& '<E><bo>' ] ! add custom keywords call attr_update ( 'end' , '.' , ' ' ) call attr_mode ( manner = 'plain' ) write ( * , '(a)' )( attr ( trim ( text ( i )), chars = 80 ), i = 1 , size ( text )) call attr_update ( 'end' , '.' , char ( 0 )) call attr_mode ( manner = 'color' ) write ( * , '(a)' )( attr ( trim ( text ( i )), chars = 80 ), i = 1 , size ( text )) end program version","tags":"","loc":"program/version.html"},{"title":"fancy – M_attr","text":"Uses iso_fortran_env M_attr Contents Variables help_list_dash help_list_nodash i text Subroutines paws Source Code fancy Variables Type Attributes Name Initial character(len=256), parameter :: help_list_dash (*) = [character(len=256)::' F ortran Package M anager: ', ' ', ' build [ --compiler COMPILER_NAME ] [ --profile PROF ] [ --flag FFLAGS ] [ --list ]', ' ', ' help [ NAME(s) ]                       ', ' ', ' new NAME [[ --lib | --src ] [ --app ] [ --test ] [ --example ]]|', ' [ --full | --bare ][ --backfill ]', ' ', ' update [ NAME(s) ] [ --fetch-only ] [ --clean ] [ --verbose ]', ' ', ' list [ --list ]', ' ', ' run [[ --target ] NAME(s) [ --example ][ --profile PROF ] [ --flag FFLAGS ] [ --all ]', ' [ --runner \"CMD\" ] [ --compiler COMPILER_NAME ] [ --list ] [-- ARGS ]', ' ', ' test [[ --target ] NAME(s) ] [ --profile PROF ] [ --flag FFLAGS ] [ --runner \"CMD\" ]', ' [ --list ] [ --compiler COMPILER_NAME ] [-- ARGS ]', ' ', ' install [ --profile PROF ] [ --flag FFLAGS ] [ --no-rebuild ] [ --prefix PATH ] ', ' [ OPTIONS ]', ' '] character(len=256), parameter :: help_list_nodash (*) = [character(len=256)::' F ortran P ackage M anager: ', ' ', ' USAGE: fpm [ SUBCOMMAND [ SUBCOMMAND_OPTIONS ] ]| [ --list | --help | --version ]', ' ', ' where SUBCOMMAND is commonly one of new | build | run | test but may be any of', ' ', ' build Compile the package placing results in the \"build\" directory', ' help Display help                                                ', ' list Display this list of subcommand descriptions                ', ' new Create a new Fortran package directory with sample files    ', ' run Run the local package application programs                  ', ' test Run the test programs                                       ', ' update Update and manage project dependencies                      ', ' install Install project                                             ', ' ', ' Enter \" fpm --list \" for a brief list of subcommand options. Enter', ' \" fpm --help \" or \" fpm SUBCOMMAND --help \" for detailed descriptions.', ' ', ' Note: color mode is controlled by the environment variable FPM_COLOR. The', ' set of allowable values is { always,never,auto }. The default is \" auto \". ', ' '] integer :: i character(len=*), parameter :: text (22) = [character(len=132)::' ', ' ', ' LLL F ortran ', ' LL LL P ackage ', ' LL M anager ', ' LLLLLL ', ' LL ', ' LL               LLLLL LLL ', ' LL     LLLLLL     LL  L  LL ', ' LL    LL     L    LL  L  LL ', ' LL    LL     L    LL  L  LL ', ' LL    LLLLLLL     LL  L  LL ', ' LL ', ' LL ', ' LL ', ' ', ' ', ' Program: fpm(1)                                     ', ' Description: package manager and build system for Fortran', ' Version: 0.3.0, alpha                               ', ' License: MIT                                        ', ' Home Page: https://github.com/fortran-lang/fpm        '] Subroutines subroutine paws () Arguments None Source Code program fancy use , intrinsic :: iso_fortran_env , only : stderr => ERROR_UNIT , stdin => INPUT_UNIT , stdout => OUTPUT_UNIT use M_attr , only : attr , attr_update , attr_mode implicit none integer :: i character ( len = 256 ), parameter :: help_list_nodash ( * ) = [ character ( len = 256 ) :: & !'<clear>', & '<E><w><b><bo>F</bo>ortran <bo>P</bo>ackage <bo>M</bo>anager:</b>' , & '<E><w>                                                                        ' , & '<E><w><bo>USAGE: <r><un>fpm</un></r><w> [ <r><un>SUBCOMMAND</un></r> <w>[<m>SUBCOMMAND_OPTIONS</m><w>] ]|& &<bo>[<g>--list</g><w>|<g>--help</g><w>|<g>--version</g><w>]' , & '<E><w>                                                                        ' , & '<E><w> where <r><un><bo>SUBCOMMAND</bo></un></r> <w>is commonly one of & &<bo><g>new</g><w>|<g>build</g><w>|<g>run</g><w>|<g>test</g></bo> <w>but may be any of' , & '<E><w>                                                                        ' , & '<E><w>  <bo><g>build</g></bo>     <w>Compile the package placing results in the \"build\" directory' , & '<E><w>  <bo><g>help</g></bo>      <w>Display help                                                ' , & '<E><w>  <bo><g>list</g></bo>      <w>Display this list of subcommand descriptions                ' , & '<E><w>  <bo><g>new</g></bo>       <w>Create a new Fortran package directory with sample files    ' , & '<E><w>  <bo><g>run</g></bo>       <w>Run the local package application programs                  ' , & '<E><w>  <bo><g>test</g></bo>      <w>Run the test programs                                       ' , & '<E><w>  <bo><g>update</g></bo>    <w>Update and manage project dependencies                      ' , & '<E><w>  <bo><g>install</g></bo>   <w>Install project                                             ' , & '<E><w>                                                                        ' , & '<E><w> <bo>Enter \"<r><un>fpm</un></r> <g>--list</g><w></bo>\" for a brief list of subcommand options. Enter' , & '<E><w> \"<bo><r><un>fpm</un></r> <g>--help</g></bo><w>\" or & &\"<bo><r><un>fpm</un> <un>SUBCOMMAND</un></r> <g>--help</g><w></bo>\" for detailed descriptions.' , & '<E><w>                                                                        ' , & '<E><w> <bo>Note:</bo> color mode is controlled by the environment variable FPM_COLOR. The' , & '<E><w>       set of allowable values is {<g><bo>always,never,auto</bo></g><w>}. The default is \"<g><bo>auto</bo></g><w>\". ' , & '<E><w> ' ] character ( len = 256 ), parameter :: help_list_dash ( * ) = [ character ( len = 256 ) :: & !'<clear>', & '<E><w><b><bo>F</bo>ortran </bo>P</bo>ackage <bo>M</bo>anager:</b>' , & '<E><w>                                                           ' , & '<E><w> <bo><g>build</g><w> [<g>--compiler</g> <m>COMPILER_NAME</m><w>] & &[<g>--profile</g> <m>PROF</m><w>] [<g>--flag</g> <m>FFLAGS</m><w>] [<g>--list</g><w>]' , & '<E><w>                                                           ' , & '<E><w> <bo><g>help</g><w> [<r><un>NAME(s)</un></r><w>]                       ' , & '<E><w>                                                           ' , & '<E><w> <bo><g>new</g><w> <r><un>NAME</un></r><w> [[<g>--lib</g><w>|<g>--src</g><w>] [<g>--app</g><w>] & &[<g>--test</g><w>] [<g>--example</g><w>]]|' , & '<E><w> <bo>         [<g>--full</g><w>|<g>--bare</g><w>][<g>--backfill</g><w>]' , & '<E><w>                                                           ' , & '<E><w> <bo><g>update</g><w> <w>[<r><un>NAME(s)</un></r><w>] [<g>--fetch-only</g><w>] [<g>--clean</g><w>] [<g>--verbose</g><w>]' , & '<E><w>                                                           ' , & '<E><w> <bo><g>list</g><w> [<g>--list</g><w>]' , & '<E><w>                                                           ' , & '<E><w> <bo><g>run</g><w>  [[<g>--target</g><w>] <r><un>NAME(s)</un></r> <w>[<g>--example</g><w>]& &[<g>--profile</g><w> <m>PROF</m><w>] [<g>--flag</g><w> <m>FFLAGS</m><w>] [<g>--all</g><w>]' , & '<E><w> <bo>     [<g>--runner</g><w> <m>\"CMD\"</m><w>] [<g>--compiler</g><w> <m>COMPILER_NAME</m><w>] & &[<g>--list</g><w>] [-- <m>ARGS</m><w>]' , & '<E><w>                                                           ' , & '<E><w> <bo><g>test</g><w> [[<g>--target</g><w>] <r><un>NAME(s)</un></r><w>] [<g>--profile</g><w> <m>PROF</m><w>] & &[<g>--flag</g><w> <m>FFLAGS</m><w>] [<g>--runner</g><w> <m>\"CMD\"</m><w>]' , & '<E><w> <bo>     [<g>--list</g><w>] [<g>--compiler</g><w> <m>COMPILER_NAME</m><w>] [-- <m>ARGS</m><w>]' , & '<E><w>                                                           ' , & '<E><w> <bo><g>install</g><w> [<g>--profile</g><w> <m>PROF</m>] [<g>--flag</g><w> <m>FFLAGS</m>] & &[<g>--no-rebuild</g><w>] [<g>--prefix</g><w> <m>PATH</m><w>] ' , & '<E><w> <bo>        <w>[<m>OPTIONS</m><w>]' , & '<E><w> ' ] ! shows a limitation if periods are replaced with spaces the CHAR= option does not ! count the colored blanks so if no text after the blanks too much padding is appended to the line ! need to count last character with a background attribute or something different !nvfortran bug!character(len=*),parameter :: text(*)= [character(len=132) :: & character ( len =* ), parameter :: text ( 22 ) = [ character ( len = 132 ) :: & '<E><e>                                                     ' ,& '<E><w><bo>       <C>                                   </C><E></bo><e><end>' ,& '<E><w><bo>       <C>      LLL   </C><bo><B><w> F</bo>ortran   </B><C>            </bo><W> <e></C><E><end>' ,& '<E><w><bo>       <C>     LL LL  </C><bo><B><w>  P</bo>ackage  </B><C>            </bo><W> <e></C><E><end>' ,& '<E><w><bo>       <C>     LL     </C><bo><B><w>   M</bo>anager </B><C>            </bo><W> <e></C><E><end>' ,& '<E><w><bo>       <C>   LLLLLL                          <W> <E></bo><e><end>' ,& '<E><w><bo>       <C>     LL                            <W> <E></bo><e><end>' ,& '<E><w><bo>       <C>     LL               LLLLL LLL    <W> <E></bo><e><end>' ,& '<E><w><bo>       <C>     LL     LLLLLL     LL  L  LL   <W> <E></bo><e><end>' ,& '<E><w><bo>       <C>     LL    LL     L    LL  L  LL   <W> <E></bo><e><end>' ,& '<E><w><bo>       <C>     LL    LL     L    LL  L  LL   <W> <E></bo><e><end>' ,& '<E><w><bo>       <C>     LL    LLLLLLL     LL  L  LL   <W> <E></bo><e><end>' ,& '<E><w><bo>       <C>           LL                      <W> <E></bo><e><end>' ,& '<E><w><bo>       <C>           LL                      <W> <E></bo><e><end>' ,& '<E><w><bo>       <C>           LL                      <W> <E></bo><e><end>' ,& '<E><w><bo>       <C>                                   <W> <E></bo><e><end>' ,& '<E><w><bo>        <W>                                   <E></bo><e>    <end>' ,& '<E><bo><b>Program:</b><w>     fpm(1)                                     ' ,& '<E><bo><b>Description:</b><w> package manager and build system for Fortran' ,& '<E><bo><b>Version:</b><w>     0.3.0, alpha                               ' ,& '<E><bo><b>License:</b><w>     MIT                                        ' ,& '<E><bo><b>Home Page:</b><w>   https://github.com/fortran-lang/fpm        ' ] call attr_mode ( manner = 'color' ) write ( * , '(a)' )( attr ( trim ( help_list_nodash ( i )), chars = 80 ), i = 1 , size ( help_list_nodash )) call paws () write ( * , '(a)' )( attr ( trim ( help_list_dash ( i )), chars = 80 ), i = 1 , size ( help_list_dash )) call paws () ! add custom keywords IF (. FALSE .) THEN call attr_mode ( manner = 'plain' ) call attr_update ( 'end' , '.' , ' ' ) write ( * , '(a)' )( attr ( trim ( text ( i )), chars = 80 ), i = 1 , size ( text )) call paws () ENDIF call attr_mode ( manner = 'color' ) call attr_update ( 'end' , '.' , char ( 0 )) write ( * , '(a)' )( attr ( trim ( text ( i )), chars = 80 ), i = 1 , size ( text )) call paws () contains subroutine paws () character ( len = 1 ) :: letter integer :: ios write ( stdout , '(a)' , advance = 'no' , iostat = ios ) 'Enter [RETURN] to continue ...' read ( * , '(a)' , iostat = ios ) letter write ( stdout , '(a)' ) attr ( '<clear>' ) flush ( unit = stdout , iostat = ios ) end subroutine paws end program fancy","tags":"","loc":"program/fancy.html"},{"title":"demo_M_attrape – M_attr","text":"Uses M_attr Contents Subroutines printstuff Source Code demo_M_attrape Subroutines subroutine printstuff () Arguments None Source Code program demo_M_attrape use M_attr , only : attr , attr_mode , attr_update write ( * , '(a)' ) attr ( '<clear>TEST DEFAULTS:' ) call printstuff () write ( * , '(a)' ) attr ( 'TEST MANNER=PLAIN:' ) call attr_mode ( manner = 'plain' ) call printstuff () write ( * , '(a)' ) attr ( 'TEST MANNER=RAW:' ) call attr_mode ( manner = 'raw' ) call printstuff () write ( * , '(a)' ) attr ( 'TEST MANNER=VT102:' ) call attr_mode ( manner = 'vt102' ) call printstuff () write ( * , '(a)' ) attr ( 'TEST ADDING A CUSTOM SEQUENCE:' ) call attr_update ( 'blink' , char ( 27 ) // '[5m' ) call attr_update ( '/blink' , char ( 27 ) // '[38m' ) write ( * , '(a)' ) attr ( '<blink>Items for Friday</blink>' ) contains subroutine printstuff () write ( * , '(a)' ) attr ( '<r>RED</r>,<g>GREEN</g>,<b>BLUE</b>' ) write ( * , '(a)' ) attr ( '<c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y>' ) write ( * , '(a)' ) attr ( '<w>WHITE</w> and <e>EBONY</e>' ) write ( * , '(a)' ) attr ( 'Adding <bo>bold</bo>' ) write ( * , '(a)' ) attr ( '<bo><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></bo>' ) write ( * , '(a)' ) attr ( '<bo><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y></bo>' ) write ( * , '(a)' ) attr ( '<bo><w>WHITE</w> and <e>EBONY</e></bo>' ) write ( * , '(a)' ) attr ( 'Adding <ul>underline</ul>' ) write ( * , '(a)' ) attr ( '<bo><ul><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><w>WHITE</w> and <e>EBONY</e></ul></bo>' ) write ( * , '(a)' ) attr ( 'Adding <ul>italic</ul>' ) write ( * , '(a)' ) attr ( '<bo><ul><it><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></it></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><it><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</it></y></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><it><w>WHITE</w> and <e>EBONY</e></ul></bo>' ) write ( * , '(a)' ) attr ( 'Adding <in>inverse</in>' ) write ( * , '(a)' ) attr ( '<in><bo><ul><it><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></it></ul></bo></in>' ) write ( * , '(a)' ) attr ( '<in><bo><ul><it><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</it></y></ul></bo></in>' ) write ( * , '(a)' ) attr ( '<in><bo><ul><it><w>WHITE</w> and <e>EBONY</e></ul></bo></in>' ) end subroutine printstuff end program demo_M_attrape","tags":"","loc":"program/demo_m_attrape.html"},{"title":"demo_dump – M_attr","text":"Uses M_attr Contents Source Code demo_dump Source Code program demo_dump use M_attr , only : attr write ( * , '(a)' , advance = 'no' ) attr ( '<dump>' ) end program demo_dump","tags":"","loc":"program/demo_dump.html"},{"title":"position – M_attr","text":"Uses M_attr Contents Source Code position Source Code program position use M_attr , only : attr write ( * , '(a)' ) attr ( '<clear><B><w><bo><CSI>12;36f Good Morning! ' ) end program position","tags":"","loc":"program/position.html"},{"title":"demo_M_attr – M_attr","text":"Uses M_attr Contents Source Code demo_M_attr Source Code program demo_M_attr use M_attr , only : attr , attr_mode , attr_update write ( * , '(a)' ) attr ( 'TEST MANNER=DEFAULT:' ) write ( * , '(a)' ) attr ( '<r>RED</r>,<g>GREEN</g>,<b>BLUE</b>' ) write ( * , '(a)' ) attr ( '<c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y>' ) write ( * , '(a)' ) attr ( '<w>WHITE</w> and <e>EBONY</e>' ) write ( * , '(a)' ) attr ( 'Adding <bo>bold</bo>' ) write ( * , '(a)' ) attr ( '<bo><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></bo>' ) write ( * , '(a)' ) attr ( '<bo><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y></bo>' ) write ( * , '(a)' ) attr ( '<bo><w>WHITE</w> and <e>EBONY</e></bo>' ) write ( * , '(a)' ) attr ( 'Adding <ul>underline</ul>' ) write ( * , '(a)' ) attr ( '<bo><ul><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><w>WHITE</w> and <e>EBONY</e></ul></bo>' ) write ( * , '(a)' ) attr ( 'Adding <ul>italic</ul>' ) write ( * , '(a)' ) attr ( '<bo><ul><it><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></it></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><it><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</it></y></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><it><w>WHITE</w> and <e>EBONY</e></ul></bo>' ) write ( * , '(a)' ) attr ( 'Adding <in>inverse</in>' ) write ( * , '(a)' ) attr ( '<in><bo><ul><it><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></it></ul></bo></in>' ) write ( * , '(a)' ) attr ( '<in><bo><ul><it><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</it></y></ul></bo></in>' ) write ( * , '(a)' ) attr ( '<in><bo><ul><it><w>WHITE</w> and <e>EBONY</e></ul></bo></in>' ) end program demo_M_attr","tags":"","loc":"program/demo_m_attr~2.html"},{"title":"demo_update – M_attr","text":"Uses M_attr Contents Source Code demo_update Source Code program demo_update use M_attr , only : attr , attr_update write ( * , '(a)' ) attr ( '<clear>TEST CUSTOMIZATIONS:' ) ! add custom keywords call attr_update ( 'blink' , char ( 27 ) // '[5m' ) call attr_update ( '/blink' , char ( 27 ) // '[38m' ) write ( * , * ) write ( * , '(a)' ) attr ( '<blink>Items for Friday</blink>' ) call attr_update ( 'ouch' , attr ( & ' <R><bo><w>BIG mistake!</R></w> ' )) write ( * , * ) write ( * , '(a)' ) attr ( '<ouch> Did not see that coming.' ) write ( * , * ) write ( * , '(a)' ) attr ( & 'ORIGINALLY: <r>Apple</r>, <b>Sky</b>, <g>Grass</g>' ) ! delete call attr_update ( 'r' ) call attr_update ( '/r' ) ! replace (or create) call attr_update ( 'b' , '<<<<' ) call attr_update ( '/b' , '>>>>' ) write ( * , * ) write ( * , '(a)' ) attr ( & 'CUSTOMIZED: <r>Apple</r>, <b>Sky</b>, <g>Grass</g>' ) end program demo_update","tags":"","loc":"program/demo_update.html"},{"title":"demo_M_attr – M_attr","text":"Uses M_attr Contents Variables f line value Source Code demo_M_attr Variables Type Attributes Name Initial character(len=*), parameter :: f = '( \" GREAT: The new value \",f8.4,1x,\" is in range\")' character(len=256) :: line real :: value Source Code program demo_M_attr use M_attr , only : attr , attr_mode , attr_update implicit none character ( len = 256 ) :: line character ( len =* ), parameter :: f = '( & &\"   <bo><w><G> GREAT: </G></w>& &The new value <Y><b>\",f8.4,1x,\"</b></Y> is in range\"& &)' real :: value write ( * , '(a)' )& & attr ( '   <r><W><bo> ERROR: </W>red text on a white background</y>' ) value = 3.4567 write ( line , fmt = f ) value write ( * , '(a)' ) attr ( trim ( line )) ! write same string as plain text write ( * , * ) call attr_mode ( manner = 'plain' ) write ( * , '(a)' ) attr ( trim ( line )) call attr_mode ( manner = 'color' ) ! use pre-defined or user defined strings write ( * , * ) write ( * , '(a)' ) attr ( '<ERROR> Woe is nigh.' ) write ( * , '(a)' ) attr ( '<WARNING> The night is young.' ) write ( * , '(a)' ) attr ( '<INFO> It is Monday' ) ! create a custom mneumonic call attr_update ( 'MYERROR' , attr (& ' <R><e> E<w>-<e>R<w>-<e>R<w>-<e>O<w>-<e>R: </e></R></bo>' & )) write ( * , * ) write ( * , '(a)' ) attr ( '<MYERROR> my custom message style' ) end program demo_M_attr","tags":"","loc":"program/demo_m_attr~3.html"},{"title":"demo_attr_mode – M_attr","text":"Uses M_attr Contents Variables i lines outlines Source Code demo_attr_mode Variables Type Attributes Name Initial integer :: i character(len=:), allocatable :: lines (:) character(len=:), allocatable :: outlines (:) Source Code program demo_attr_mode use M_attr , only : attr , attr_mode implicit none character ( len = :), allocatable :: lines (:) character ( len = :), allocatable :: outlines (:) integer :: i lines = [ character ( len = 110 ) :: & '<B><y>' ,& '<B><y>  Suffice it to say that <W><e>black</e></W><B><y>& & and <E><w>white</w></E><B><y> are also colors' ,& '<B><y>  for their simultaneous contrast is as striking as that ' ,& '<B><y>  of <R><g>green</g></R><B><y> and <G><r>red</r></G><B><y>,& & for instance. --- <bo>Vincent van Gogh' ,& '<B><y>' ,& ' ' ] outlines = attr ( lines , chars = 57 ) write ( * , '(a)' )( trim ( outlines ( i )), i = 1 , size ( outlines )) call attr_mode ( manner = 'plain' ) ! write as plain text write ( * , '(a)' ) attr ( lines ) call attr_mode ( manner = 'raw' ) ! write as-is write ( * , '(a)' ) attr ( lines ) call attr_mode ( manner = 'ansi' ) ! return to default mode outlines = attr ( lines , chars = 80 ) write ( * , '(a)' )( trim ( outlines ( i )), i = 1 , size ( outlines )) end program demo_attr_mode","tags":"","loc":"program/demo_attr_mode.html"},{"title":"demo_advice – M_attr","text":"Uses M_attr Contents Source Code demo_advice Source Code program demo_advice use M_attr , only : advice , attr implicit none call advice ( \"error\" , \"Say you didn't!\" ) call advice ( \"warn\" , \"I wouldn't if I were you, Will Robinson.\" ) call advice ( \"info\" , \"I fixed that for you, but it was a bad idea.\" ) call advice ( \"???    \" , \"not today you don't\" ) ! call to just update the macros call advice () ! conventional call to ATTR(3f) using the ADVICE(3f)-defined macros write ( * , * ) attr ( '<bo>The year was <g><YE></g>, the month was <g><MO></g>' ) end program demo_advice","tags":"","loc":"program/demo_advice.html"},{"title":"demo_esc – M_attr","text":"Uses M_attr Contents Subroutines printstuff Source Code demo_esc Subroutines subroutine printstuff (label) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: label Source Code program demo_esc use M_attr , only : attr , attr_mode , attr_update call printstuff ( 'defaults' ) call attr_mode ( manner = 'plain' ) call printstuff ( 'plain:' ) call printstuff ( 'raw' ) call attr_mode ( manner = 'color' ) call printstuff ( '' ) write ( * , '(a)' ) attr ( 'TEST ADDING A CUSTOM SEQUENCE:' ) call attr_update ( 'blink' , char ( 27 ) // '[5m' ) call attr_update ( '/blink' , char ( 27 ) // '[38m' ) write ( * , '(a)' ) attr ( '<blink>Items for Friday</blink>' ) contains subroutine printstuff ( label ) character ( len =* ), intent ( in ) :: label character ( len = :), allocatable :: array (:) call attr_mode ( manner = label ) array = [ character ( len = 60 ) :: & 'TEST MANNER=' // label , & '<r>RED</r>,<g>GREEN</g>,<b>BLUE</b>' , & '<c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y>' , & '<w>WHITE</w> and <e>EBONY</e>' ] write ( * , '(a)' ) attr ( array ) write ( * , '(a)' ) attr ( 'Adding <bo>bold</bo>' ) write ( * , '(a)' ) attr ( '<bo><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></bo>' ) write ( * , '(a)' ) attr ( '<bo><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y></bo>' ) write ( * , '(a)' ) attr ( '<bo><w>WHITE</w> and <e>EBONY</e></bo>' ) write ( * , '(a)' ) attr ( 'Adding <ul>underline</ul>' ) write ( * , '(a)' ) attr (& & '<bo><ul><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></ul></bo>' ) write ( * , '(a)' ) attr (& & '<bo><ul><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><w>WHITE</w> and <e>EBONY</e></ul></bo>' ) write ( * , '(a)' ) attr ( 'Adding <ul>italic</ul>' ) write ( * , '(a)' ) attr (& & '<bo><ul><it><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></it></ul></bo>' ) write ( * , '(a)' ) attr (& & '<bo><ul><it><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</it></y></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><it><w>WHITE</w> and <e>EBONY</e></ul></bo>' ) write ( * , '(a)' ) attr ( 'Adding <in>inverse</in>' ) write ( * , '(a)' ) attr ( '<in><bo><ul><it><r>RED</r>,<g>GREEN</g>,& &<b>BLUE</b></it></ul></bo></in>' ) write ( * , '(a)' ) attr ( '<in><bo><ul><it><c>CYAN</c>,<m>MAGENTA</g>,& &<y>YELLOW</it></y></ul></bo></in>' ) write ( * , '(a)' ) attr (& & '<in><bo><ul><it><w>WHITE</w> and <e>EBONY</e></ul></bo></in>' ) end subroutine printstuff end program demo_esc","tags":"","loc":"program/demo_esc.html"},{"title":"runtest – M_attr","text":"Uses M_msg M_verify M_testsuite_M_attr Contents Source Code runtest Source Code program runtest use M_msg use M_verify , only : unit_check_command , unit_check_keep_going , unit_check_level use M_testsuite_M_attr unit_check_command = '' unit_check_keep_going = . true . unit_check_level = 0 call test_suite_M_attr () end program runtest","tags":"","loc":"program/runtest.html"}]}