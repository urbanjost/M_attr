var tipuesearch = {"pages":[{"title":" M_attr ","text":"M_attr Developer Info John S. Urban","tags":"home","loc":"index.html"},{"title":"M_attr.f90 – M_attr","text":"Contents Modules M_attr Source Code M_attr.f90 Source Code !> !!##NAME !!    M_attr(3f) - [M_attr] control text attributes on terminals !!    (LICENSE:MIT) !! !!##SYNOPSIS !! !!      use M_attr, only : attr, attr_mode, attr_update !! !!##MAJOR FEATURES !!   o Add text attributes with an HTML-like syntax using attr(3f). !!   o suppress the escape sequence output with attr_mode(3f). !!   o customize what strings are produced using attr_update(3f). !! !!##DESCRIPTION !!    M_attr(3f) is a Fortran module that writes common ANSI escape !!    sequences which control terminal attributes like text color. It is !!    designed to allow the sequences to be suppressed and for the user !!    program to completely customize it -- the user can add, delete and !!    replace the sequences associated with a keyword without changing !!    the code. !! !!    Attributes are specified by writing lines with HTML-like structure. !! !!    The advantage of the approach of replacing in-band escape sequences !!    with formatting directives contained on each line is that it is easy !!    to turn off when running batch, but more importantly your program can !!    be run in \"raw\" mode and write a clean text file with the directives in !!    it that can then be read back in by a simple filter program that strips !!    it back to plain text( see app/plain.f90), or displays it to a screen !!    in color(see app/light.f90) or perhaps converts it to another format. !! !!    By making each line self-contained by default this can still be done !!    with any arbitrarily selected group of lines from the file. !! !!    So in addition to printing colored lines to your screen this module !!    makes it trivial to read specially-formatted data from a file like a !!    message catalog (perhaps with various versions in different languages) !!    and colorize it or display it as plain text using the included attr(3f) !!    procedure, for example. !! !!##LIMITATIONS !!   o colors are not nestable. !!   o keywords are case-sensitive, !!   o ANSI escape sequences are not universally supported by !!     all terminal emulators; and normally should be suppressed !!     when not going to a tty device. Therefore, you should use !!     M_system::system_istty(3f) or the common Fortran extension !!     ISATTY() to set the default to \"plain\" instead of \"color\" !!     when the output file is not a conforming terminal. On basic !!     MSWindows console windows, it is best to use Windows 10+ and/or !!     the Linux mode; you may have to enable ANSI escape sequence !!     mode on MSWindows. It does work as-is with CygWin and MinGW and !!     Putty windows and mintty(1) as tested. !! !!##EXAMPLE !! !!    Sample program !! !!     program demo_M_attr !!     use M_attr, only : attr, attr_mode, attr_update !!     implicit none !!     character(len=256) :: line !!     character(len=*),parameter :: f='( & !!      &\"   <bo><w><G> GREAT: </G></w>& !!      &The new value <Y><b>\",f8.4,1x,\"</b></Y> is in range\"& !!      &)' !!     real :: value !! !!        write(*,'(a)')& !!        &attr('   <r><W><bo> ERROR: </W>red text on a white background</y>') !! !!        value=3.4567 !!        write(line,fmt=f) value !!        write(*,'(a)')attr(trim(line)) !! !!        ! write same string as plain text !!        write(*,*) !!        call attr_mode(manner='plain') !!        write(*,'(a)')attr(trim(line)) !! !!        call attr_mode(manner='color') !!        ! use pre-defined or user defined strings !!        write(*,*) !!        write(*,'(a)')attr('<ERROR> Woe is nigh.') !!        write(*,'(a)')attr('<WARNING> The night is young.') !!        write(*,'(a)')attr('<INFO> It is Monday') !! !!        ! create a custom mneumonic !!        call attr_update('MYERROR',attr(& !!        ' <R><e> E<w>-<e>R<w>-<e>R<w>-<e>O<w>-<e>R: </e></R></bo>'& !!        )) !!        write(*,*) !!        write(*,'(a)')attr('<MYERROR> my custom message style') !! !!     end program demo_M_attr !! !!##AUTHOR !!    John S. Urban, 2020 !! !!##LICENSE !!    MIT !! !!##SEE ALSO !!    attr(3f), attr_mode(3f), attr_update(3f) !! !!    Related information: !! !!     terminfo(3c), termlib(3c), tput(1), reset(1), clear(1), !!     console_codes(4), ECMA-48, !!     https://en.wikipedia.org/wiki/ANSI_escape_code module M_attr use , intrinsic :: iso_fortran_env , only : stderr => ERROR_UNIT , stdin => INPUT_UNIT , stdout => OUTPUT_UNIT use , intrinsic :: iso_c_binding , only : c_int implicit none private public :: attr public :: attr_mode public :: attr_update private :: attr_matrix private :: attr_scalar private :: attr_scalar_width private :: get private :: locate ! find PLACE in sorted character array where value can be found or should be placed private :: insert ! insert entry into a sorted allocatable array at specified position private :: replace ! replace entry by index from a sorted allocatable array if it is present private :: remove ! delete entry by index from a sorted allocatable array if it is present private :: wipe_dictionary private :: vt102 interface attr module procedure attr_scalar module procedure attr_matrix module procedure attr_scalar_width end interface ! direct use of constant strings character ( len = :), allocatable , save :: keywords (:) character ( len = :), allocatable , save :: values (:) character ( len = :), allocatable , save :: mono_values (:) character ( len = :), allocatable , save :: mode ! mnemonics character ( len =* ), parameter :: NL = new_line ( 'a' ) ! New line character. character ( len =* ), parameter :: ESCAPE = achar ( 27 ) ! \"\\\" character. ! codes character ( len =* ), parameter :: CODE_START = ESCAPE // '[' ! Start ANSI code, \"\". character ( len =* ), parameter :: CODE_END = 'm' ! End ANSI code, \"m\". character ( len =* ), parameter :: CODE_RESET = CODE_START // '0' // CODE_END ! Clear all styles, \"0m\". character ( len =* ), parameter :: CLEAR_DISPLAY = CODE_START // '2J' character ( len =* ), parameter :: HOME_DISPLAY = CODE_START // 'H' character ( len =* ), parameter :: BELL = achar ( 7 ) character ( len =* ), parameter :: AT_BOLD = '1' , AT_ITALIC = '3' , AT_UNDERLINE = '4' , AT_INVERSE = '7' character ( len =* ), parameter :: BLACK = '0' , RED = '1' , GREEN = '2' , YELLOW = '3' , BLUE = '4' , MAGENTA = '5' , CYAN = '6' , WHITE = '7' , DEFAULT = '9' !prefixes character ( len =* ), parameter :: FG = '3' character ( len =* ), parameter :: BG = '4' character ( len =* ), parameter :: FG_INTENSE = '9' character ( len =* ), parameter :: BG_INTENSE = '10' character ( len =* ), parameter :: ON = '' character ( len =* ), parameter :: OFF = '2' ! foreground colors character ( len =* ), parameter , public :: fg_red = CODE_START // FG // RED // CODE_END character ( len =* ), parameter , public :: fg_cyan = CODE_START // FG // CYAN // CODE_END character ( len =* ), parameter , public :: fg_magenta = CODE_START // FG // MAGENTA // CODE_END character ( len =* ), parameter , public :: fg_blue = CODE_START // FG // BLUE // CODE_END character ( len =* ), parameter , public :: fg_green = CODE_START // FG // GREEN // CODE_END character ( len =* ), parameter , public :: fg_yellow = CODE_START // FG // YELLOW // CODE_END character ( len =* ), parameter , public :: fg_white = CODE_START // FG // WHITE // CODE_END character ( len =* ), parameter , public :: fg_ebony = CODE_START // FG // BLACK // CODE_END character ( len =* ), parameter , public :: fg_black = CODE_START // FG // BLACK // CODE_END character ( len =* ), parameter , public :: fg_default = CODE_START // FG // DEFAULT // CODE_END ! background colors character ( len =* ), parameter , public :: bg_red = CODE_START // BG // RED // CODE_END character ( len =* ), parameter , public :: bg_cyan = CODE_START // BG // CYAN // CODE_END character ( len =* ), parameter , public :: bg_magenta = CODE_START // BG // MAGENTA // CODE_END character ( len =* ), parameter , public :: bg_blue = CODE_START // BG // BLUE // CODE_END character ( len =* ), parameter , public :: bg_green = CODE_START // BG // GREEN // CODE_END character ( len =* ), parameter , public :: bg_yellow = CODE_START // BG // YELLOW // CODE_END character ( len =* ), parameter , public :: bg_white = CODE_START // BG // WHITE // CODE_END character ( len =* ), parameter , public :: bg_ebony = CODE_START // BG // BLACK // CODE_END character ( len =* ), parameter , public :: bg_black = CODE_START // BG // BLACK // CODE_END character ( len =* ), parameter , public :: bg_default = CODE_START // BG // DEFAULT // CODE_END ! attributes character ( len =* ), parameter , public :: bold = CODE_START // ON // AT_BOLD // CODE_END character ( len =* ), parameter , public :: italic = CODE_START // ON // AT_ITALIC // CODE_END character ( len =* ), parameter , public :: inverse = CODE_START // ON // AT_INVERSE // CODE_END character ( len =* ), parameter , public :: underline = CODE_START // ON // AT_UNDERLINE // CODE_END character ( len =* ), parameter , public :: unbold = CODE_START // OFF // AT_BOLD // CODE_END character ( len =* ), parameter , public :: unitalic = CODE_START // OFF // AT_ITALIC // CODE_END character ( len =* ), parameter , public :: uninverse = CODE_START // OFF // AT_INVERSE // CODE_END character ( len =* ), parameter , public :: ununderline = CODE_START // OFF // AT_UNDERLINE // CODE_END character ( len =* ), parameter , public :: reset = CODE_RESET character ( len =* ), parameter , public :: clear = HOME_DISPLAY // CLEAR_DISPLAY contains !> !!##NAME !!    attr(3f) - [M_attr] substitute escape sequences for HTML-like syntax !!               in strings !!    (LICENSE:MIT) !! !!##SYNOPSIS !! !!      function attr(string,reset) result (expanded) !! !!        ! scalar !!        character(len=*),intent(in)  :: string !!        logical,intent(in),optional  :: reset !!        character(len=:),allocatable :: expanded !!        ! or array !!        character(len=*),intent(in)  :: string(:) !!        logical,intent(in),optional  :: reset !!        character(len=:),allocatable :: expanded(:) !!        integer,intent(in),optional  :: chars !! !!##DESCRIPTION !!    Use HTML-like syntax to add attributes to terminal output such as color !!    on devices that recognize ANSI escape sequences. !! !!##OPTIONS !!    string        input string  of form !! !!                    \"<attribute_name>string</attribute_name> ...\". !! !!                   where the current attributes are color names, !!                   bold, italic, underline, ... !! !!    reset          By default, a sequence to clear all text attributes !!                   is sent at the end of each returned line if an escape !!                   character appears in the output string. This can be !!                   turned off by setting RESET to .false. . !! !!                   Note if turning off the reset attributes may be !!                   continued accross lines, but if each line is not !!                   self-contained attributes may not display properly !!                   when filtered with commands such as grep(1). !! !!    chars          For arrays, a reset will be placed after the Nth !!                   displayable column count in order to make it easier !!                   to generate consistent right borders for non-default !!                   background colors for a text block. !!##KEYWORDS !!    primary default keywords !! !!      colors: !!        r,         red,       R,  RED !!        g,         green,     G,  GREEN !!        b,         blue,      B,  BLUE !!        m,         magenta,   M,  MAGENTA !!        c,         cyan,      C,  CYAN !!        y,         yellow,    Y,  YELLOW !!        e,         ebony,     E,  EBONY !!        w,         white,     W,  WHITE !!      attributes: !!        it,        italic !!        bo,        bold !!        un,        underline !!       other: !!        clear !!        escape !!        default !!        reset !!        gt !!        lt !!      dual-value (one for color, one for mono): !!        write(*,*)attr('<ERROR>an error message') !!        write(*,*)attr('<WARNING>a warning message') !!        write(*,*)attr('<INFO>an informational message') !! !!    By default, if the color mnemonics (ie. the keywords) are uppercase !!    they change the background color. If lowercase, the foreground color. !!    When preceded by a \"/\" character the attribute is returned to the default. !! !!    The \"default\" keyword is typically used explicitly when !!    reset=.false, and sets all text attributes to their initial defaults. !! !!##LIMITATIONS !!    o colors are not nestable, keywords are case-sensitive, !!    o not all terminals obey the sequences. On Windows, it is best if !!      you use Windows 10+ and/or the Linux mode; although it has worked !!      with all CygWin and MinGW and Putty windows and mintty. !!    o you should use \"<gt>\" and \"<lt>\" instead of \">\" and \"<\" in a string !!      processed by attr(3f) instead of in any plain text output so that !!      the raw mode will create correct input for the attr(3f) function !!      if read back in. !! !!##EXAMPLE !! !!    Sample program !! !!     program demo_esc !!     use M_attr, only : attr, attr_mode, attr_update !!        call printstuff('defaults') !! !!        call attr_mode(manner='plain') !!        call printstuff('plain:') !! !!        call printstuff('raw') !! !!        call attr_mode(manner='color') !!        call printstuff('') !! !!        write(*,'(a)') attr('TEST ADDING A CUSTOM SEQUENCE:') !!        call attr_update('blink',char(27)//'[5m') !!        call attr_update('/blink',char(27)//'[38m') !!        write(*,'(a)') attr('<blink>Items for Friday</blink>') !! !!     contains !!     subroutine printstuff(label) !!     character(len=*),intent(in)  :: label !!     character(len=:),allocatable :: array(:) !!       call attr_mode(manner=label) !! !!       array=[character(len=60) ::    & !!        'TEST MANNER='//label,                      & !!        '<r>RED</r>,<g>GREEN</g>,<b>BLUE</b>',      & !!        '<c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y>', & !!        '<w>WHITE</w> and <e>EBONY</e>'] !!       write(*,'(a)') attr(array) !! !!       write(*,'(a)') attr('Adding <bo>bold</bo>') !!       write(*,'(a)') attr('<bo><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></bo>') !!       write(*,'(a)') attr('<bo><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y></bo>') !!       write(*,'(a)') attr('<bo><w>WHITE</w> and <e>EBONY</e></bo>') !! !!       write(*,'(a)') attr('Adding <ul>underline</ul>') !!       write(*,'(a)') attr(& !!        &'<bo><ul><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></ul></bo>') !!       write(*,'(a)') attr(& !!        &'<bo><ul><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y></ul></bo>') !!       write(*,'(a)') attr('<bo><ul><w>WHITE</w> and <e>EBONY</e></ul></bo>') !! !!       write(*,'(a)') attr('Adding <ul>italic</ul>') !!       write(*,'(a)') attr(& !!        &'<bo><ul><it><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></it></ul></bo>') !!       write(*,'(a)') attr(& !!        &'<bo><ul><it><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</it></y></ul></bo>') !!       write(*,'(a)') attr('<bo><ul><it><w>WHITE</w> and <e>EBONY</e></ul></bo>') !! !!       write(*,'(a)') attr('Adding <in>inverse</in>') !!       write(*,'(a)') attr(& !!        &'<in><bo><ul><it><r>RED</r>,<g>GREEN</g>,& !!        &<b>BLUE</b></it></ul></bo></in>') !!       write(*,'(a)') attr(& !!        &'<in><bo><ul><it><c>CYAN</c>,<m>MAGENTA</g>,& !!        &<y>YELLOW</it></y></ul></bo></in>') !!       write(*,'(a)') attr(& !!        &'<in><bo><ul><it><w>WHITE</w> and <e>EBONY</e></ul></bo></in>') !!     end subroutine printstuff !! !!     end program demo_esc !! !!##AUTHOR !!    John S. Urban, 2020 !! !!##LICENSE !!    MIT !! !!##SEE ALSO !!    attr_mode(3f), attr_update(3f) function attr_scalar ( string , reset ) result ( expanded ) character ( len =* ), intent ( in ) :: string logical , intent ( in ), optional :: reset logical :: clear_at_end character ( len = :), allocatable :: padded character ( len = :), allocatable :: expanded character ( len = :), allocatable :: name integer :: i integer :: ii integer :: maxlen integer :: place if ( present ( reset )) then clear_at_end = reset else clear_at_end = . true . endif if (. not . allocated ( mode )) then ! set substitution mode mode = 'color' ! 'color'|'raw'|'plain' call vt102 () endif if ( mode == 'raw' ) then expanded = string return endif maxlen = len ( string ) padded = string // ' ' i = 1 expanded = '' do select case ( padded ( i : i )) case ( '>' ) ! should not get here unless unmatched i = i + 1 expanded = expanded // '>' case ( '<' ) ! assuming not nested for now ii = index ( padded ( i + 1 :), '>' ) if ( ii . eq . 0 ) then expanded = expanded // '<' i = i + 1 else name = padded ( i + 1 : i + ii - 1 ) name = trim ( adjustl ( name )) call locate ( keywords , name , place ) if ( mode . eq . 'plain' ) then expanded = expanded // get ( name ) elseif ( place . le . 0 ) then ! unknown name; print what you found expanded = expanded // padded ( i : i + ii ) else expanded = expanded // get ( name ) endif i = ii + i + 1 endif case default expanded = expanded // padded ( i : i ) i = i + 1 end select if ( i >= maxlen + 1 ) exit enddo if ( ( index ( expanded , escape ). ne . 0 ). and .( clear_at_end )) then if (( mode . ne . 'raw' ). and .( mode . ne . 'plain' )) then expanded = expanded // CODE_RESET ! Clear all styles endif endif expanded = trim ( expanded ) end function attr_scalar function attr_matrix ( string , reset , chars ) result ( expanded ) character ( len =* ), intent ( in ) :: string (:) logical , intent ( in ), optional :: reset integer , intent ( in ), optional :: chars character ( len = :), allocatable :: expanded (:) !gfortran does not return allocatable array from a function properly, but works with subroutine call kludge_bug ( string , reset , chars , expanded ) end function attr_matrix subroutine kludge_bug ( string , reset , chars , expanded ) character ( len =* ), intent ( in ) :: string (:) logical , intent ( in ), optional :: reset integer , intent ( in ), optional :: chars character ( len = :), allocatable :: expanded (:) integer :: width character ( len = :), allocatable :: hold integer :: i integer :: right integer :: len_local integer :: len_local2 allocate ( character ( len = 0 ) :: expanded ( 0 )) if ( present ( chars )) then right = chars else right = len ( string ) endif if (. not . allocated ( mode )) then ! set substitution mode mode = 'color' ! 'color'|'raw'|'plain' call vt102 () endif do i = 1 , size ( string ) if ( mode . eq . 'color' ) then len_local2 = len_trim ( attr_scalar ( string ( i ))) mode = 'plain' len_local = len_trim ( attr_scalar ( string ( i ))) hold = trim ( string ( i )) // repeat ( ' ' , max ( 0 , right - len_local )) mode = 'color' else hold = string ( i ) endif hold = attr_scalar ( hold , reset = reset ) width = max ( len ( hold ), len ( expanded )) expanded = [ character ( len = width ) :: expanded , hold ] enddo end subroutine kludge_bug function attr_scalar_width ( string , reset , chars ) result ( expanded ) character ( len =* ), intent ( in ) :: string logical , intent ( in ), optional :: reset integer , intent ( in ) :: chars character ( len = :), allocatable :: expanded_arr (:) character ( len = :), allocatable :: expanded expanded_arr = attr_matrix ([ string ], reset , chars ) expanded = expanded_arr ( 1 ) end function attr_scalar_width subroutine vt102 () ! create a dictionary with character keywords, values, and value lengths ! using the routines for maintaining a list call wipe_dictionary () ! insert and replace entries call attr_update ( 'bold' , bold ) call attr_update ( '/bold' , unbold ) call attr_update ( 'bo' , bold ) call attr_update ( '/bo' , unbold ) call attr_update ( 'livid' , bold ) call attr_update ( '/livid' , unbold ) call attr_update ( 'li' , bold ) call attr_update ( '/li' , unbold ) call attr_update ( 'italic' , italic ) call attr_update ( '/italic' , unitalic ) call attr_update ( 'it' , italic ) call attr_update ( '/it' , unitalic ) call attr_update ( 'inverse' , inverse ) call attr_update ( '/inverse' , uninverse ) call attr_update ( 'in' , inverse ) call attr_update ( '/in' , uninverse ) call attr_update ( 'underline' , underline ) call attr_update ( '/underline' , ununderline ) call attr_update ( 'un' , underline ) call attr_update ( '/un' , ununderline ) call attr_update ( 'ul' , underline ) call attr_update ( '/ul' , ununderline ) call attr_update ( 'attr' , ESCAPE ) call attr_update ( 'escape' , ESCAPE ) call attr_update ( 'clear' , clear ) call attr_update ( 'reset' , reset ) call attr_update ( 'bell' , BELL ) call attr_update ( 'gt' , '>' ) call attr_update ( 'lt' , '<' ) ! foreground colors call attr_update ( 'r' , fg_red ) call attr_update ( '/r' , fg_default ) call attr_update ( 'red' , fg_red ) call attr_update ( '/red' , fg_default ) call attr_update ( 'c' , fg_cyan ) call attr_update ( '/c' , fg_default ) call attr_update ( 'cyan' , fg_cyan ) call attr_update ( '/cyan' , fg_default ) call attr_update ( 'm' , fg_magenta ) call attr_update ( '/m' , fg_default ) call attr_update ( 'magenta' , fg_magenta ) call attr_update ( '/magenta' , fg_default ) call attr_update ( 'b' , fg_blue ) call attr_update ( '/b' , fg_default ) call attr_update ( 'blue' , fg_blue ) call attr_update ( '/blue' , fg_default ) call attr_update ( 'g' , fg_green ) call attr_update ( '/g' , fg_default ) call attr_update ( 'green' , fg_green ) call attr_update ( '/green' , fg_default ) call attr_update ( 'y' , fg_yellow ) call attr_update ( '/y' , fg_default ) call attr_update ( 'yellow' , fg_yellow ) call attr_update ( '/yellow' , fg_default ) call attr_update ( 'w' , fg_white ) call attr_update ( '/w' , fg_default ) call attr_update ( 'white' , fg_white ) call attr_update ( '/white' , fg_default ) call attr_update ( 'e' , fg_ebony ) call attr_update ( '/e' , fg_default ) call attr_update ( 'ebony' , fg_ebony ) call attr_update ( '/ebony' , fg_default ) call attr_update ( 'x' , fg_ebony ) call attr_update ( '/x' , fg_default ) call attr_update ( 'black' , fg_ebony ) call attr_update ( '/black' , fg_default ) ! background colors call attr_update ( 'R' , bg_red ) call attr_update ( '/R' , bg_default ) call attr_update ( 'RED' , bg_red ) call attr_update ( '/RED' , bg_default ) call attr_update ( 'C' , bg_cyan ) call attr_update ( '/C' , bg_default ) call attr_update ( 'CYAN' , bg_cyan ) call attr_update ( '/CYAN' , bg_default ) call attr_update ( 'M' , bg_magenta ) call attr_update ( '/M' , bg_default ) call attr_update ( 'MAGENTA' , bg_magenta ) call attr_update ( '/MAGENTA' , bg_default ) call attr_update ( 'B' , bg_blue ) call attr_update ( '/B' , bg_default ) call attr_update ( 'BLUE' , bg_blue ) call attr_update ( '/BLUE' , bg_default ) call attr_update ( 'G' , bg_green ) call attr_update ( '/G' , bg_default ) call attr_update ( 'GREEN' , bg_green ) call attr_update ( '/GREEN' , bg_default ) call attr_update ( 'Y' , bg_yellow ) call attr_update ( '/Y' , bg_default ) call attr_update ( 'YELLOW' , bg_yellow ) call attr_update ( '/YELLOW' , bg_default ) call attr_update ( 'W' , bg_white ) call attr_update ( '/W' , bg_default ) call attr_update ( 'WHITE' , bg_white ) call attr_update ( '/WHITE' , bg_default ) call attr_update ( 'E' , bg_ebony ) call attr_update ( '/E' , bg_default ) call attr_update ( 'EBONY' , bg_ebony ) call attr_update ( '/EBONY' , bg_default ) call attr_update ( 'X' , bg_ebony ) call attr_update ( '/X' , bg_default ) call attr_update ( 'BLACK' , bg_ebony ) call attr_update ( '/BLACK' , bg_default ) call attr_update ( 'ERROR' , fg_red // bold // bg_ebony // 'error:' // bg_default // fg_default , 'ERROR:' ) call attr_update ( 'WARNING' , fg_magenta // bold // bg_ebony // 'warning:' // bg_default // fg_default , 'WARNING:' ) call attr_update ( 'INFO' , fg_yellow // bold // bg_ebony // 'info:' // bg_default // fg_default , 'INFO:' ) end subroutine vt102 !> !! !> !!##NAME !!    attr_mode(3f) - [M_attr] select processing mode for output from attr(3f) !!    (LICENSE:MIT) !! !!##SYNOPSIS !! !!     subroutine attr_mode(manner) !! !!        character(len=*),intent(in) :: manner !! !!##DESCRIPTION !!    Turn off the generation of strings associated with the HTML keywords !!    in the string generated by the attr(3f) function, or display the !!    text in raw mode as it was passed to attr(3f) or return to ANSI !!    escape control sequence generation. !! !!##OPTIONS !!    MANNER  The current manners or modes supported via the attr_mode(3f) !!             procedure are !! !!         plain          suppress the output associated with keywords !!         color(default) commonly supported escape sequences !!         raw            echo the input to attr(3f) as its output !!         reload         restore original keyword meanings deleted or !!                        replaced by calls to attr_update(3f). !! !!##EXAMPLE !! !!    Sample program !! !!     program demo_attr_mode !!     use M_attr, only : attr, attr_mode !!     implicit none !!     character(len=:),allocatable :: lines(:) !!     character(len=:),allocatable :: outlines(:) !!     integer :: i !!        lines=[character(len=110):: & !!        '<B><y>',& !!        '<B><y>  Suffice it to say that <W><e>black</e></W><B><y>& !!        & and <E><w>white</w></E><B><y> are also colors',& !!        '<B><y>  for their simultaneous contrast is as striking as that ',& !!        '<B><y>  of <R><g>green</g></R><B><y> and <G><r>red</r></G><B><y>,& !!        & for instance. --- <bo>Vincent van Gogh',& !!        '<B><y>',& !!        ' '] !! !!        outlines=attr(lines,chars=57) !!        write(*,'(a)')(trim(outlines(i)),i=1,size(outlines)) !! !!        call attr_mode(manner='plain') ! write as plain text !!        write(*,'(a)')attr(lines) !!        call attr_mode(manner='raw')   ! write as-is !!        write(*,'(a)')attr(lines) !! !!        call attr_mode(manner='ansi')  ! return to default mode !!        outlines=attr(lines,chars=80) !!        write(*,'(a)')(trim(outlines(i)),i=1,size(outlines)) !! !!     end program demo_attr_mode !! !!##AUTHOR !!    John S. Urban, 2020 !! !!##LICENSE !!    MIT subroutine attr_mode ( manner ) character ( len =* ), intent ( in ) :: manner integer :: i if (. not . allocated ( mode )) then ! set substitution mode mode = 'color' call vt102 () endif select case ( manner ) case ( 'vt102' , 'ANSI' , 'ansi' , 'color' , 'COLOR' ) mode = 'color' case ( 'reload' , 'default' , 'defaults' , '' ) call vt102 () mode = 'color' case ( 'raw' ) mode = 'raw' case ( 'dump' ) ! dump dictionary for debugging if ( allocated ( keywords )) then if ( size ( keywords ). gt . 0 ) then write ( stderr , '(*(a,t30,a))' ) 'KEYWORD' , 'VALUE' write ( stderr , '(*(a,t30,2(\"[\",a,\"]\"),/))' )( trim ( keywords ( i )), values ( i ), mono_values ( i ), i = 1 , size ( keywords )) endif endif case ( 'dummy' , 'plain' , 'text' ) mode = 'plain' case default write ( * , * ) 'unknown manner. Try color|raw|plain' mode = 'color' end select end subroutine attr_mode subroutine wipe_dictionary () if ( allocated ( keywords )) deallocate ( keywords ) allocate ( character ( len = 0 ) :: keywords ( 0 )) if ( allocated ( values )) deallocate ( values ) allocate ( character ( len = 0 ) :: values ( 0 )) if ( allocated ( mono_values )) deallocate ( mono_values ) allocate ( character ( len = 0 ) :: mono_values ( 0 )) end subroutine wipe_dictionary !> !! !> !!##NAME !!    attr_update(3f) - [M_attr] update internal dictionary given keyword and value !!    (LICENSE:MIT) !! !!##SYNOPSIS !! !! !!    subroutine attr_update(key,val) !! !!     character(len=*),intent(in)           :: key !!     character(len=*),intent(in),optional  :: val !!     character(len=*),intent(in),optional  :: mono_val !! !!##DESCRIPTION !!    Update internal dictionary in M_attr(3fm) module. !! !!##OPTIONS !!    key       name of keyword to add, replace, or delete from dictionary !!    val       if present add or replace value associated with keyword. If !!              not present remove keyword entry from dictionary. !!    mono_val  if present add or replace second value associated with !!              keyword used for plain text mode. !!              Must only be specified if VAL is also specified. !! !!##KEYWORDS !!    The following keywords are defined by default !! !!    colors: !! !!      r,red     c,cyan     w,white !!      g,green   m,magenta  e,ebony !!      b,blue    y,yellow !! !!    If the color keywords are capitalized they control the text background !!    instead of the text color. !! !!    attributes: !! !!      ul,underline !!      it,italics (often produces inverse colors on many devices !! !!##EXAMPLE !! !! !!    Sample program !! !!      program demo_update !!      use M_attr, only : attr, attr_update !!         write(*,'(a)') attr('<clear>TEST CUSTOMIZED:') !! !!         ! add custom keywords !!         call attr_update('blink',char(27)//'[5m') !!         call attr_update('/blink',char(27)//'[38m') !! !!         write(*,*) !!         write(*,'(a)') attr('<blink>Items for Friday</blink>') !! !!         call attr_update('ouch',attr( & !!         ' <R><bo><w>BIG mistake!</R></w> ')) !!         write(*,*) !!         write(*,'(a)') attr('<ouch> Did not see that coming.') !! !!         write(*,*) !!         write(*,'(a)') attr( & !!         'ORIGINALLY: <r>Apple</r>, <b>Sky</b>, <g>Grass</g>') !! !!         ! delete !!         call attr_update('r') !!         call attr_update('/r') !! !!         ! replace (or create) !!         call attr_update('b','<<<<') !!         call attr_update('/b','>>>>') !!         write(*,*) !!         write(*,'(a)') attr( & !!         'CUSTOMIZED: <r>Apple</r>, <b>Sky</b>, <g>Grass</g>') !! !!      end program demo_update !! !! !!##AUTHOR !!    John S. Urban, 2020 !! !!##LICENSE !!    MIT subroutine attr_update ( key , valin , mono_valin ) character ( len =* ), intent ( in ) :: key character ( len =* ), intent ( in ), optional :: valin character ( len =* ), intent ( in ), optional :: mono_valin integer :: place character ( len = :), allocatable :: val character ( len = :), allocatable :: mono_val if ( present ( mono_valin )) then mono_val = mono_valin else mono_val = '' endif if ( present ( valin )) then val = valin ! find where string is or should be call locate ( keywords , key , place ) ! if string was not found insert it if ( place . lt . 1 ) then call insert ( keywords , key , iabs ( place )) call insert ( values , val , iabs ( place )) call insert ( mono_values , mono_val , iabs ( place )) else call replace ( values , val , place ) call replace ( mono_values , mono_val , place ) endif else call locate ( keywords , key , place ) if ( place . gt . 0 ) then call remove ( keywords , place ) call remove ( values , place ) call remove ( mono_values , place ) endif endif end subroutine attr_update function get ( key ) result ( valout ) character ( len =* ), intent ( in ) :: key character ( len = :), allocatable :: valout integer :: place ! find where string is or should be call locate ( keywords , key , place ) if ( place . lt . 1 ) then valout = '' else if ( mode . eq . 'plain' ) then valout = trim ( mono_values ( place )) else valout = trim ( values ( place )) endif endif end function get subroutine locate ( list , value , place , ier , errmsg ) character ( len =* ), intent ( in ) :: value integer , intent ( out ) :: place character ( len = :), allocatable :: list (:) integer , intent ( out ), optional :: ier character ( len =* ), intent ( out ), optional :: errmsg integer :: i character ( len = :), allocatable :: message integer :: arraysize integer :: maxtry integer :: imin , imax integer :: error if (. not . allocated ( list )) then list = [ character ( len = max ( len_trim ( value ), 2 )) :: ] endif arraysize = size ( list ) error = 0 if ( arraysize . eq . 0 ) then maxtry = 0 place =- 1 else maxtry = int ( log ( float ( arraysize )) / log ( 2.0 ) + 1.0 ) place = ( arraysize + 1 ) / 2 endif imin = 1 imax = arraysize message = '' LOOP : block do i = 1 , maxtry if ( value . eq . list ( PLACE )) then exit LOOP else if ( value . gt . list ( place )) then imax = place - 1 else imin = place + 1 endif if ( imin . gt . imax ) then place =- imin if ( iabs ( place ). gt . arraysize ) then ! ran off end of list. Where new value should go or an unsorted input array' exit LOOP endif exit LOOP endif place = ( imax + imin ) / 2 if ( place . gt . arraysize . or . place . le . 0 ) then message = '*locate* error: search is out of bounds of list. Probably an unsorted input array' error =- 1 exit LOOP endif enddo message = '*locate* exceeded allowed tries. Probably an unsorted input array' endblock LOOP if ( present ( ier )) then ier = error else if ( error . ne . 0 ) then write ( stderr , * ) message // ' VALUE=' , trim ( value ) // ' PLACE=' , place stop 1 endif if ( present ( errmsg )) then errmsg = message endif end subroutine locate subroutine remove ( list , place ) character ( len = :), allocatable :: list (:) integer , intent ( in ) :: place integer :: ii , end if (. not . allocated ( list )) then list = [ character ( len = 2 ) :: ] endif ii = len ( list ) end = size ( list ) if ( place . le . 0. or . place . gt . end ) then ! index out of bounds of array elseif ( place . eq . end ) then ! remove from array list = [ character ( len = ii ) :: list (: place - 1 ) ] else list = [ character ( len = ii ) :: list (: place - 1 ), list ( place + 1 :) ] endif end subroutine remove subroutine replace ( list , value , place ) character ( len =* ), intent ( in ) :: value character ( len = :), allocatable :: list (:) character ( len = :), allocatable :: kludge (:) integer , intent ( in ) :: place integer :: ii integer :: tlen integer :: end if (. not . allocated ( list )) then list = [ character ( len = max ( len_trim ( value ), 2 )) :: ] endif tlen = len_trim ( value ) end = size ( list ) if ( place . lt . 0. or . place . gt . end ) then write ( stderr , * ) '*replace* error: index out of range. end=' , end , ' index=' , place elseif ( len_trim ( value ). le . len ( list )) then list ( place ) = value else ! increase length of variable ii = max ( tlen , len ( list )) kludge = [ character ( len = ii ) :: list ] list = kludge list ( place ) = value endif end subroutine replace subroutine insert ( list , value , place ) character ( len =* ), intent ( in ) :: value character ( len = :), allocatable :: list (:) character ( len = :), allocatable :: kludge (:) integer , intent ( in ) :: place integer :: ii integer :: end if (. not . allocated ( list )) then list = [ character ( len = max ( len_trim ( value ), 2 )) :: ] endif ii = max ( len_trim ( value ), len ( list ), 2 ) end = size ( list ) if ( end . eq . 0 ) then ! empty array list = [ character ( len = ii ) :: value ] elseif ( place . eq . 1 ) then ! put in front of array kludge = [ character ( len = ii ) :: value , list ] list = kludge elseif ( place . gt . end ) then ! put at end of array kludge = [ character ( len = ii ) :: list , value ] list = kludge elseif ( place . ge . 2. and . place . le . end ) then ! put in middle of array kludge = [ character ( len = ii ) :: list (: place - 1 ), value , list ( place :) ] list = kludge else ! index out of range write ( stderr , * ) '*insert* error: index out of range. end=' , end , ' index=' , place , ' value=' , value endif end subroutine insert end module M_attr","tags":"","loc":"sourcefile/m_attr.f90.html"},{"title":"redirect.F90 – M_attr","text":"Contents Programs roots Source Code redirect.F90 Source Code program roots use , intrinsic :: iso_fortran_env , only : stdin => input_unit , stdout => output_unit , stderr => error_unit use M_attr , only : attr , attr_mode , attr_update ! Calculate and print the roots of a quadratic formula even if they are complex implicit none integer , parameter :: dp = kind ( 0.0d0 ) real ( kind = dp ) :: a , b , c , discriminant real ( kind = dp ) :: x1 , x2 , x ! Real roots of the equation real ( kind = dp ) :: x_real ! Real part of complex root of the equation REAL ( kind = dp ) :: x_complex ! Imaginary part of complex root of the equation character ( len = 256 ) :: message integer :: ios character ( len = 1 ) :: paws character ( len = 1024 ) :: buffer character ( len =* ), parameter :: numbers = '(\"<B><w><bo>   \",*(\"(\",g0.8,\",\",g0.8,\")\":,1x))' if ( system_isatty ( stdout )) then ! ISATTY() is an extension, but found in Intel, GNU, PGI, ... compiler call attr_mode ( 'color' ) else call attr_mode ( 'plain' ) endif INFINITE : do ! clear screen, set attributes and print messages call text ( \"<reset><clear>\" ) call text ( \"For the quadratic equation <m>A</m><g>*x**2 +<m>B</m><g>*x + <m>C</m> \" ) write ( * , '(*(a))' , advance = 'no' ) & & attr ( '<B><w><bo>' // repeat ( '_' , 78 ) // '  ' ), & & char ( 13 ),& & attr ( '<B><g><bo>enter coefficients <m>A,B,C</m><g>:<y><gt><ul>' ,& & reset = . false .) read ( * , * , iostat = ios , iomsg = message ) a , b , c write ( * , '(a)' , advance = 'no' ) attr ( '<reset>' ) if ( ios . ne . 0 ) then write ( * , '(*(g0))' ) ios , ' ' , trim ( message ) else ! Given the equation \"A*X**2 + B*X + C = 0\" ! Use the quadratic formula to determine the root values of the equation. ! prompt for new value call text () call text ( 'Given the equation' ) call text () write ( buffer , '(*(g0.8))' ) '<B><w><bo>   ' , a , '<m>*X**2</m><w> + ' , b , '<m>*X</m><w> + ' , c , ' = 0' call text ( buffer ) call text () discriminant = b ** 2 - 4 * a * c if ( a . eq . 0 ) then call text ( '<ERROR> <m>If <m>a</m><g> is zero this is a linear, not quadratic equation' ) elseif ( discriminant > 0 ) then call text ( 'the <m>roots</m><g> (ie. \"x intercepts\") are <m>real<m><g> so the parabola ' ) call text ( 'crosses the x-axis at <m>two points</m><g>:' ) call text () x1 = ( - b + sqrt ( discriminant )) / ( 2 * a ) x2 = ( - b - sqrt ( discriminant )) / ( 2 * a ) write ( buffer , numbers ) x1 , 0.0d0 call text ( buffer ) write ( buffer , numbers ) x2 , 0.0d0 call text ( buffer ) call text () elseif ( discriminant == 0 ) then call text ( 'the <m>roots</m><g> (ie. \"x intercepts\") are repeated <m>(real and equal)</m><g>' ) call text ( 'so the parabola just touches the x-axis at:' ) call text () if ( b . ne . 0 ) then x = ( - b ) / ( 2 * a ) else x = 0.0d0 endif write ( buffer , numbers ) x , 0.0d0 call text ( buffer ) call text () else call text ( 'the <m>roots</m><g>(ie. \"x intercepts\")  are <m>complex</m><g>:' ) x_real = ( - b ) / ( 2 * a ) x_complex = sqrt ( abs ( discriminant )) / ( 2 * a ) call text () WRITE ( buffer , '(a,*(\"(\",g0.8,\", +i\",g0.8,\")\",:,1x))' ) '<B><w><bo>   ' , x_real , x_complex call text ( buffer ) WRITE ( buffer , '(a,*(\"(\",g0.8,\", -i\",g0.8,\")\",:,1x))' ) '<B><w><bo>   ' , x_real , x_complex call text ( buffer ) call text () endif call text ( 'with' ) call text () write ( buffer , '(g0,*(g0.8,1x))' ) \"<B><w><bo>   <m>discriminate</m><w> = \" , discriminant call text ( buffer ) call text () endif write ( * , '(*(g0))' , advance = 'no' ) attr ( '<B><e>press <g>return</g><e> to continue, \"<g>q</g><e>\" to quit:' , chars = 79 ) read ( * , advance = 'yes' , iostat = ios , fmt = '(a)' , iomsg = message ) paws if ( paws . ne . '' ) exit INFINITE enddo INFINITE contains subroutine text ( string ) character ( len =* ), intent ( in ), optional :: string if ( present ( string )) then write ( * , '(*(g0))' ) attr ( '<B><g><bo>' // string , chars = 80 ) else write ( * , '(*(g0))' ) attr ( '<B><g><bo>' , chars = 80 ) endif end subroutine text !>  call compiler-specific ISATTY() function or return .FALSE. #undef ISATTY #ifdef __INTEL_COMPILER function system_isatty ( lun ) use IFPORT integer , intent ( in ) :: lun logical :: system_isatty system_isatty = isatty ( lun ) end function system_isatty #define ISATTY #endif #ifdef __NVCOMPILER_MAJOR__X ! __NVCOMPILER_MAJOR__ __NVCOMPILER_MINOR__ __NVCOMPILER_PATCHLEVEL__ function system_isatty ( lun ) use DFPORT integer , intent ( in ) :: lun logical :: system_isatty system_isatty = isatty ( lun ) end function system_isatty #define ISATTY #endif #ifdef __GFORTRAN__ function system_isatty ( lun ) integer , intent ( in ) :: lun logical :: system_isatty system_isatty = isatty ( lun ) end function system_isatty #define ISATTY #endif #ifndef ISATTY function system_isatty ( lun ) integer , intent ( in ) :: lun logical :: system_isatty system_isatty = . false . end function system_isatty #define ISATTY #endif END PROGRAM roots","tags":"","loc":"sourcefile/redirect.f90.html"},{"title":"light.f90 – M_attr","text":"Contents Programs demo_attr Source Code light.f90 Source Code program demo_attr ! read stdin and run it through M_attr::attr to display color use M_attr , only : attr , attr_update implicit none character ( len = 1024 ) :: line character ( len = :), allocatable :: expanded integer :: ios line = '' call attr_update ( 'Z' , char ( 27 ) // '[1m' ) do read ( * , '(a)' , iostat = ios ) line expanded = attr ( trim ( line )) write ( * , '(a)' ) expanded if ( ios . ne . 0 ) exit enddo write ( * , '(a)' , advance = 'no' ) attr ( '<reset>' ) end program demo_attr","tags":"","loc":"sourcefile/light.f90.html"},{"title":"plain.f90 – M_attr","text":"Contents Programs demo_attr Source Code plain.f90 Source Code program demo_attr ! read stdin and run it through M_attr::attr to display without color use M_attr , only : attr , attr_mode implicit none character ( len = 1024 ) :: line integer :: ios line = '' call attr_mode ( manner = 'plain' ) do read ( * , '(a)' , iostat = ios ) line write ( * , '(a)' ) attr ( trim ( line )) if ( ios . ne . 0 ) exit enddo write ( * , '(a)' , advance = 'no' ) attr ( '<reset>' ) end program demo_attr","tags":"","loc":"sourcefile/plain.f90.html"},{"title":"demo_M_attr.f90 – M_attr","text":"Contents Programs demo_M_attr Source Code demo_M_attr.f90 Source Code program demo_M_attr use M_attr , only : attr , attr_mode , attr_update implicit none character ( len = 256 ) :: line character ( len =* ), parameter :: f = '( & &\"   <bo><w><G> GREAT: </G></w>& &The new value <Y><b>\",f8.4,1x,\"</b></Y> is in range\"& &)' real :: value write ( * , '(a)' )& & attr ( '   <r><W><bo> ERROR: </W>red text on a white background</y>' ) value = 3.4567 write ( line , fmt = f ) value write ( * , '(a)' ) attr ( trim ( line )) ! write same string as plain text write ( * , * ) call attr_mode ( manner = 'plain' ) write ( * , '(a)' ) attr ( trim ( line )) call attr_mode ( manner = 'color' ) ! use pre-defined or user defined strings write ( * , * ) write ( * , '(a)' ) attr ( '<ERROR> Woe is nigh.' ) write ( * , '(a)' ) attr ( '<WARNING> The night is young.' ) write ( * , '(a)' ) attr ( '<INFO> It is Monday' ) ! create a custom mneumonic call attr_update ( 'MYERROR' , attr (& ' <R><e> E<w>-<e>R<w>-<e>R<w>-<e>O<w>-<e>R: </e></R></bo>' & )) write ( * , * ) write ( * , '(a)' ) attr ( '<MYERROR> my custom message style' ) end program demo_M_attr","tags":"","loc":"sourcefile/demo_m_attr.f90.html"},{"title":"demo_attr.f90 – M_attr","text":"Contents Programs demo_esc Source Code demo_attr.f90 Source Code program demo_esc use M_attr , only : attr , attr_mode , attr_update call printstuff ( 'defaults' ) call attr_mode ( manner = 'plain' ) call printstuff ( 'plain:' ) call printstuff ( 'raw' ) call attr_mode ( manner = 'color' ) call printstuff ( '' ) write ( * , '(a)' ) attr ( 'TEST ADDING A CUSTOM SEQUENCE:' ) call attr_update ( 'blink' , char ( 27 ) // '[5m' ) call attr_update ( '/blink' , char ( 27 ) // '[38m' ) write ( * , '(a)' ) attr ( '<blink>Items for Friday</blink>' ) contains subroutine printstuff ( label ) character ( len =* ), intent ( in ) :: label character ( len = :), allocatable :: array (:) call attr_mode ( manner = label ) array = [ character ( len = 60 ) :: & 'TEST MANNER=' // label , & '<r>RED</r>,<g>GREEN</g>,<b>BLUE</b>' , & '<c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y>' , & '<w>WHITE</w> and <e>EBONY</e>' ] write ( * , '(a)' ) attr ( array ) write ( * , '(a)' ) attr ( 'Adding <bo>bold</bo>' ) write ( * , '(a)' ) attr ( '<bo><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></bo>' ) write ( * , '(a)' ) attr ( '<bo><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y></bo>' ) write ( * , '(a)' ) attr ( '<bo><w>WHITE</w> and <e>EBONY</e></bo>' ) write ( * , '(a)' ) attr ( 'Adding <ul>underline</ul>' ) write ( * , '(a)' ) attr (& & '<bo><ul><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></ul></bo>' ) write ( * , '(a)' ) attr (& & '<bo><ul><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><w>WHITE</w> and <e>EBONY</e></ul></bo>' ) write ( * , '(a)' ) attr ( 'Adding <ul>italic</ul>' ) write ( * , '(a)' ) attr (& & '<bo><ul><it><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></it></ul></bo>' ) write ( * , '(a)' ) attr (& & '<bo><ul><it><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</it></y></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><it><w>WHITE</w> and <e>EBONY</e></ul></bo>' ) write ( * , '(a)' ) attr ( 'Adding <in>inverse</in>' ) write ( * , '(a)' ) attr (& & '<in><bo><ul><it><r>RED</r>,<g>GREEN</g>,& &<b>BLUE</b></it></ul></bo></in>' ) write ( * , '(a)' ) attr (& & '<in><bo><ul><it><c>CYAN</c>,<m>MAGENTA</g>,& &<y>YELLOW</it></y></ul></bo></in>' ) write ( * , '(a)' ) attr (& & '<in><bo><ul><it><w>WHITE</w> and <e>EBONY</e></ul></bo></in>' ) end subroutine printstuff end program demo_esc","tags":"","loc":"sourcefile/demo_attr.f90.html"},{"title":"demo_attr_update.f90 – M_attr","text":"Contents Programs demo_update Source Code demo_attr_update.f90 Source Code program demo_update use M_attr , only : attr , attr_update write ( * , '(a)' ) attr ( '<clear>TEST CUSTOMIZED:' ) ! add custom keywords call attr_update ( 'blink' , char ( 27 ) // '[5m' ) call attr_update ( '/blink' , char ( 27 ) // '[38m' ) write ( * , * ) write ( * , '(a)' ) attr ( '<blink>Items for Friday</blink>' ) call attr_update ( 'ouch' , attr ( & ' <R><bo><w>BIG mistake!</R></w> ' )) write ( * , * ) write ( * , '(a)' ) attr ( '<ouch> Did not see that coming.' ) write ( * , * ) write ( * , '(a)' ) attr ( & 'ORIGINALLY: <r>Apple</r>, <b>Sky</b>, <g>Grass</g>' ) ! delete call attr_update ( 'r' ) call attr_update ( '/r' ) ! replace (or create) call attr_update ( 'b' , '<<<<' ) call attr_update ( '/b' , '>>>>' ) write ( * , * ) write ( * , '(a)' ) attr ( & 'CUSTOMIZED: <r>Apple</r>, <b>Sky</b>, <g>Grass</g>' ) end program demo_update","tags":"","loc":"sourcefile/demo_attr_update.f90.html"},{"title":"demo_attr_mode.f90 – M_attr","text":"Contents Programs demo_attr_mode Source Code demo_attr_mode.f90 Source Code program demo_attr_mode use M_attr , only : attr , attr_mode implicit none character ( len = :), allocatable :: lines (:) character ( len = :), allocatable :: outlines (:) integer :: i lines = [ character ( len = 110 ) :: & '<B><y>' ,& '<B><y>  Suffice it to say that <W><e>black</e></W><B><y>& & and <E><w>white</w></E><B><y> are also colors' ,& '<B><y>  for their simultaneous contrast is as striking as that ' ,& '<B><y>  of <R><g>green</g></R><B><y> and <G><r>red</r></G><B><y>,& & for instance. --- <bo>Vincent van Gogh' ,& '<B><y>' ,& ' ' ] outlines = attr ( lines , chars = 57 ) write ( * , '(a)' )( trim ( outlines ( i )), i = 1 , size ( outlines )) call attr_mode ( manner = 'plain' ) ! write as plain text write ( * , '(a)' ) attr ( lines ) call attr_mode ( manner = 'raw' ) ! write as-is write ( * , '(a)' ) attr ( lines ) call attr_mode ( manner = 'ansi' ) ! return to default mode outlines = attr ( lines , chars = 80 ) write ( * , '(a)' )( trim ( outlines ( i )), i = 1 , size ( outlines )) end program demo_attr_mode","tags":"","loc":"sourcefile/demo_attr_mode.f90.html"},{"title":"custom.f90 – M_attr","text":"Contents Programs demo_M_attr Source Code custom.f90 Source Code program demo_M_attr use M_attr , only : attr , attr_update write ( * , '(a)' ) attr ( '<clear>TEST CUSTOMIZED:' ) ! add custom keywords call attr_update ( 'blink' , char ( 27 ) // '[5m' ) call attr_update ( '/blink' , char ( 27 ) // '[38m' ) write ( * , '(a)' ) attr ( '<blink>Items for Friday</blink>' ) write ( * , '(a)' , advance = 'no' ) attr ( '<r>RED</r>,' ) write ( * , '(a)' , advance = 'no' ) attr ( '<b>BLUE</b>,' ) write ( * , '(a)' , advance = 'yes' ) attr ( '<g>GREEN</g>' ) ! delete call attr_update ( 'r' ) call attr_update ( '/r' ) ! replace call attr_update ( 'b' , '<<<<' ) call attr_update ( '/b' , '>>>>' ) write ( * , '(a)' , advance = 'no' ) attr ( '<r>RED</r>,' ) write ( * , '(a)' , advance = 'no' ) attr ( '<b>BLUE</b>,' ) write ( * , '(a)' , advance = 'yes' ) attr ( '<g>GREEN</g>' ) end program demo_M_attr","tags":"","loc":"sourcefile/custom.f90.html"},{"title":"message.f90 – M_attr","text":"Contents Programs mode Source Code message.f90 Source Code program mode use M_attr , only : attr , attr_mode implicit none call printme ( 'color' ) call printme ( 'plain' ) call printme ( 'raw' ) contains subroutine printme ( mymode ) character ( len =* ), intent ( in ) :: mymode call attr_mode ( mymode ) write ( * , '(a)' ) mymode write ( * , '(a)' ) attr ( '<ERROR>Woe is nigh.' ) write ( * , '(a)' ) attr ( '<WARNING>The night is young.' ) write ( * , '(a)' ) attr ( '<INFO>It is Monday' ) end subroutine printme end program mode","tags":"","loc":"sourcefile/message.f90.html"},{"title":"mixed.f90 – M_attr","text":"Contents Programs demo_M_attrape Source Code mixed.f90 Source Code program demo_M_attrape use M_attr , only : attr , attr_mode , attr_update write ( * , '(a)' ) attr ( '<clear>TEST DEFAULTS:' ) call printstuff () write ( * , '(a)' ) attr ( 'TEST MANNER=PLAIN:' ) call attr_mode ( manner = 'plain' ) call printstuff () write ( * , '(a)' ) attr ( 'TEST MANNER=RAW:' ) call attr_mode ( manner = 'raw' ) call printstuff () write ( * , '(a)' ) attr ( 'TEST MANNER=VT102:' ) call attr_mode ( manner = 'vt102' ) call printstuff () write ( * , '(a)' ) attr ( 'TEST ADDING A CUSTOM SEQUENCE:' ) call attr_update ( 'blink' , char ( 27 ) // '[5m' ) call attr_update ( '/blink' , char ( 27 ) // '[38m' ) write ( * , '(a)' ) attr ( '<blink>Items for Friday</blink>' ) contains subroutine printstuff () write ( * , '(a)' ) attr ( '<r>RED</r>,<g>GREEN</g>,<b>BLUE</b>' ) write ( * , '(a)' ) attr ( '<c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y>' ) write ( * , '(a)' ) attr ( '<w>WHITE</w> and <e>EBONY</e>' ) write ( * , '(a)' ) attr ( 'Adding <bo>bold</bo>' ) write ( * , '(a)' ) attr ( '<bo><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></bo>' ) write ( * , '(a)' ) attr ( '<bo><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y></bo>' ) write ( * , '(a)' ) attr ( '<bo><w>WHITE</w> and <e>EBONY</e></bo>' ) write ( * , '(a)' ) attr ( 'Adding <ul>underline</ul>' ) write ( * , '(a)' ) attr ( '<bo><ul><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><w>WHITE</w> and <e>EBONY</e></ul></bo>' ) write ( * , '(a)' ) attr ( 'Adding <ul>italic</ul>' ) write ( * , '(a)' ) attr ( '<bo><ul><it><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></it></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><it><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</it></y></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><it><w>WHITE</w> and <e>EBONY</e></ul></bo>' ) write ( * , '(a)' ) attr ( 'Adding <in>inverse</in>' ) write ( * , '(a)' ) attr ( '<in><bo><ul><it><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></it></ul></bo></in>' ) write ( * , '(a)' ) attr ( '<in><bo><ul><it><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</it></y></ul></bo></in>' ) write ( * , '(a)' ) attr ( '<in><bo><ul><it><w>WHITE</w> and <e>EBONY</e></ul></bo></in>' ) end subroutine printstuff end program demo_M_attrape","tags":"","loc":"sourcefile/mixed.f90.html"},{"title":"dump.f90 – M_attr","text":"Contents Programs demo_dump Source Code dump.f90 Source Code program demo_dump use M_attr , only : attr write ( * , '(a)' , advance = 'no' ) attr ( '<dump>' ) end program demo_dump","tags":"","loc":"sourcefile/dump.f90.html"},{"title":"functional.f90 – M_attr","text":"Contents Programs mode Source Code functional.f90 Source Code program mode use M_attr , only : attr , attr_mode implicit none call printme ( 'color' ) call printme ( 'plain' ) call printme ( 'raw' ) contains subroutine printme ( mymode ) character ( len =* ), intent ( in ) :: mymode call attr_mode ( mymode ) write ( * , '(a)' ) mymode write ( * , '(*(g0))' , advance = 'no' ) attr ( 'red:BLUE:bold' ), 'Hello!' , & & attr ( '/BLUE' ), ' Well, this is boring without a nice background color.' , attr ( 'reset' ) write ( * , '(*(g0))' , advance = 'yes' ) ' Back to a normal write statement.' end subroutine printme end program mode","tags":"","loc":"sourcefile/functional.f90.html"},{"title":"default.f90 – M_attr","text":"Contents Programs demo_M_attr Source Code default.f90 Source Code program demo_M_attr use M_attr , only : attr , attr_mode , attr_update write ( * , '(a)' ) attr ( 'TEST MANNER=DEFAULT:' ) write ( * , '(a)' ) attr ( '<r>RED</r>,<g>GREEN</g>,<b>BLUE</b>' ) write ( * , '(a)' ) attr ( '<c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y>' ) write ( * , '(a)' ) attr ( '<w>WHITE</w> and <e>EBONY</e>' ) write ( * , '(a)' ) attr ( 'Adding <bo>bold</bo>' ) write ( * , '(a)' ) attr ( '<bo><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></bo>' ) write ( * , '(a)' ) attr ( '<bo><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y></bo>' ) write ( * , '(a)' ) attr ( '<bo><w>WHITE</w> and <e>EBONY</e></bo>' ) write ( * , '(a)' ) attr ( 'Adding <ul>underline</ul>' ) write ( * , '(a)' ) attr ( '<bo><ul><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><w>WHITE</w> and <e>EBONY</e></ul></bo>' ) write ( * , '(a)' ) attr ( 'Adding <ul>italic</ul>' ) write ( * , '(a)' ) attr ( '<bo><ul><it><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></it></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><it><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</it></y></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><it><w>WHITE</w> and <e>EBONY</e></ul></bo>' ) write ( * , '(a)' ) attr ( 'Adding <in>inverse</in>' ) write ( * , '(a)' ) attr ( '<in><bo><ul><it><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></it></ul></bo></in>' ) write ( * , '(a)' ) attr ( '<in><bo><ul><it><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</it></y></ul></bo></in>' ) write ( * , '(a)' ) attr ( '<in><bo><ul><it><w>WHITE</w> and <e>EBONY</e></ul></bo></in>' ) end program demo_M_attr","tags":"","loc":"sourcefile/default.f90.html"},{"title":"attr_mode – M_attr","text":"public subroutine attr_mode(manner) !> NAME attr_mode ( 3 f ) - [ M_attr ] select processing mode for output from attr ( 3 f ) ( LICENSE : MIT ) SYNOPSIS subroutine attr_mode(manner)\n\n    character(len=*),intent(in) :: manner DESCRIPTION Turn off the generation of strings associated with the HTML keywords in the string generated by the attr ( 3 f ) function , or display the text in raw mode as it was passed to attr ( 3 f ) or return to ANSI escape control sequence generation . OPTIONS MANNER The current manners or modes supported via the attr_mode ( 3 f ) procedure are plain suppress the output associated with keywords color ( default ) commonly supported escape sequences raw echo the input to attr ( 3 f ) as its output reload restore original keyword meanings deleted or replaced by calls to attr_update ( 3 f ) . EXAMPLE Sample program\n\n program demo_attr_mode\n use M_attr, only : attr, attr_mode\n implicit none\n character(len=:),allocatable :: lines(:)\n character(len=:),allocatable :: outlines(:)\n integer :: i\n    lines=[character(len=110):: & ' <B><y> ', & ' <B><y> Suffice it to say that <W><e> black </e></W><B><y> & & and <E><w> white </w></E><B><y> are also colors', & ' <B><y> for their simultaneous contrast is as striking as that ', & ' <B><y> of <R><g> green </g></R><B><y> and <G><r> red </r></G><B><y> , & & for instance. --- <bo> Vincent van Gogh', & ' <B><y> ', & ' ']\n\n    outlines=attr(lines,chars=57)\n    write(*,'(a)')(trim(outlines(i)),i=1,size(outlines))\n\n    call attr_mode(manner='plain') ! write as plain text\n    write(*,'(a)')attr(lines)\n    call attr_mode(manner='raw')   ! write as-is\n    write(*,'(a)')attr(lines)\n\n    call attr_mode(manner='ansi')  ! return to default mode\n    outlines=attr(lines,chars=80)\n    write(*,'(a)')(trim(outlines(i)),i=1,size(outlines))\n\n end program demo_attr_mode AUTHOR John S. Urban, 2020 LICENSE MIT Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: manner Contents Variables i Source Code attr_mode Variables Type Visibility Attributes Name Initial integer, public :: i Source Code subroutine attr_mode ( manner ) character ( len =* ), intent ( in ) :: manner integer :: i if (. not . allocated ( mode )) then ! set substitution mode mode = 'color' call vt102 () endif select case ( manner ) case ( 'vt102' , 'ANSI' , 'ansi' , 'color' , 'COLOR' ) mode = 'color' case ( 'reload' , 'default' , 'defaults' , '' ) call vt102 () mode = 'color' case ( 'raw' ) mode = 'raw' case ( 'dump' ) ! dump dictionary for debugging if ( allocated ( keywords )) then if ( size ( keywords ). gt . 0 ) then write ( stderr , '(*(a,t30,a))' ) 'KEYWORD' , 'VALUE' write ( stderr , '(*(a,t30,2(\"[\",a,\"]\"),/))' )( trim ( keywords ( i )), values ( i ), mono_values ( i ), i = 1 , size ( keywords )) endif endif case ( 'dummy' , 'plain' , 'text' ) mode = 'plain' case default write ( * , * ) 'unknown manner. Try color|raw|plain' mode = 'color' end select end subroutine attr_mode","tags":"","loc":"proc/attr_mode.html"},{"title":"attr_update – M_attr","text":"public subroutine attr_update(key, valin, mono_valin) !> NAME attr_update ( 3 f ) - [ M_attr ] update internal dictionary given keyword and value ( LICENSE : MIT ) SYNOPSIS subroutine attr_update(key,val)\n\n character(len=*),intent(in)           :: key\n character(len=*),intent(in),optional  :: val\n character(len=*),intent(in),optional  :: mono_val DESCRIPTION Update internal dictionary in M_attr(3fm) module. OPTIONS key name of keyword to add , replace , or delete from dictionary val if present add or replace value associated with keyword . If not present remove keyword entry from dictionary . mono_val if present add or replace second value associated with keyword used for plain text mode . Must only be specified if VAL is also specified . KEYWORDS The following keywords are defined by default colors : r , red c , cyan w , white g , green m , magenta e , ebony b , blue y , yellow If the color keywords are capitalized they control the text background instead of the text color . attributes : ul , underline it , italics ( often produces inverse colors on many devices EXAMPLE Sample program\n\n  program demo_update\n  use M_attr, only : attr, attr_update\n     write(*,'(a)') attr(' <clear> TEST CUSTOMIZED:')\n\n     ! add custom keywords\n     call attr_update('blink',char(27)//'[5m')\n     call attr_update('/blink',char(27)//'[38m')\n\n     write(*,*)\n     write(*,'(a)') attr(' <blink> Items for Friday </blink> ')\n\n     call attr_update('ouch',attr( & ' <R><bo><w> BIG mistake! </R></w> '))\n     write(*,*)\n     write(*,'(a)') attr(' <ouch> Did not see that coming.')\n\n     write(*,*)\n     write(*,'(a)') attr( & 'ORIGINALLY: <r> Apple </r> , <b> Sky </b> , <g> Grass </g> ')\n\n     ! delete\n     call attr_update('r')\n     call attr_update('/r')\n\n     ! replace (or create)\n     call attr_update('b',' <<<< ')\n     call attr_update('/b','>>>>')\n     write(*,*)\n     write(*,'(a)') attr( & 'CUSTOMIZED: <r> Apple </r> , <b> Sky </b> , <g> Grass </g> ')\n\n  end program demo_update AUTHOR John S. Urban, 2020 LICENSE MIT Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: key character(len=*), intent(in), optional :: valin character(len=*), intent(in), optional :: mono_valin Contents Variables mono_val place val Source Code attr_update Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: mono_val integer, public :: place character(len=:), public, allocatable :: val Source Code subroutine attr_update ( key , valin , mono_valin ) character ( len =* ), intent ( in ) :: key character ( len =* ), intent ( in ), optional :: valin character ( len =* ), intent ( in ), optional :: mono_valin integer :: place character ( len = :), allocatable :: val character ( len = :), allocatable :: mono_val if ( present ( mono_valin )) then mono_val = mono_valin else mono_val = '' endif if ( present ( valin )) then val = valin ! find where string is or should be call locate ( keywords , key , place ) ! if string was not found insert it if ( place . lt . 1 ) then call insert ( keywords , key , iabs ( place )) call insert ( values , val , iabs ( place )) call insert ( mono_values , mono_val , iabs ( place )) else call replace ( values , val , place ) call replace ( mono_values , mono_val , place ) endif else call locate ( keywords , key , place ) if ( place . gt . 0 ) then call remove ( keywords , place ) call remove ( values , place ) call remove ( mono_values , place ) endif endif end subroutine attr_update","tags":"","loc":"proc/attr_update.html"},{"title":"attr – M_attr","text":"public interface attr Contents Module Procedures attr_scalar attr_matrix attr_scalar_width Module Procedures private function attr_scalar(string, reset) result(expanded) Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string logical, intent(in), optional :: reset Return Value character(len=:),\n  allocatable private function attr_matrix(string, reset, chars) result(expanded) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string (:) logical, intent(in), optional :: reset integer, intent(in), optional :: chars Return Value character(len=:),\n  allocatable, (:) private function attr_scalar_width(string, reset, chars) result(expanded) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string logical, intent(in), optional :: reset integer, intent(in) :: chars Return Value character(len=:),\n  allocatable","tags":"","loc":"interface/attr.html"},{"title":"system_isatty – M_attr","text":"function system_isatty(lun) call compiler-specific ISATTY() function or return .FALSE. Arguments Type Intent Optional Attributes Name integer, intent(in) :: lun Return Value logical Contents Source Code system_isatty Source Code function system_isatty ( lun ) use IFPORT integer , intent ( in ) :: lun logical :: system_isatty system_isatty = isatty ( lun ) end function system_isatty","tags":"","loc":"proc/system_isatty.html"},{"title":"text – M_attr","text":"subroutine text(string) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: string Contents Source Code text Source Code subroutine text ( string ) character ( len =* ), intent ( in ), optional :: string if ( present ( string )) then write ( * , '(*(g0))' ) attr ( '<B><g><bo>' // string , chars = 80 ) else write ( * , '(*(g0))' ) attr ( '<B><g><bo>' , chars = 80 ) endif end subroutine text","tags":"","loc":"proc/text.html"},{"title":"printstuff – M_attr","text":"subroutine printstuff(label) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: label Contents Variables array Source Code printstuff Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: array (:) Source Code subroutine printstuff ( label ) character ( len =* ), intent ( in ) :: label character ( len = :), allocatable :: array (:) call attr_mode ( manner = label ) array = [ character ( len = 60 ) :: & 'TEST MANNER=' // label , & '<r>RED</r>,<g>GREEN</g>,<b>BLUE</b>' , & '<c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y>' , & '<w>WHITE</w> and <e>EBONY</e>' ] write ( * , '(a)' ) attr ( array ) write ( * , '(a)' ) attr ( 'Adding <bo>bold</bo>' ) write ( * , '(a)' ) attr ( '<bo><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></bo>' ) write ( * , '(a)' ) attr ( '<bo><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y></bo>' ) write ( * , '(a)' ) attr ( '<bo><w>WHITE</w> and <e>EBONY</e></bo>' ) write ( * , '(a)' ) attr ( 'Adding <ul>underline</ul>' ) write ( * , '(a)' ) attr (& & '<bo><ul><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></ul></bo>' ) write ( * , '(a)' ) attr (& & '<bo><ul><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><w>WHITE</w> and <e>EBONY</e></ul></bo>' ) write ( * , '(a)' ) attr ( 'Adding <ul>italic</ul>' ) write ( * , '(a)' ) attr (& & '<bo><ul><it><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></it></ul></bo>' ) write ( * , '(a)' ) attr (& & '<bo><ul><it><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</it></y></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><it><w>WHITE</w> and <e>EBONY</e></ul></bo>' ) write ( * , '(a)' ) attr ( 'Adding <in>inverse</in>' ) write ( * , '(a)' ) attr (& & '<in><bo><ul><it><r>RED</r>,<g>GREEN</g>,& &<b>BLUE</b></it></ul></bo></in>' ) write ( * , '(a)' ) attr (& & '<in><bo><ul><it><c>CYAN</c>,<m>MAGENTA</g>,& &<y>YELLOW</it></y></ul></bo></in>' ) write ( * , '(a)' ) attr (& & '<in><bo><ul><it><w>WHITE</w> and <e>EBONY</e></ul></bo></in>' ) end subroutine printstuff","tags":"","loc":"proc/printstuff.html"},{"title":"printme – M_attr","text":"subroutine printme(mymode) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: mymode Contents Source Code printme Source Code subroutine printme ( mymode ) character ( len =* ), intent ( in ) :: mymode call attr_mode ( mymode ) write ( * , '(a)' ) mymode write ( * , '(a)' ) attr ( '<ERROR>Woe is nigh.' ) write ( * , '(a)' ) attr ( '<WARNING>The night is young.' ) write ( * , '(a)' ) attr ( '<INFO>It is Monday' ) end subroutine printme","tags":"","loc":"proc/printme.html"},{"title":"printstuff – M_attr","text":"subroutine printstuff() Arguments None Contents Source Code printstuff Source Code subroutine printstuff () write ( * , '(a)' ) attr ( '<r>RED</r>,<g>GREEN</g>,<b>BLUE</b>' ) write ( * , '(a)' ) attr ( '<c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y>' ) write ( * , '(a)' ) attr ( '<w>WHITE</w> and <e>EBONY</e>' ) write ( * , '(a)' ) attr ( 'Adding <bo>bold</bo>' ) write ( * , '(a)' ) attr ( '<bo><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></bo>' ) write ( * , '(a)' ) attr ( '<bo><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y></bo>' ) write ( * , '(a)' ) attr ( '<bo><w>WHITE</w> and <e>EBONY</e></bo>' ) write ( * , '(a)' ) attr ( 'Adding <ul>underline</ul>' ) write ( * , '(a)' ) attr ( '<bo><ul><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><w>WHITE</w> and <e>EBONY</e></ul></bo>' ) write ( * , '(a)' ) attr ( 'Adding <ul>italic</ul>' ) write ( * , '(a)' ) attr ( '<bo><ul><it><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></it></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><it><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</it></y></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><it><w>WHITE</w> and <e>EBONY</e></ul></bo>' ) write ( * , '(a)' ) attr ( 'Adding <in>inverse</in>' ) write ( * , '(a)' ) attr ( '<in><bo><ul><it><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></it></ul></bo></in>' ) write ( * , '(a)' ) attr ( '<in><bo><ul><it><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</it></y></ul></bo></in>' ) write ( * , '(a)' ) attr ( '<in><bo><ul><it><w>WHITE</w> and <e>EBONY</e></ul></bo></in>' ) end subroutine printstuff","tags":"","loc":"proc/printstuff~2.html"},{"title":"printme – M_attr","text":"subroutine printme(mymode) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: mymode Contents Source Code printme Source Code subroutine printme ( mymode ) character ( len =* ), intent ( in ) :: mymode call attr_mode ( mymode ) write ( * , '(a)' ) mymode write ( * , '(*(g0))' , advance = 'no' ) attr ( 'red:BLUE:bold' ), 'Hello!' , & & attr ( '/BLUE' ), ' Well, this is boring without a nice background color.' , attr ( 'reset' ) write ( * , '(*(g0))' , advance = 'yes' ) ' Back to a normal write statement.' end subroutine printme","tags":"","loc":"proc/printme~2.html"},{"title":"M_attr – M_attr","text":"NAME M_attr ( 3 f ) - [ M_attr ] control text attributes on terminals ( LICENSE : MIT ) SYNOPSIS use M_attr, only : attr, attr_mode, attr_update MAJOR FEATURES o Add text attributes with an HTML-like syntax using attr(3f).\n   o suppress the escape sequence output with attr_mode(3f).\n   o customize what strings are produced using attr_update(3f). DESCRIPTION M_attr ( 3 f ) is a Fortran module that writes common ANSI escape sequences which control terminal attributes like text color . It is designed to allow the sequences to be suppressed and for the user program to completely customize it -- the user can add , delete and replace the sequences associated with a keyword without changing the code . Attributes are specified by writing lines with HTML - like structure . The advantage of the approach of replacing in - band escape sequences with formatting directives contained on each line is that it is easy to turn off when running batch , but more importantly your program can be run in \"raw\" mode and write a clean text file with the directives in it that can then be read back in by a simple filter program that strips it back to plain text ( see app / plain . f90 ), or displays it to a screen in color ( see app / light . f90 ) or perhaps converts it to another format . By making each line self - contained by default this can still be done with any arbitrarily selected group of lines from the file . So in addition to printing colored lines to your screen this module makes it trivial to read specially - formatted data from a file like a message catalog ( perhaps with various versions in different languages ) and colorize it or display it as plain text using the included attr ( 3 f ) procedure , for example . LIMITATIONS o colors are not nestable.\n   o keywords are case-sensitive,\n   o ANSI escape sequences are not universally supported by\n     all terminal emulators; and normally should be suppressed\n     when not going to a tty device. Therefore, you should use\n     M_system::system_istty(3f) or the common Fortran extension\n     ISATTY() to set the default to “plain” instead of “color”\n     when the output file is not a conforming terminal. On basic\n     MSWindows console windows, it is best to use Windows 10+ and/or\n     the Linux mode; you may have to enable ANSI escape sequence\n     mode on MSWindows. It does work as-is with CygWin and MinGW and\n     Putty windows and mintty(1) as tested. EXAMPLE Sample program\n\n program demo_M_attr\n use M_attr, only : attr, attr_mode, attr_update\n implicit none\n character(len=256) :: line\n character(len=*),parameter :: f='( & & \" <bo><w><G> GREAT: </G></w> & & The new value <Y><b> \",f8.4,1x,\" </b></Y> is in range\" & & )'\n real :: value\n\n    write(*,'(a)') & & attr(' <r><W><bo> ERROR: </W> red text on a white background </y> ')\n\n    value=3.4567\n    write(line,fmt=f) value\n    write(*,'(a)')attr(trim(line))\n\n    ! write same string as plain text\n    write(*,*)\n    call attr_mode(manner='plain')\n    write(*,'(a)')attr(trim(line))\n\n    call attr_mode(manner='color')\n    ! use pre-defined or user defined strings\n    write(*,*)\n    write(*,'(a)')attr(' <ERROR> Woe is nigh.')\n    write(*,'(a)')attr(' <WARNING> The night is young.')\n    write(*,'(a)')attr(' <INFO> It is Monday')\n\n    ! create a custom mneumonic\n    call attr_update('MYERROR',attr( & ' <R><e> E <w> - <e> R <w> - <e> R <w> - <e> O <w> - <e> R: </e></R></bo> ' & ))\n    write(*,*)\n    write(*,'(a)')attr(' <MYERROR> my custom message style')\n\n end program demo_M_attr AUTHOR John S. Urban, 2020 LICENSE MIT SEE ALSO attr(3f), attr_mode(3f), attr_update(3f)\n\nRelated information:\n\n terminfo(3c), termlib(3c), tput(1), reset(1), clear(1),\n console_codes(4), ECMA-48,\n https://en.wikipedia.org/wiki/ANSI_escape_code Uses iso_fortran_env iso_c_binding Contents Variables bg_black bg_blue bg_cyan bg_default bg_ebony bg_green bg_magenta bg_red bg_white bg_yellow bold clear fg_black fg_blue fg_cyan fg_default fg_ebony fg_green fg_magenta fg_red fg_white fg_yellow inverse italic reset unbold underline uninverse unitalic ununderline Interfaces attr Subroutines attr_mode attr_update Variables Type Visibility Attributes Name Initial character(len=*), public, parameter :: bg_black = CODE_START//BG//BLACK//CODE_END character(len=*), public, parameter :: bg_blue = CODE_START//BG//BLUE//CODE_END character(len=*), public, parameter :: bg_cyan = CODE_START//BG//CYAN//CODE_END character(len=*), public, parameter :: bg_default = CODE_START//BG//DEFAULT//CODE_END character(len=*), public, parameter :: bg_ebony = CODE_START//BG//BLACK//CODE_END character(len=*), public, parameter :: bg_green = CODE_START//BG//GREEN//CODE_END character(len=*), public, parameter :: bg_magenta = CODE_START//BG//MAGENTA//CODE_END character(len=*), public, parameter :: bg_red = CODE_START//BG//RED//CODE_END character(len=*), public, parameter :: bg_white = CODE_START//BG//WHITE//CODE_END character(len=*), public, parameter :: bg_yellow = CODE_START//BG//YELLOW//CODE_END character(len=*), public, parameter :: bold = CODE_START//ON//AT_BOLD//CODE_END character(len=*), public, parameter :: clear = HOME_DISPLAY//CLEAR_DISPLAY character(len=*), public, parameter :: fg_black = CODE_START//FG//BLACK//CODE_END character(len=*), public, parameter :: fg_blue = CODE_START//FG//BLUE//CODE_END character(len=*), public, parameter :: fg_cyan = CODE_START//FG//CYAN//CODE_END character(len=*), public, parameter :: fg_default = CODE_START//FG//DEFAULT//CODE_END character(len=*), public, parameter :: fg_ebony = CODE_START//FG//BLACK//CODE_END character(len=*), public, parameter :: fg_green = CODE_START//FG//GREEN//CODE_END character(len=*), public, parameter :: fg_magenta = CODE_START//FG//MAGENTA//CODE_END character(len=*), public, parameter :: fg_red = CODE_START//FG//RED//CODE_END character(len=*), public, parameter :: fg_white = CODE_START//FG//WHITE//CODE_END character(len=*), public, parameter :: fg_yellow = CODE_START//FG//YELLOW//CODE_END character(len=*), public, parameter :: inverse = CODE_START//ON//AT_INVERSE//CODE_END character(len=*), public, parameter :: italic = CODE_START//ON//AT_ITALIC//CODE_END character(len=*), public, parameter :: reset = CODE_RESET character(len=*), public, parameter :: unbold = CODE_START//OFF//AT_BOLD//CODE_END character(len=*), public, parameter :: underline = CODE_START//ON//AT_UNDERLINE//CODE_END character(len=*), public, parameter :: uninverse = CODE_START//OFF//AT_INVERSE//CODE_END character(len=*), public, parameter :: unitalic = CODE_START//OFF//AT_ITALIC//CODE_END character(len=*), public, parameter :: ununderline = CODE_START//OFF//AT_UNDERLINE//CODE_END Interfaces public interface attr private function attr_scalar(string, reset) result(expanded) Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string logical, intent(in), optional :: reset Return Value character(len=:),\n  allocatable private function attr_matrix(string, reset, chars) result(expanded) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string (:) logical, intent(in), optional :: reset integer, intent(in), optional :: chars Return Value character(len=:),\n  allocatable, (:) private function attr_scalar_width(string, reset, chars) result(expanded) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string logical, intent(in), optional :: reset integer, intent(in) :: chars Return Value character(len=:),\n  allocatable Subroutines public subroutine attr_mode (manner) !> Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: manner public subroutine attr_update (key, valin, mono_valin) !> Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: key character(len=*), intent(in), optional :: valin character(len=*), intent(in), optional :: mono_valin","tags":"","loc":"module/m_attr.html"},{"title":"roots – M_attr","text":"Uses iso_fortran_env M_attr Contents Variables a b buffer c discriminant dp ios message numbers paws x x1 x2 x_complex x_real Functions system_isatty Subroutines text Source Code roots Variables Type Attributes Name Initial real(kind=dp) :: a real(kind=dp) :: b character(len=1024) :: buffer real(kind=dp) :: c real(kind=dp) :: discriminant integer, parameter :: dp = kind(0.0d0) integer :: ios character(len=256) :: message character(len=*), parameter :: numbers = '(\" \",*(\"(\",g0.8,\",\",g0.8,\")\":,1x))' character(len=1) :: paws real(kind=dp) :: x real(kind=dp) :: x1 real(kind=dp) :: x2 real(kind=dp) :: x_complex real(kind=dp) :: x_real Functions function system_isatty (lun) call compiler-specific ISATTY() function or return .FALSE. Arguments Type Intent Optional Attributes Name integer, intent(in) :: lun Return Value logical Subroutines subroutine text (string) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: string Source Code program roots use , intrinsic :: iso_fortran_env , only : stdin => input_unit , stdout => output_unit , stderr => error_unit use M_attr , only : attr , attr_mode , attr_update ! Calculate and print the roots of a quadratic formula even if they are complex implicit none integer , parameter :: dp = kind ( 0.0d0 ) real ( kind = dp ) :: a , b , c , discriminant real ( kind = dp ) :: x1 , x2 , x ! Real roots of the equation real ( kind = dp ) :: x_real ! Real part of complex root of the equation REAL ( kind = dp ) :: x_complex ! Imaginary part of complex root of the equation character ( len = 256 ) :: message integer :: ios character ( len = 1 ) :: paws character ( len = 1024 ) :: buffer character ( len =* ), parameter :: numbers = '(\"<B><w><bo>   \",*(\"(\",g0.8,\",\",g0.8,\")\":,1x))' if ( system_isatty ( stdout )) then ! ISATTY() is an extension, but found in Intel, GNU, PGI, ... compiler call attr_mode ( 'color' ) else call attr_mode ( 'plain' ) endif INFINITE : do ! clear screen, set attributes and print messages call text ( \"<reset><clear>\" ) call text ( \"For the quadratic equation <m>A</m><g>*x**2 +<m>B</m><g>*x + <m>C</m> \" ) write ( * , '(*(a))' , advance = 'no' ) & & attr ( '<B><w><bo>' // repeat ( '_' , 78 ) // '  ' ), & & char ( 13 ),& & attr ( '<B><g><bo>enter coefficients <m>A,B,C</m><g>:<y><gt><ul>' ,& & reset = . false .) read ( * , * , iostat = ios , iomsg = message ) a , b , c write ( * , '(a)' , advance = 'no' ) attr ( '<reset>' ) if ( ios . ne . 0 ) then write ( * , '(*(g0))' ) ios , ' ' , trim ( message ) else ! Given the equation \"A*X**2 + B*X + C = 0\" ! Use the quadratic formula to determine the root values of the equation. ! prompt for new value call text () call text ( 'Given the equation' ) call text () write ( buffer , '(*(g0.8))' ) '<B><w><bo>   ' , a , '<m>*X**2</m><w> + ' , b , '<m>*X</m><w> + ' , c , ' = 0' call text ( buffer ) call text () discriminant = b ** 2 - 4 * a * c if ( a . eq . 0 ) then call text ( '<ERROR> <m>If <m>a</m><g> is zero this is a linear, not quadratic equation' ) elseif ( discriminant > 0 ) then call text ( 'the <m>roots</m><g> (ie. \"x intercepts\") are <m>real<m><g> so the parabola ' ) call text ( 'crosses the x-axis at <m>two points</m><g>:' ) call text () x1 = ( - b + sqrt ( discriminant )) / ( 2 * a ) x2 = ( - b - sqrt ( discriminant )) / ( 2 * a ) write ( buffer , numbers ) x1 , 0.0d0 call text ( buffer ) write ( buffer , numbers ) x2 , 0.0d0 call text ( buffer ) call text () elseif ( discriminant == 0 ) then call text ( 'the <m>roots</m><g> (ie. \"x intercepts\") are repeated <m>(real and equal)</m><g>' ) call text ( 'so the parabola just touches the x-axis at:' ) call text () if ( b . ne . 0 ) then x = ( - b ) / ( 2 * a ) else x = 0.0d0 endif write ( buffer , numbers ) x , 0.0d0 call text ( buffer ) call text () else call text ( 'the <m>roots</m><g>(ie. \"x intercepts\")  are <m>complex</m><g>:' ) x_real = ( - b ) / ( 2 * a ) x_complex = sqrt ( abs ( discriminant )) / ( 2 * a ) call text () WRITE ( buffer , '(a,*(\"(\",g0.8,\", +i\",g0.8,\")\",:,1x))' ) '<B><w><bo>   ' , x_real , x_complex call text ( buffer ) WRITE ( buffer , '(a,*(\"(\",g0.8,\", -i\",g0.8,\")\",:,1x))' ) '<B><w><bo>   ' , x_real , x_complex call text ( buffer ) call text () endif call text ( 'with' ) call text () write ( buffer , '(g0,*(g0.8,1x))' ) \"<B><w><bo>   <m>discriminate</m><w> = \" , discriminant call text ( buffer ) call text () endif write ( * , '(*(g0))' , advance = 'no' ) attr ( '<B><e>press <g>return</g><e> to continue, \"<g>q</g><e>\" to quit:' , chars = 79 ) read ( * , advance = 'yes' , iostat = ios , fmt = '(a)' , iomsg = message ) paws if ( paws . ne . '' ) exit INFINITE enddo INFINITE contains subroutine text ( string ) character ( len =* ), intent ( in ), optional :: string if ( present ( string )) then write ( * , '(*(g0))' ) attr ( '<B><g><bo>' // string , chars = 80 ) else write ( * , '(*(g0))' ) attr ( '<B><g><bo>' , chars = 80 ) endif end subroutine text !>  call compiler-specific ISATTY() function or return .FALSE. #undef ISATTY #ifdef __INTEL_COMPILER function system_isatty ( lun ) use IFPORT integer , intent ( in ) :: lun logical :: system_isatty system_isatty = isatty ( lun ) end function system_isatty #define ISATTY #endif #ifdef __NVCOMPILER_MAJOR__X ! __NVCOMPILER_MAJOR__ __NVCOMPILER_MINOR__ __NVCOMPILER_PATCHLEVEL__ function system_isatty ( lun ) use DFPORT integer , intent ( in ) :: lun logical :: system_isatty system_isatty = isatty ( lun ) end function system_isatty #define ISATTY #endif #ifdef __GFORTRAN__ function system_isatty ( lun ) integer , intent ( in ) :: lun logical :: system_isatty system_isatty = isatty ( lun ) end function system_isatty #define ISATTY #endif #ifndef ISATTY function system_isatty ( lun ) integer , intent ( in ) :: lun logical :: system_isatty system_isatty = . false . end function system_isatty #define ISATTY #endif END PROGRAM roots","tags":"","loc":"program/roots.html"},{"title":"demo_attr – M_attr","text":"Uses M_attr Contents Variables expanded ios line Source Code demo_attr Variables Type Attributes Name Initial character(len=:), allocatable :: expanded integer :: ios character(len=1024) :: line Source Code program demo_attr ! read stdin and run it through M_attr::attr to display color use M_attr , only : attr , attr_update implicit none character ( len = 1024 ) :: line character ( len = :), allocatable :: expanded integer :: ios line = '' call attr_update ( 'Z' , char ( 27 ) // '[1m' ) do read ( * , '(a)' , iostat = ios ) line expanded = attr ( trim ( line )) write ( * , '(a)' ) expanded if ( ios . ne . 0 ) exit enddo write ( * , '(a)' , advance = 'no' ) attr ( '<reset>' ) end program demo_attr","tags":"","loc":"program/demo_attr.html"},{"title":"demo_attr – M_attr","text":"Uses M_attr Contents Variables ios line Source Code demo_attr Variables Type Attributes Name Initial integer :: ios character(len=1024) :: line Source Code program demo_attr ! read stdin and run it through M_attr::attr to display without color use M_attr , only : attr , attr_mode implicit none character ( len = 1024 ) :: line integer :: ios line = '' call attr_mode ( manner = 'plain' ) do read ( * , '(a)' , iostat = ios ) line write ( * , '(a)' ) attr ( trim ( line )) if ( ios . ne . 0 ) exit enddo write ( * , '(a)' , advance = 'no' ) attr ( '<reset>' ) end program demo_attr","tags":"","loc":"program/demo_attr~2.html"},{"title":"demo_M_attr – M_attr","text":"Uses M_attr Contents Variables f line value Source Code demo_M_attr Variables Type Attributes Name Initial character(len=*), parameter :: f = '( \" GREAT: The new value \",f8.4,1x,\" is in range\")' character(len=256) :: line real :: value Source Code program demo_M_attr use M_attr , only : attr , attr_mode , attr_update implicit none character ( len = 256 ) :: line character ( len =* ), parameter :: f = '( & &\"   <bo><w><G> GREAT: </G></w>& &The new value <Y><b>\",f8.4,1x,\"</b></Y> is in range\"& &)' real :: value write ( * , '(a)' )& & attr ( '   <r><W><bo> ERROR: </W>red text on a white background</y>' ) value = 3.4567 write ( line , fmt = f ) value write ( * , '(a)' ) attr ( trim ( line )) ! write same string as plain text write ( * , * ) call attr_mode ( manner = 'plain' ) write ( * , '(a)' ) attr ( trim ( line )) call attr_mode ( manner = 'color' ) ! use pre-defined or user defined strings write ( * , * ) write ( * , '(a)' ) attr ( '<ERROR> Woe is nigh.' ) write ( * , '(a)' ) attr ( '<WARNING> The night is young.' ) write ( * , '(a)' ) attr ( '<INFO> It is Monday' ) ! create a custom mneumonic call attr_update ( 'MYERROR' , attr (& ' <R><e> E<w>-<e>R<w>-<e>R<w>-<e>O<w>-<e>R: </e></R></bo>' & )) write ( * , * ) write ( * , '(a)' ) attr ( '<MYERROR> my custom message style' ) end program demo_M_attr","tags":"","loc":"program/demo_m_attr.html"},{"title":"demo_esc – M_attr","text":"Uses M_attr Contents Subroutines printstuff Source Code demo_esc Subroutines subroutine printstuff (label) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: label Source Code program demo_esc use M_attr , only : attr , attr_mode , attr_update call printstuff ( 'defaults' ) call attr_mode ( manner = 'plain' ) call printstuff ( 'plain:' ) call printstuff ( 'raw' ) call attr_mode ( manner = 'color' ) call printstuff ( '' ) write ( * , '(a)' ) attr ( 'TEST ADDING A CUSTOM SEQUENCE:' ) call attr_update ( 'blink' , char ( 27 ) // '[5m' ) call attr_update ( '/blink' , char ( 27 ) // '[38m' ) write ( * , '(a)' ) attr ( '<blink>Items for Friday</blink>' ) contains subroutine printstuff ( label ) character ( len =* ), intent ( in ) :: label character ( len = :), allocatable :: array (:) call attr_mode ( manner = label ) array = [ character ( len = 60 ) :: & 'TEST MANNER=' // label , & '<r>RED</r>,<g>GREEN</g>,<b>BLUE</b>' , & '<c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y>' , & '<w>WHITE</w> and <e>EBONY</e>' ] write ( * , '(a)' ) attr ( array ) write ( * , '(a)' ) attr ( 'Adding <bo>bold</bo>' ) write ( * , '(a)' ) attr ( '<bo><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></bo>' ) write ( * , '(a)' ) attr ( '<bo><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y></bo>' ) write ( * , '(a)' ) attr ( '<bo><w>WHITE</w> and <e>EBONY</e></bo>' ) write ( * , '(a)' ) attr ( 'Adding <ul>underline</ul>' ) write ( * , '(a)' ) attr (& & '<bo><ul><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></ul></bo>' ) write ( * , '(a)' ) attr (& & '<bo><ul><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><w>WHITE</w> and <e>EBONY</e></ul></bo>' ) write ( * , '(a)' ) attr ( 'Adding <ul>italic</ul>' ) write ( * , '(a)' ) attr (& & '<bo><ul><it><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></it></ul></bo>' ) write ( * , '(a)' ) attr (& & '<bo><ul><it><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</it></y></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><it><w>WHITE</w> and <e>EBONY</e></ul></bo>' ) write ( * , '(a)' ) attr ( 'Adding <in>inverse</in>' ) write ( * , '(a)' ) attr (& & '<in><bo><ul><it><r>RED</r>,<g>GREEN</g>,& &<b>BLUE</b></it></ul></bo></in>' ) write ( * , '(a)' ) attr (& & '<in><bo><ul><it><c>CYAN</c>,<m>MAGENTA</g>,& &<y>YELLOW</it></y></ul></bo></in>' ) write ( * , '(a)' ) attr (& & '<in><bo><ul><it><w>WHITE</w> and <e>EBONY</e></ul></bo></in>' ) end subroutine printstuff end program demo_esc","tags":"","loc":"program/demo_esc.html"},{"title":"demo_update – M_attr","text":"Uses M_attr Contents Source Code demo_update Source Code program demo_update use M_attr , only : attr , attr_update write ( * , '(a)' ) attr ( '<clear>TEST CUSTOMIZED:' ) ! add custom keywords call attr_update ( 'blink' , char ( 27 ) // '[5m' ) call attr_update ( '/blink' , char ( 27 ) // '[38m' ) write ( * , * ) write ( * , '(a)' ) attr ( '<blink>Items for Friday</blink>' ) call attr_update ( 'ouch' , attr ( & ' <R><bo><w>BIG mistake!</R></w> ' )) write ( * , * ) write ( * , '(a)' ) attr ( '<ouch> Did not see that coming.' ) write ( * , * ) write ( * , '(a)' ) attr ( & 'ORIGINALLY: <r>Apple</r>, <b>Sky</b>, <g>Grass</g>' ) ! delete call attr_update ( 'r' ) call attr_update ( '/r' ) ! replace (or create) call attr_update ( 'b' , '<<<<' ) call attr_update ( '/b' , '>>>>' ) write ( * , * ) write ( * , '(a)' ) attr ( & 'CUSTOMIZED: <r>Apple</r>, <b>Sky</b>, <g>Grass</g>' ) end program demo_update","tags":"","loc":"program/demo_update.html"},{"title":"demo_attr_mode – M_attr","text":"Uses M_attr Contents Variables i lines outlines Source Code demo_attr_mode Variables Type Attributes Name Initial integer :: i character(len=:), allocatable :: lines (:) character(len=:), allocatable :: outlines (:) Source Code program demo_attr_mode use M_attr , only : attr , attr_mode implicit none character ( len = :), allocatable :: lines (:) character ( len = :), allocatable :: outlines (:) integer :: i lines = [ character ( len = 110 ) :: & '<B><y>' ,& '<B><y>  Suffice it to say that <W><e>black</e></W><B><y>& & and <E><w>white</w></E><B><y> are also colors' ,& '<B><y>  for their simultaneous contrast is as striking as that ' ,& '<B><y>  of <R><g>green</g></R><B><y> and <G><r>red</r></G><B><y>,& & for instance. --- <bo>Vincent van Gogh' ,& '<B><y>' ,& ' ' ] outlines = attr ( lines , chars = 57 ) write ( * , '(a)' )( trim ( outlines ( i )), i = 1 , size ( outlines )) call attr_mode ( manner = 'plain' ) ! write as plain text write ( * , '(a)' ) attr ( lines ) call attr_mode ( manner = 'raw' ) ! write as-is write ( * , '(a)' ) attr ( lines ) call attr_mode ( manner = 'ansi' ) ! return to default mode outlines = attr ( lines , chars = 80 ) write ( * , '(a)' )( trim ( outlines ( i )), i = 1 , size ( outlines )) end program demo_attr_mode","tags":"","loc":"program/demo_attr_mode.html"},{"title":"demo_M_attr – M_attr","text":"Uses M_attr Contents Source Code demo_M_attr Source Code program demo_M_attr use M_attr , only : attr , attr_update write ( * , '(a)' ) attr ( '<clear>TEST CUSTOMIZED:' ) ! add custom keywords call attr_update ( 'blink' , char ( 27 ) // '[5m' ) call attr_update ( '/blink' , char ( 27 ) // '[38m' ) write ( * , '(a)' ) attr ( '<blink>Items for Friday</blink>' ) write ( * , '(a)' , advance = 'no' ) attr ( '<r>RED</r>,' ) write ( * , '(a)' , advance = 'no' ) attr ( '<b>BLUE</b>,' ) write ( * , '(a)' , advance = 'yes' ) attr ( '<g>GREEN</g>' ) ! delete call attr_update ( 'r' ) call attr_update ( '/r' ) ! replace call attr_update ( 'b' , '<<<<' ) call attr_update ( '/b' , '>>>>' ) write ( * , '(a)' , advance = 'no' ) attr ( '<r>RED</r>,' ) write ( * , '(a)' , advance = 'no' ) attr ( '<b>BLUE</b>,' ) write ( * , '(a)' , advance = 'yes' ) attr ( '<g>GREEN</g>' ) end program demo_M_attr","tags":"","loc":"program/demo_m_attr~2.html"},{"title":"mode – M_attr","text":"Uses M_attr Contents Subroutines printme Source Code mode Subroutines subroutine printme (mymode) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: mymode Source Code program mode use M_attr , only : attr , attr_mode implicit none call printme ( 'color' ) call printme ( 'plain' ) call printme ( 'raw' ) contains subroutine printme ( mymode ) character ( len =* ), intent ( in ) :: mymode call attr_mode ( mymode ) write ( * , '(a)' ) mymode write ( * , '(a)' ) attr ( '<ERROR>Woe is nigh.' ) write ( * , '(a)' ) attr ( '<WARNING>The night is young.' ) write ( * , '(a)' ) attr ( '<INFO>It is Monday' ) end subroutine printme end program mode","tags":"","loc":"program/mode.html"},{"title":"demo_M_attrape – M_attr","text":"Uses M_attr Contents Subroutines printstuff Source Code demo_M_attrape Subroutines subroutine printstuff () Arguments None Source Code program demo_M_attrape use M_attr , only : attr , attr_mode , attr_update write ( * , '(a)' ) attr ( '<clear>TEST DEFAULTS:' ) call printstuff () write ( * , '(a)' ) attr ( 'TEST MANNER=PLAIN:' ) call attr_mode ( manner = 'plain' ) call printstuff () write ( * , '(a)' ) attr ( 'TEST MANNER=RAW:' ) call attr_mode ( manner = 'raw' ) call printstuff () write ( * , '(a)' ) attr ( 'TEST MANNER=VT102:' ) call attr_mode ( manner = 'vt102' ) call printstuff () write ( * , '(a)' ) attr ( 'TEST ADDING A CUSTOM SEQUENCE:' ) call attr_update ( 'blink' , char ( 27 ) // '[5m' ) call attr_update ( '/blink' , char ( 27 ) // '[38m' ) write ( * , '(a)' ) attr ( '<blink>Items for Friday</blink>' ) contains subroutine printstuff () write ( * , '(a)' ) attr ( '<r>RED</r>,<g>GREEN</g>,<b>BLUE</b>' ) write ( * , '(a)' ) attr ( '<c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y>' ) write ( * , '(a)' ) attr ( '<w>WHITE</w> and <e>EBONY</e>' ) write ( * , '(a)' ) attr ( 'Adding <bo>bold</bo>' ) write ( * , '(a)' ) attr ( '<bo><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></bo>' ) write ( * , '(a)' ) attr ( '<bo><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y></bo>' ) write ( * , '(a)' ) attr ( '<bo><w>WHITE</w> and <e>EBONY</e></bo>' ) write ( * , '(a)' ) attr ( 'Adding <ul>underline</ul>' ) write ( * , '(a)' ) attr ( '<bo><ul><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><w>WHITE</w> and <e>EBONY</e></ul></bo>' ) write ( * , '(a)' ) attr ( 'Adding <ul>italic</ul>' ) write ( * , '(a)' ) attr ( '<bo><ul><it><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></it></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><it><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</it></y></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><it><w>WHITE</w> and <e>EBONY</e></ul></bo>' ) write ( * , '(a)' ) attr ( 'Adding <in>inverse</in>' ) write ( * , '(a)' ) attr ( '<in><bo><ul><it><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></it></ul></bo></in>' ) write ( * , '(a)' ) attr ( '<in><bo><ul><it><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</it></y></ul></bo></in>' ) write ( * , '(a)' ) attr ( '<in><bo><ul><it><w>WHITE</w> and <e>EBONY</e></ul></bo></in>' ) end subroutine printstuff end program demo_M_attrape","tags":"","loc":"program/demo_m_attrape.html"},{"title":"demo_dump – M_attr","text":"Uses M_attr Contents Source Code demo_dump Source Code program demo_dump use M_attr , only : attr write ( * , '(a)' , advance = 'no' ) attr ( '<dump>' ) end program demo_dump","tags":"","loc":"program/demo_dump.html"},{"title":"mode – M_attr","text":"Uses M_attr Contents Subroutines printme Source Code mode Subroutines subroutine printme (mymode) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: mymode Source Code program mode use M_attr , only : attr , attr_mode implicit none call printme ( 'color' ) call printme ( 'plain' ) call printme ( 'raw' ) contains subroutine printme ( mymode ) character ( len =* ), intent ( in ) :: mymode call attr_mode ( mymode ) write ( * , '(a)' ) mymode write ( * , '(*(g0))' , advance = 'no' ) attr ( 'red:BLUE:bold' ), 'Hello!' , & & attr ( '/BLUE' ), ' Well, this is boring without a nice background color.' , attr ( 'reset' ) write ( * , '(*(g0))' , advance = 'yes' ) ' Back to a normal write statement.' end subroutine printme end program mode","tags":"","loc":"program/mode~2.html"},{"title":"demo_M_attr – M_attr","text":"Uses M_attr Contents Source Code demo_M_attr Source Code program demo_M_attr use M_attr , only : attr , attr_mode , attr_update write ( * , '(a)' ) attr ( 'TEST MANNER=DEFAULT:' ) write ( * , '(a)' ) attr ( '<r>RED</r>,<g>GREEN</g>,<b>BLUE</b>' ) write ( * , '(a)' ) attr ( '<c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y>' ) write ( * , '(a)' ) attr ( '<w>WHITE</w> and <e>EBONY</e>' ) write ( * , '(a)' ) attr ( 'Adding <bo>bold</bo>' ) write ( * , '(a)' ) attr ( '<bo><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></bo>' ) write ( * , '(a)' ) attr ( '<bo><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y></bo>' ) write ( * , '(a)' ) attr ( '<bo><w>WHITE</w> and <e>EBONY</e></bo>' ) write ( * , '(a)' ) attr ( 'Adding <ul>underline</ul>' ) write ( * , '(a)' ) attr ( '<bo><ul><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><w>WHITE</w> and <e>EBONY</e></ul></bo>' ) write ( * , '(a)' ) attr ( 'Adding <ul>italic</ul>' ) write ( * , '(a)' ) attr ( '<bo><ul><it><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></it></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><it><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</it></y></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><it><w>WHITE</w> and <e>EBONY</e></ul></bo>' ) write ( * , '(a)' ) attr ( 'Adding <in>inverse</in>' ) write ( * , '(a)' ) attr ( '<in><bo><ul><it><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></it></ul></bo></in>' ) write ( * , '(a)' ) attr ( '<in><bo><ul><it><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</it></y></ul></bo></in>' ) write ( * , '(a)' ) attr ( '<in><bo><ul><it><w>WHITE</w> and <e>EBONY</e></ul></bo></in>' ) end program demo_M_attr","tags":"","loc":"program/demo_m_attr~3.html"}]}