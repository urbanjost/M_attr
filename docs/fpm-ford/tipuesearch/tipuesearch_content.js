var tipuesearch = {"pages":[{"title":" M_attr ","text":"M_attr Developer Info John S. Urban","tags":"home","loc":"index.html"},{"title":"M_attr.f90 – M_attr","text":"Contents Modules M_attr Source Code M_attr.f90 Source Code !> !!##NAME !!    M_attr(3f) - [M_attr::INTRO] control text attributes on terminals !!    (LICENSE:MIT) !! !!##SYNOPSIS !! !! !!      use M_attr, only : attr, attr_mode, attr_update !! !!      use M_attr, only : alert ! generate standard messages !! !!##DESCRIPTION !!    M_attr(3f) is a Fortran module that uses common ANSI escape sequences !!    to control terminal text attributes. !! !!         use M_attr !!         write(*,*)attr('<red>Red Text!</red> <green>Green Text!</green>') !!         end !! !!    It is designed to use three simple procedures to !! !!     + Specify attributes using simple HTML-like syntax !!     + allow the sequences to be suppressed when desired !!     + permit the  user program to completely customize the keywords. !!       The user can add, delete and replace the sequences associated with !!       a keyword without changing the code. !! !!    One advantage of the approach of using formatting directives which !!    are replaced with in-band escape sequences is that it is easy to turn !!    off when running batch. !! !!    Another important capability is that programs can be run in \"raw\" mode !!    and create a simple text file with the formatting directives in it !!    that can then be read back in by a simple filter program that strips !!    it back to plain text( see app/plain.f90), or displays it to a screen !!    in color(see app/light.f90) or perhaps converts it to another format. !! !!    So this approach makes it trivial to read specially-formatted data !!    from a file like a message catalog (perhaps with various versions !!    in different languages) and colorize it or display it as plain text !! !!    By making each line self-contained (by default) lines can be filtered !!    by external utilities and still display correctly. !! !!##ACCESS !!    Via git(1): !! !!        git clone https://github.com/urbanjost/M_attr.git !!        cd M_attr/src !!        # change Makefile if not using one of the listed compilers !!        make clean; make gfortran    # for gfortran !!        make clean; make ifort       # for ifort !!        make clean; make nvfortran   # for nvfortran !! !!    This will compile the M_attr module and example programs. !! !!    Alternatively, via fpm ( described at https://github.com/fortran-lang/fpm): !! !!         git clone https://github.com/urbanjost/M_attr.git !! !!    or just list it as a dependency in your fpm.toml project file. !! !!         [dependencies] !!         M_attr        = { git = \"https://github.com/urbanjost/M_attr.git\" } !! !!##LIMITATIONS !!   o colors are not nestable. !!   o keywords are case-sensitive, !!   o ANSI escape sequences are not universally supported by !!     all terminal emulators; and normally should be suppressed !!     when not going to a tty device. Therefore, you should use !!     M_system::system_istty(3f) or the common Fortran extension !!     ISATTY() to set the default to \"plain\" instead of \"color\" !!     when the output file is not a conforming terminal. On basic !!     MSWindows console windows, it is best to use Windows 10+ and/or !!     the Linux mode; you may have to enable ANSI escape sequence !!     mode on MSWindows. It does work as-is with CygWin and MinGW and !!     Putty windows and mintty(1) as tested. !! !!##EXAMPLE !! !!    Sample program !! !!     program demo_M_attr !!     use M_attr, only : attr, attr_mode, attr_update, alert !!     implicit none !!     character(len=256) :: line !!     character(len=*),parameter :: f='( & !!      &\"   <bo><w><G> GREAT: </G></w>& !!      &The new value <Y><b>\",f8.4,1x,\"</b></Y> is in range\"& !!      &)' !!     real :: value !! !!        write(*,'(a)')& !!        &attr('   <r><W><bo> ERROR: </W>red text on a white background</y>') !! !!        value=3.4567 !!        write(line,fmt=f) value !!        write(*,'(a)')attr(trim(line)) !! !!        ! write same string as plain text !!        write(*,*) !!        call attr_mode(manner='plain') !!        write(*,'(a)')attr(trim(line)) !! !!        call attr_mode(manner='color') !!        ! use pre-defined or user defined strings !!        write(*,*) !!        write(*,'(a)')attr('<ERROR> Woe is nigh.') !!        write(*,'(a)')attr('<WARNING> The night is young.') !!        write(*,'(a)')attr('<INFO> It is Monday') !! !!        call alert('<ERROR>', 'Woe is nigh.') !!        call alert('<WARNING>', 'The night is young.') !!        call alert('<INFO>', 'It is Monday') !! !!        ! create a custom mnemonic !!        call attr_update('MYERROR',attr(& !!        ' <R><e> E<w>-<e>R<w>-<e>R<w>-<e>O<w>-<e>R: </e></R></bo>'& !!        )) !!        write(*,*) !!        write(*,'(a)')attr('<MYERROR> my custom message style') !! !!     end program demo_M_attr !! !!##AUTHOR !!    John S. Urban, 2021 !! !!##LICENSE !!    MIT !! !!##SEE ALSO !!    attr(3f), attr_mode(3f), attr_update(3f) !! !!    Related information: !! !!     terminfo(3c), termlib(3c), tput(1), reset(1), clear(1), !!     console_codes(4), ECMA-48, !!     https://en.wikipedia.org/wiki/ANSI_escape_code module M_attr use , intrinsic :: iso_fortran_env , only : stderr => ERROR_UNIT , stdin => INPUT_UNIT , stdout => OUTPUT_UNIT use , intrinsic :: iso_c_binding , only : c_int implicit none private public :: attr public :: attr_mode public :: attr_update public :: alert , advice private :: attr_matrix private :: attr_scalar private :: attr_scalar_width private :: get private :: locate ! find PLACE in sorted character array where value can be found or should be placed private :: insert ! insert entry into a sorted allocatable array at specified position private :: replace ! replace entry by index from a sorted allocatable array if it is present private :: remove ! delete entry by index from a sorted allocatable array if it is present private :: wipe_dictionary private :: vt102 interface attr module procedure attr_scalar module procedure attr_matrix module procedure attr_scalar_width end interface interface advice ! deprecated old name for alert(3f) module procedure alert end interface ! direct use of constant strings character ( len = :), allocatable , save :: keywords (:) character ( len = :), allocatable , save :: values (:) character ( len = :), allocatable , save :: mono_values (:) character ( len = :), allocatable , save :: mode ! mnemonics character ( len =* ), parameter :: NL = new_line ( 'a' ) ! New line character. ! DECIMAL ! *-------*-------*-------*-------*-------*-------*-------*-------* ! | 00 nul| 01 soh| 02 stx| 03 etx| 04 eot| 05 enq| 06 ack| 07 bel| ! | 08 bs | 09 ht | 10 nl | 11 vt | 12 np | 13 cr | 14 so | 15 si | ! | 16 dle| 17 dc1| 18 dc2| 19 dc3| 20 dc4| 21 nak| 22 syn| 23 etb| ! | 24 can| 25 em | 26 sub| 27 esc| 28 fs | 29 gs | 30 rs | 31 us | ! | 32 sp | 33  ! | 34  \" | 35  # | 36  $ | 37  % | 38  & | 39  ' | ! | 40  ( | 41  ) | 42  * | 43  + | 44  , | 45  - | 46  . | 47  / | ! | 48  0 | 49  1 | 50  2 | 51  3 | 52  4 | 53  5 | 54  6 | 55  7 | ! | 56  8 | 57  9 | 58  : | 59  ; | 60  < | 61  = | 62  > | 63  ? | ! | 64  @ | 65  A | 66  B | 67  C | 68  D | 69  E | 70  F | 71  G | ! | 72  H | 73  I | 74  J | 75  K | 76  L | 77  M | 78  N | 79  O | ! | 80  P | 81  Q | 82  R | 83  S | 84  T | 85  U | 86  V | 87  W | ! | 88  X | 89  Y | 90  Z | 91  [ | 92  \\ | 93  ] | 94  &#94; | 95  _ | ! | 96  ` | 97  a | 98  b | 99  c |100  d |101  e |102  f |103  g | ! |104  h |105  i |106  j |107  k |108  l |109  m |110  n |111  o | ! |112  p |113  q |114  r |115  s |116  t |117  u |118  v |119  w | ! |120  x |121  y |122  z |123  { |124  | |125  } |126  ~ |127 del| ! *-------*-------*-------*-------*-------*-------*-------*-------* character ( len =* ), parameter :: nul = achar ( 0 ) character ( len =* ), parameter :: bel = achar ( 7 ) ! &#94;G beeps; character ( len =* ), parameter :: bs = achar ( 8 ) ! &#94;H backspaces one column (but not past the beginning of the line); character ( len =* ), parameter :: ht = achar ( 9 ) ! &#94;I goes to next tab stop or to the end of the line if there is no earlier tab stop character ( len =* ), parameter :: lf = achar ( 10 ) ! &#94;J character ( len =* ), parameter :: vt = achar ( 11 ) ! &#94;K character ( len =* ), parameter :: ff = achar ( 12 ) ! &#94;L all give a linefeed, and if LF/NL (new-line mode) is set also a carriage return character ( len =* ), parameter :: cr = achar ( 13 ) ! &#94;M gives a carriage return; character ( len =* ), parameter :: so = achar ( 14 ) ! &#94;N activates the G1 character set; character ( len =* ), parameter :: si = achar ( 15 ) ! &#94;O activates the G0 character set; character ( len =* ), parameter :: can = achar ( 24 ) ! &#94;X interrupt escape sequences; character ( len =* ), parameter :: sub = achar ( 26 ) ! &#94;Z interrupt escape sequences; character ( len =* ), parameter :: esc = achar ( 27 ) ! &#94;[ starts an escape sequence; character ( len =* ), parameter :: del = achar ( 127 ) ! is ignored; ! codes character ( len =* ), parameter :: CODE_START = esc // '[' ! Start ANSI code, \"\". character ( len =* ), parameter :: CODE_END = 'm' ! End ANSI code, \"m\". character ( len =* ), parameter :: CODE_RESET = CODE_START // '0' // CODE_END ! Clear all styles, \"0m\". character ( len =* ), parameter :: CLEAR_DISPLAY = CODE_START // '2J' character ( len =* ), parameter :: HOME_DISPLAY = CODE_START // 'H' character ( len =* ), parameter :: BELL = achar ( 7 ) character ( len =* ), parameter :: AT_BOLD = '1' , AT_ITALIC = '3' , AT_UNDERLINE = '4' , AT_INVERSE = '7' character ( len =* ), parameter :: BLACK = '0' , RED = '1' , GREEN = '2' , YELLOW = '3' , BLUE = '4' , MAGENTA = '5' , CYAN = '6' , WHITE = '7' , DEFAULT = '9' !prefixes character ( len =* ), parameter :: FG = '3' character ( len =* ), parameter :: BG = '4' character ( len =* ), parameter :: FG_INTENSE = '9' character ( len =* ), parameter :: BG_INTENSE = '10' character ( len =* ), parameter :: ON = '' character ( len =* ), parameter :: OFF = '2' ! foreground colors character ( len =* ), parameter , public :: fg_red = CODE_START // FG // RED // CODE_END character ( len =* ), parameter , public :: fg_cyan = CODE_START // FG // CYAN // CODE_END character ( len =* ), parameter , public :: fg_magenta = CODE_START // FG // MAGENTA // CODE_END character ( len =* ), parameter , public :: fg_blue = CODE_START // FG // BLUE // CODE_END character ( len =* ), parameter , public :: fg_green = CODE_START // FG // GREEN // CODE_END character ( len =* ), parameter , public :: fg_yellow = CODE_START // FG // YELLOW // CODE_END character ( len =* ), parameter , public :: fg_white = CODE_START // FG // WHITE // CODE_END character ( len =* ), parameter , public :: fg_ebony = CODE_START // FG // BLACK // CODE_END character ( len =* ), parameter , public :: fg_black = CODE_START // FG // BLACK // CODE_END character ( len =* ), parameter , public :: fg_default = CODE_START // FG // DEFAULT // CODE_END ! background colors character ( len =* ), parameter , public :: bg_red = CODE_START // BG // RED // CODE_END character ( len =* ), parameter , public :: bg_cyan = CODE_START // BG // CYAN // CODE_END character ( len =* ), parameter , public :: bg_magenta = CODE_START // BG // MAGENTA // CODE_END character ( len =* ), parameter , public :: bg_blue = CODE_START // BG // BLUE // CODE_END character ( len =* ), parameter , public :: bg_green = CODE_START // BG // GREEN // CODE_END character ( len =* ), parameter , public :: bg_yellow = CODE_START // BG // YELLOW // CODE_END character ( len =* ), parameter , public :: bg_white = CODE_START // BG // WHITE // CODE_END character ( len =* ), parameter , public :: bg_ebony = CODE_START // BG // BLACK // CODE_END character ( len =* ), parameter , public :: bg_black = CODE_START // BG // BLACK // CODE_END character ( len =* ), parameter , public :: bg_default = CODE_START // BG // DEFAULT // CODE_END ! attributes character ( len =* ), parameter , public :: bold = CODE_START // ON // AT_BOLD // CODE_END character ( len =* ), parameter , public :: italic = CODE_START // ON // AT_ITALIC // CODE_END character ( len =* ), parameter , public :: inverse = CODE_START // ON // AT_INVERSE // CODE_END character ( len =* ), parameter , public :: underline = CODE_START // ON // AT_UNDERLINE // CODE_END character ( len =* ), parameter , public :: unbold = CODE_START // '22' // CODE_END character ( len =* ), parameter , public :: unitalic = CODE_START // OFF // AT_ITALIC // CODE_END character ( len =* ), parameter , public :: uninverse = CODE_START // OFF // AT_INVERSE // CODE_END character ( len =* ), parameter , public :: ununderline = CODE_START // OFF // AT_UNDERLINE // CODE_END character ( len =* ), parameter , public :: reset = CODE_RESET character ( len =* ), parameter , public :: clear = HOME_DISPLAY // CLEAR_DISPLAY !private fmt private str integer , save :: alert_unit = stdout logical , save :: alert_debug = . true . logical , save :: alert_warn = . true . logical , save :: alert_info = . true . logical , save :: alert_error = . true . logical , save :: alert_other = . true . interface str module procedure msg_scalar , msg_one end interface str contains !> !!##NAME !!    attr(3f) - [M_attr] substitute escape sequences for HTML-like syntax !!               in strings !!    (LICENSE:MIT) !! !!##SYNOPSIS !! !!      function attr(string,reset) result (expanded) !! !!        ! scalar !!        character(len=*),intent(in)  :: string !!        logical,intent(in),optional  :: reset !!        character(len=:),allocatable :: expanded !!        ! or array !!        character(len=*),intent(in)  :: string(:) !!        logical,intent(in),optional  :: reset !!        character(len=:),allocatable :: expanded(:) !!        integer,intent(in),optional  :: chars !! !!##DESCRIPTION !!    Use HTML-like syntax to add attributes to terminal output such as color !!    on devices that recognize ANSI escape sequences. !! !!##OPTIONS !!    string        input string  of form !! !!                    \"<attribute_name>string</attribute_name> ...\". !! !!                   where the current attributes are color names, !!                   bold, italic, underline, ... !! !!    reset          By default, a sequence to clear all text attributes !!                   is sent at the end of each returned line if an escape !!                   character appears in the output string. This can be !!                   turned off by setting RESET to .false. . !! !!                   Note if turning off the reset attributes may be !!                   continued across lines, but if each line is not !!                   self-contained attributes may not display properly !!                   when filtered with commands such as grep(1). !! !!    chars          For arrays, a reset will be placed after the Nth !!                   displayable column count in order to make it easier !!                   to generate consistent right borders for non-default !!                   background colors for a text block. !!##KEYWORDS !!    primary default keywords !! !!      colors: !!        r,         red,       R,  RED !!        g,         green,     G,  GREEN !!        b,         blue,      B,  BLUE !!        m,         magenta,   M,  MAGENTA !!        c,         cyan,      C,  CYAN !!        y,         yellow,    Y,  YELLOW !!        e,         ebony,     E,  EBONY !!        w,         white,     W,  WHITE !! !!      attributes: !!        it,        italic !!        bo,        bold !!        un,        underline !! !!      basic control characters: !!       nul !!       bel  (0x07, &#94;G) beeps; !!       bs   (0x08, &#94;H) backspaces one column (but not past the beginning of !!                       the line); !!       ht   (0x09, &#94;I) goes to the next tab stop or to the end of the line if !!                       there is no earlier tab stop; !!       lf   (0x0A, &#94;J), !!       vt   (0x0B, &#94;K) !!       ff   (0x0C, &#94;L) all give a linefeed, and if LF/NL (new-line mode) is !!                       set also a carriage return !!       cr   (0x0D, &#94;M) gives a carriage return; !!       so   (0x0E, &#94;N) activates the G1 character set; !!       si   (0x0F, &#94;O) activates the G0 character set; !!       can  (0x18, &#94;X) and SUB (0x1A, &#94;Z) interrupt escape sequences; !!       sub !!       esc  (0x1B, &#94;[) starts an escape sequence; !!       del  (0x7F) is ignored; !! !!      other: !!        clear !!        default !!        reset !!        gt !!        lt !!        save,DECSC     Save  current state (cursor coordinates, attributes, !!                       character sets pointed at by G0, G1). !!        restore,DECRC  Restore state most recently saved by ESC 7. !!        CSI            \"Control Sequence Introducer\"(0x9B) is equivalent to !!                       \"ESC [\". !! !!      dual-value (one for color, one for mono): !! !!        write(*,*)attr('<ERROR>an error message') !!        write(*,*)attr('<WARNING>a warning message') !!        write(*,*)attr('<INFO>an informational message') !! !!    By default, if the color mnemonics (ie. the keywords) are uppercase !!    they change the background color. If lowercase, the foreground color. !!    When preceded by a \"/\" character the attribute is returned to the default. !! !!    The \"default\" keyword is typically used explicitly when !!    reset=.false, and sets all text attributes to their initial defaults. !! !!##LIMITATIONS !!    o colors are not nestable, keywords are case-sensitive, !!    o not all terminals obey the sequences. On Windows, it is best if !!      you use Windows 10+ and/or the Linux mode; although it has worked !!      with all CygWin and MinGW and Putty windows and mintty. !!    o you should use \"<gt>\" and \"<lt>\" instead of \">\" and \"<\" in a string !!      processed by attr(3f) instead of in any plain text output so that !!      the raw mode will create correct input for the attr(3f) function !!      if read back in. !! !!##EXAMPLE !! !!    Sample program !! !!     program demo_attr !!     use M_attr, only : attr, attr_mode, attr_update !!        call printstuff('defaults') !! !!        call attr_mode(manner='plain') !!        call printstuff('plain:') !! !!        call printstuff('raw') !! !!        call attr_mode(manner='color') !!        call printstuff('') !! !!        write(*,'(a)') attr('TEST ADDING A CUSTOM SEQUENCE:') !!        call attr_update('blink',char(27)//'[5m') !!        call attr_update('/blink',char(27)//'[25m') !!        write(*,'(a)') attr('<blink>Items for Friday</blink>') !! !!     contains !!     subroutine printstuff(label) !!     character(len=*),intent(in)  :: label !!     character(len=:),allocatable :: array(:) !!       call attr_mode(manner=label) !! !!       array=[character(len=60) ::    & !!        'TEST MANNER='//label,                      & !!        '<r>RED</r>,<g>GREEN</g>,<b>BLUE</b>',      & !!        '<c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y>', & !!        '<w>WHITE</w> and <e>EBONY</e>'] !!       write(*,'(a)') attr(array) !! !!       write(*,'(a)') attr('Adding <bo>bold</bo>') !!       write(*,'(a)') attr('<bo><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></bo>') !!       write(*,'(a)') attr('<bo><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y></bo>') !!       write(*,'(a)') attr('<bo><w>WHITE</w> and <e>EBONY</e></bo>') !! !!       write(*,'(a)') attr('Adding <ul>underline</ul>') !!       write(*,'(a)') attr(& !!        &'<bo><ul><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></ul></bo>') !!       write(*,'(a)') attr(& !!        &'<bo><ul><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y></ul></bo>') !!       write(*,'(a)') attr('<bo><ul><w>WHITE</w> and <e>EBONY</e></ul></bo>') !! !!       write(*,'(a)') attr('Adding <ul>italic</ul>') !!       write(*,'(a)') attr(& !!        &'<bo><ul><it><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></it></ul></bo>') !!       write(*,'(a)') attr(& !!        &'<bo><ul><it><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</it></y></ul></bo>') !!       write(*,'(a)') attr('<bo><ul><it><w>WHITE</w> and <e>EBONY</e></ul></bo>') !! !!       write(*,'(a)') attr('Adding <in>inverse</in>') !!       write(*,'(a)') attr('<in><bo><ul><it><r>RED</r>,<g>GREEN</g>,& !!        &<b>BLUE</b></it></ul></bo></in>') !!       write(*,'(a)') attr('<in><bo><ul><it><c>CYAN</c>,<m>MAGENTA</g>,& !!        &<y>YELLOW</it></y></ul></bo></in>') !!       write(*,'(a)') attr(& !!        &'<in><bo><ul><it><w>WHITE</w> and <e>EBONY</e></ul></bo></in>') !!     end subroutine printstuff !!     end program demo_attr !! !!##AUTHOR !!    John S. Urban, 2021 !! !!##LICENSE !!    MIT !! !!##SEE ALSO !!    attr_mode(3f), attr_update(3f) function attr_scalar ( string , reset ) result ( expanded ) character ( len =* ), intent ( in ) :: string logical , intent ( in ), optional :: reset logical :: clear_at_end character ( len = :), allocatable :: padded character ( len = :), allocatable :: expanded character ( len = :), allocatable :: name integer :: i integer :: ii integer :: maxlen integer :: place if ( present ( reset )) then clear_at_end = reset else clear_at_end = . true . endif if (. not . allocated ( mode )) then ! set substitution mode mode = 'color' ! 'color'|'raw'|'plain' call vt102 () endif if ( mode == 'raw' ) then expanded = string return endif maxlen = len ( string ) padded = string // ' ' i = 1 expanded = '' do select case ( padded ( i : i )) case ( '>' ) ! should not get here unless unmatched i = i + 1 expanded = expanded // '>' case ( '<' ) ! assuming not nested for now ii = index ( padded ( i + 1 :), '>' ) if ( ii . eq . 0 ) then expanded = expanded // '<' i = i + 1 else name = padded ( i + 1 : i + ii - 1 ) name = trim ( adjustl ( name )) call locate ( keywords , name , place ) if ( mode . eq . 'plain' ) then expanded = expanded // get ( name ) elseif ( place . le . 0 ) then ! unknown name; print what you found expanded = expanded // padded ( i : i + ii ) maxlen = maxlen - ii - 1 else expanded = expanded // get ( name ) endif i = ii + i + 1 endif case default expanded = expanded // padded ( i : i ) i = i + 1 end select if ( i >= maxlen + 1 ) exit enddo if ( ( index ( expanded , esc ). ne . 0 ). and .( clear_at_end )) then if (( mode . ne . 'raw' ). and .( mode . ne . 'plain' )) then expanded = expanded // CODE_RESET ! Clear all styles endif endif expanded = expanded end function attr_scalar function attr_matrix ( strings , reset , chars ) result ( expanded ) character ( len =* ), intent ( in ) :: strings (:) logical , intent ( in ), optional :: reset integer , intent ( in ), optional :: chars character ( len = :), allocatable :: expanded (:) ! gfortran does not return allocatable array from a function properly, but works with subroutine call kludge_bug ( strings , reset , chars , expanded ) end function attr_matrix subroutine kludge_bug ( strings , reset , chars , expanded ) character ( len =* ), intent ( in ) :: strings (:) logical , intent ( in ), optional :: reset integer , intent ( in ), optional :: chars character ( len = :), allocatable :: expanded (:) integer :: width character ( len = :), allocatable :: hold integer :: i integer :: right integer :: len_local allocate ( character ( len = 0 ) :: expanded ( 0 )) if ( present ( chars )) then right = chars else right = len ( strings ) endif if (. not . allocated ( mode )) then ! set substitution mode mode = 'color' ! 'color'|'raw'|'plain' call vt102 () endif do i = 1 , size ( strings ) if ( mode . eq . 'color' ) then mode = 'plain' len_local = len ( attr_scalar ( strings ( i ))) hold = trim ( strings ( i )) // repeat ( ' ' , max ( 0 , right - len_local )) mode = 'color' else hold = strings ( i ) endif hold = trim ( attr_scalar ( hold , reset = reset )) width = max ( len ( hold ), len ( expanded )) expanded = [ character ( len = width ) :: expanded , hold ] enddo end subroutine kludge_bug function attr_scalar_width ( string , reset , chars ) result ( expanded ) character ( len =* ), intent ( in ) :: string logical , intent ( in ), optional :: reset integer , intent ( in ) :: chars character ( len = :), allocatable :: expanded_arr (:) character ( len = :), allocatable :: expanded expanded_arr = attr_matrix ([ string ], reset , chars ) expanded = expanded_arr ( 1 ) end function attr_scalar_width subroutine vt102 () ! create a dictionary with character keywords, values, and value lengths ! using the routines for maintaining a list call wipe_dictionary () ! insert and replace entries call attr_update ( 'bold' , bold ) call attr_update ( '/bold' , unbold ) call attr_update ( 'bo' , bold ) call attr_update ( '/bo' , unbold ) call attr_update ( 'italic' , italic ) call attr_update ( '/italic' , unitalic ) call attr_update ( 'it' , italic ) call attr_update ( '/it' , unitalic ) call attr_update ( 'inverse' , inverse ) call attr_update ( '/inverse' , uninverse ) call attr_update ( 'in' , inverse ) call attr_update ( '/in' , uninverse ) call attr_update ( 'underline' , underline ) call attr_update ( '/underline' , ununderline ) call attr_update ( 'un' , underline ) call attr_update ( '/un' , ununderline ) call attr_update ( 'ul' , underline ) call attr_update ( '/ul' , ununderline ) call attr_update ( 'bell' , BELL ) call attr_update ( 'nul' , nul ) call attr_update ( 'bel' , bel ) call attr_update ( 'bs' , bs ) call attr_update ( 'ht' , ht ) call attr_update ( 'lf' , lf ) call attr_update ( 'vt' , vt ) call attr_update ( 'ff' , ff ) call attr_update ( 'cr' , cr ) call attr_update ( 'so' , so ) call attr_update ( 'si' , si ) call attr_update ( 'can' , can ) call attr_update ( 'sub' , sub ) call attr_update ( 'esc' , esc ) call attr_update ( 'escape' , esc ) call attr_update ( 'del' , del ) call attr_update ( 'save' , esc // '7' ) call attr_update ( 'DECSC' , esc // '7' ) call attr_update ( 'restore' , esc // '8' ) call attr_update ( 'DECRC' , esc // '8' ) call attr_update ( 'CSI' , esc // '[' ) call attr_update ( 'clear' , clear ) call attr_update ( 'reset' , reset ) call attr_update ( 'gt' , '>' , '>' ) call attr_update ( 'lt' , '<' , '<' ) ! foreground colors call attr_update ( 'r' , fg_red ) call attr_update ( '/r' , fg_default ) call attr_update ( 'red' , fg_red ) call attr_update ( '/red' , fg_default ) call attr_update ( 'c' , fg_cyan ) call attr_update ( '/c' , fg_default ) call attr_update ( 'cyan' , fg_cyan ) call attr_update ( '/cyan' , fg_default ) call attr_update ( 'm' , fg_magenta ) call attr_update ( '/m' , fg_default ) call attr_update ( 'magenta' , fg_magenta ) call attr_update ( '/magenta' , fg_default ) call attr_update ( 'b' , fg_blue ) call attr_update ( '/b' , fg_default ) call attr_update ( 'blue' , fg_blue ) call attr_update ( '/blue' , fg_default ) call attr_update ( 'g' , fg_green ) call attr_update ( '/g' , fg_default ) call attr_update ( 'green' , fg_green ) call attr_update ( '/green' , fg_default ) call attr_update ( 'y' , fg_yellow ) call attr_update ( '/y' , fg_default ) call attr_update ( 'yellow' , fg_yellow ) call attr_update ( '/yellow' , fg_default ) call attr_update ( 'w' , fg_white ) call attr_update ( '/w' , fg_default ) call attr_update ( 'white' , fg_white ) call attr_update ( '/white' , fg_default ) call attr_update ( 'e' , fg_ebony ) call attr_update ( '/e' , fg_default ) call attr_update ( 'ebony' , fg_ebony ) call attr_update ( '/ebony' , fg_default ) call attr_update ( 'x' , fg_ebony ) call attr_update ( '/x' , fg_default ) call attr_update ( 'black' , fg_ebony ) call attr_update ( '/black' , fg_default ) ! background colors call attr_update ( 'R' , bg_red ) call attr_update ( '/R' , bg_default ) call attr_update ( 'RED' , bg_red ) call attr_update ( '/RED' , bg_default ) call attr_update ( 'C' , bg_cyan ) call attr_update ( '/C' , bg_default ) call attr_update ( 'CYAN' , bg_cyan ) call attr_update ( '/CYAN' , bg_default ) call attr_update ( 'M' , bg_magenta ) call attr_update ( '/M' , bg_default ) call attr_update ( 'MAGENTA' , bg_magenta ) call attr_update ( '/MAGENTA' , bg_default ) call attr_update ( 'B' , bg_blue ) call attr_update ( '/B' , bg_default ) call attr_update ( 'BLUE' , bg_blue ) call attr_update ( '/BLUE' , bg_default ) call attr_update ( 'G' , bg_green ) call attr_update ( '/G' , bg_default ) call attr_update ( 'GREEN' , bg_green ) call attr_update ( '/GREEN' , bg_default ) call attr_update ( 'Y' , bg_yellow ) call attr_update ( '/Y' , bg_default ) call attr_update ( 'YELLOW' , bg_yellow ) call attr_update ( '/YELLOW' , bg_default ) call attr_update ( 'W' , bg_white ) call attr_update ( '/W' , bg_default ) call attr_update ( 'WHITE' , bg_white ) call attr_update ( '/WHITE' , bg_default ) call attr_update ( 'E' , bg_ebony ) call attr_update ( '/E' , bg_default ) call attr_update ( 'EBONY' , bg_ebony ) call attr_update ( '/EBONY' , bg_default ) call attr_update ( 'X' , bg_ebony ) call attr_update ( '/X' , bg_default ) call attr_update ( 'BLACK' , bg_ebony ) call attr_update ( '/BLACK' , bg_default ) ! compound call attr_update ( 'ERROR' , fg_red // bold // bg_ebony // ':error:  ' // bg_default // fg_default , ':error:' ) call attr_update ( 'WARNING' , fg_yellow // bold // bg_ebony // ':warning:' // bg_default // fg_default , ':warning:' ) call attr_update ( 'INFO' , fg_green // bold // bg_ebony // ':info:   ' // bg_default // fg_default , ':info:' ) end subroutine vt102 !> !! !> !!##NAME !!    attr_mode(3f) - [M_attr] select processing mode for output from attr(3f) !!    (LICENSE:MIT) !! !!##SYNOPSIS !! !!     subroutine attr_mode(manner) !! !!        character(len=*),intent(in) :: manner !! !!##DESCRIPTION !!    Turn off the generation of strings associated with the HTML keywords !!    in the string generated by the attr(3f) function, or display the !!    text in raw mode as it was passed to attr(3f) or return to ANSI !!    escape control sequence generation. !! !!##OPTIONS !!    MANNER  The current manners or modes supported via the attr_mode(3f) !!             procedure are !! !!         plain          suppress the output associated with keywords !!         color(default) commonly supported escape sequences !!         raw            echo the input to attr(3f) as its output !!         reload         restore original keyword meanings deleted or !!                        replaced by calls to attr_update(3f). !! !!##EXAMPLE !! !!    Sample program !! !!     program demo_attr_mode !!     use M_attr, only : attr, attr_mode !!     implicit none !!     character(len=:),allocatable :: lines(:) !!     character(len=:),allocatable :: outlines(:) !!     integer :: i !!        lines=[character(len=110):: & !!        &'<M><y>',& !!        &'<M><y>  Suffice it to say that black and white are also colors',& !!        &'<M><y>  for their simultaneous contrast is as striking as that ',& !!        &'<M><y>  of green and red, for instance. & !!        & --- <y><bo>Vincent van Gogh</bo></y>',& !!        &' '] !! !!        outlines=attr(lines,chars=57) !!        write(*,'(a)')(trim(outlines(i)),i=1,size(outlines)) !! !!        call attr_mode(manner='plain') ! write as plain text !!        write(*,'(a)')attr(lines) !! !!        call attr_mode(manner='raw')   ! write as-is !!        write(*,'(a)')attr(lines) !! !!        call attr_mode(manner='ansi')  ! return to default mode !! !!     end program demo_attr_mode !! !!##AUTHOR !!    John S. Urban, 2021 !! !!##LICENSE !!    MIT subroutine attr_mode ( manner ) character ( len =* ), intent ( in ) :: manner integer :: i if (. not . allocated ( mode )) then ! set substitution mode mode = 'color' call vt102 () endif select case ( manner ) case ( 'vt102' , 'ANSI' , 'ansi' , 'color' , 'COLOR' ) mode = 'color' case ( 'reload' , 'default' , 'defaults' , '' ) call vt102 () mode = 'color' case ( 'raw' ) mode = 'raw' case ( 'dump' ) ! dump dictionary for debugging if ( allocated ( keywords )) then if ( size ( keywords ). gt . 0 ) then write ( stderr , '(*(a,t30,a))' ) 'KEYWORD' , 'VALUE' write ( stderr , '(*(a,t30,2(\"[\",a,\"]\"),/))' )( trim ( keywords ( i )), values ( i ), mono_values ( i ), i = 1 , size ( keywords )) endif endif case ( 'dummy' , 'plain' , 'text' ) mode = 'plain' case default write ( * , * ) 'unknown manner. Try color|raw|plain' mode = 'color' end select end subroutine attr_mode subroutine wipe_dictionary () if ( allocated ( keywords )) deallocate ( keywords ) allocate ( character ( len = 0 ) :: keywords ( 0 )) if ( allocated ( values )) deallocate ( values ) allocate ( character ( len = 0 ) :: values ( 0 )) if ( allocated ( mono_values )) deallocate ( mono_values ) allocate ( character ( len = 0 ) :: mono_values ( 0 )) end subroutine wipe_dictionary !> !! !> !!##NAME !!    attr_update(3f) - [M_attr] update internal dictionary given keyword and value !!    (LICENSE:MIT) !! !!##SYNOPSIS !! !!    subroutine attr_update(key,val) !! !!     character(len=*),intent(in)           :: key !!     character(len=*),intent(in),optional  :: val !!     character(len=*),intent(in),optional  :: mono_val !! !!##DESCRIPTION !!    Update internal dictionary in M_attr(3fm) module. !! !!##OPTIONS !!    key       name of keyword to add, replace, or delete from dictionary !!    val       if present add or replace value associated with keyword. If !!              not present remove keyword entry from dictionary. !!    mono_val  if present add or replace second value associated with !!              keyword used for plain text mode. !!              Must only be specified if VAL is also specified. !! !!##KEYWORDS !!    The following keywords are defined by default !! !!    colors: !! !!      r,red     c,cyan     w,white !!      g,green   m,magenta  e,ebony !!      b,blue    y,yellow !! !!    If the color keywords are capitalized they control the text background !!    instead of the text color. !! !!    attributes: !! !!      ul,underline !!      it,italics (often produces inverse colors on many devices !! !!##EXAMPLE !! !!    Sample program !! !!      program demo_update !!      use M_attr, only : attr, attr_update !!         write(*,'(a)') attr('<clear>TEST CUSTOMIZATIONS:') !!         ! add custom keywords !!         call attr_update('blink',char(27)//'[5m') !!         call attr_update('/blink',char(27)//'[25m') !!         write(*,*) !!         write(*,'(a)') attr('<blink>Items for Friday</blink>') !!         call attr_update('ouch',attr( & !!         ' <R><bo><w>BIG mistake!</R></w> ')) !!         write(*,*) !!         write(*,'(a)') attr('<ouch> Did not see that coming.') !!         write(*,*) !!         write(*,'(a)') attr( & !!         'ORIGINALLY: <r>Apple</r>, <b>Sky</b>, <g>Grass</g>') !!         ! delete !!         call attr_update('r') !!         call attr_update('/r') !!         ! replace (or create) !!         call attr_update('b','<<<<') !!         call attr_update('/b','>>>>') !!         write(*,*) !!         write(*,'(a)') attr( & !!         'CUSTOMIZED: <r>Apple</r>, <b>Sky</b>, <g>Grass</g>') !!      end program demo_update !! !!##AUTHOR !!    John S. Urban, 2021 !! !!##LICENSE !!    MIT subroutine attr_update ( key , valin , mono_valin ) character ( len =* ), intent ( in ) :: key character ( len =* ), intent ( in ), optional :: valin character ( len =* ), intent ( in ), optional :: mono_valin integer :: place character ( len = :), allocatable :: val character ( len = :), allocatable :: mono_val if (. not . allocated ( mode )) then ! set substitution mode mode = 'color' ! 'color'|'raw'|'plain' call vt102 () endif if ( present ( mono_valin )) then mono_val = mono_valin else mono_val = '' endif if ( present ( valin )) then val = valin ! find where string is or should be call locate ( keywords , key , place ) ! if string was not found insert it if ( place . lt . 1 ) then call insert ( keywords , key , iabs ( place )) call insert ( values , val , iabs ( place )) call insert ( mono_values , mono_val , iabs ( place )) else call replace ( values , val , place ) call replace ( mono_values , mono_val , place ) endif else call locate ( keywords , key , place ) if ( place . gt . 0 ) then call remove ( keywords , place ) call remove ( values , place ) call remove ( mono_values , place ) endif endif end subroutine attr_update function get ( key ) result ( valout ) character ( len =* ), intent ( in ) :: key character ( len = :), allocatable :: valout integer :: place ! find where string is or should be call locate ( keywords , key , place ) if ( place . lt . 1 ) then valout = '' else if ( mode . eq . 'plain' ) then valout = trim ( mono_values ( place )) else valout = trim ( values ( place )) endif endif end function get subroutine locate ( list , value , place , ier , errmsg ) character ( len =* ), intent ( in ) :: value integer , intent ( out ) :: place character ( len = :), allocatable :: list (:) integer , intent ( out ), optional :: ier character ( len =* ), intent ( out ), optional :: errmsg integer :: i character ( len = :), allocatable :: message integer :: arraysize integer :: maxtry integer :: imin , imax integer :: error if (. not . allocated ( list )) then list = [ character ( len = max ( len_trim ( value ), 2 )) :: ] endif arraysize = size ( list ) error = 0 if ( arraysize . eq . 0 ) then maxtry = 0 place =- 1 else maxtry = int ( log ( float ( arraysize )) / log ( 2.0 ) + 1.0 ) place = ( arraysize + 1 ) / 2 endif imin = 1 imax = arraysize message = '' LOOP : block do i = 1 , maxtry if ( value . eq . list ( PLACE )) then exit LOOP else if ( value . gt . list ( place )) then imax = place - 1 else imin = place + 1 endif if ( imin . gt . imax ) then place =- imin if ( iabs ( place ). gt . arraysize ) then ! ran off end of list. Where new value should go or an unsorted input array' exit LOOP endif exit LOOP endif place = ( imax + imin ) / 2 if ( place . gt . arraysize . or . place . le . 0 ) then message = '*locate* error: search is out of bounds of list. Probably an unsorted input array' error =- 1 exit LOOP endif enddo message = '*locate* exceeded allowed tries. Probably an unsorted input array' endblock LOOP if ( present ( ier )) then ier = error else if ( error . ne . 0 ) then write ( stderr , * ) message // ' VALUE=' , trim ( value ) // ' PLACE=' , place stop 1 endif if ( present ( errmsg )) then errmsg = message endif end subroutine locate subroutine remove ( list , place ) character ( len = :), allocatable :: list (:) integer , intent ( in ) :: place integer :: ii , end if (. not . allocated ( list )) then list = [ character ( len = 2 ) :: ] endif ii = len ( list ) end = size ( list ) if ( place . le . 0. or . place . gt . end ) then ! index out of bounds of array elseif ( place . eq . end ) then ! remove from array list = [ character ( len = ii ) :: list (: place - 1 ) ] else list = [ character ( len = ii ) :: list (: place - 1 ), list ( place + 1 :) ] endif end subroutine remove subroutine replace ( list , value , place ) character ( len =* ), intent ( in ) :: value character ( len = :), allocatable :: list (:) character ( len = :), allocatable :: kludge (:) integer , intent ( in ) :: place integer :: ii integer :: tlen integer :: end if (. not . allocated ( list )) then list = [ character ( len = max ( len_trim ( value ), 2 )) :: ] endif tlen = len_trim ( value ) end = size ( list ) if ( place . lt . 0. or . place . gt . end ) then write ( stderr , * ) '*replace* error: index out of range. end=' , end , ' index=' , place elseif ( len_trim ( value ). le . len ( list )) then list ( place ) = value else ! increase length of variable ii = max ( tlen , len ( list )) kludge = [ character ( len = ii ) :: list ] list = kludge list ( place ) = value endif end subroutine replace subroutine insert ( list , value , place ) character ( len =* ), intent ( in ) :: value character ( len = :), allocatable :: list (:) character ( len = :), allocatable :: kludge (:) integer , intent ( in ) :: place integer :: ii integer :: end if (. not . allocated ( list )) then list = [ character ( len = max ( len_trim ( value ), 2 )) :: ] endif ii = max ( len_trim ( value ), len ( list ), 2 ) end = size ( list ) if ( end . eq . 0 ) then ! empty array list = [ character ( len = ii ) :: value ] elseif ( place . eq . 1 ) then ! put in front of array kludge = [ character ( len = ii ) :: value , list ] list = kludge elseif ( place . gt . end ) then ! put at end of array kludge = [ character ( len = ii ) :: list , value ] list = kludge elseif ( place . ge . 2. and . place . le . end ) then ! put in middle of array kludge = [ character ( len = ii ) :: list (: place - 1 ), value , list ( place :) ] list = kludge else ! index out of range write ( stderr , * ) '*insert* error: index out of range. end=' , end , ' index=' , place , ' value=' , value endif end subroutine insert !> !! !> !!##NAME !!    alert(3f) - [M_attr] print messages using a standard format including time and program name !!    (LICENSE:MIT) !! !!##SYNOPSIS !! !!     subroutine alert(message,g0,g1,g2,g3,g4,g5,g6,g7,g8,g9,ga,gb,gc,gd,ge,gf,gg,gh,gi,gj) !! !!        character(len=*),intent(in),optional :: type !!        character(len=*),intent(in),optional :: message !!        class(*),intent(in),optional :: g0,g1,g2,g3,g4,g5,g6,g7,g8,g9, & !!                                      & ga,gb,gc,gd,ge,gf,gg,gh,gi,gj !! !!##DESCRIPTION !!    Display a message prefixed with a timestamp and the name !!    of the calling program when the TYPE is specified as any !!    of 'error','warn', or 'info'. !! !!    It also allows the keywords !!    <ARG0>,<TZ>,<YE>,<MO>,<DA>,<HR>,<MI>,<SE>,<MS> to be used in the !!    message (which is passed to ATTR(3f)). !! !!    Note that time stamp keywords will only be updated when using ALERT(3f) !!    and will only be displayed in color mode! !! !!##OPTIONS !!    TYPE     if present and one of 'warn','message','info', or 'debug'  a predefined !!             message is written to stderr of the form !! !!              : <HR>:<MI>:<SE>.<MS> : (<ARG0>) : TYPE -> message !! !!    MESSAGE  the user-supplied message to display via a call to ATTR(3f) !! !!    g[0-9a-j]   optional values to print after the message. May !!                be of type INTEGER, LOGICAL, REAL, DOUBLEPRECISION, !!                COMPLEX, or CHARACTER. !! !!    if no parameters are supplied the macros are updated but no output is generated. !! !!##EXAMPLE !! !!    Sample program !! !!       program demo_alert !!       use M_attr, only : alert, attr, attr_mode !!       implicit none !!       real X !!          call attr_mode(manner='plain') !!          call attr_mode(manner='color') !!          call alert(\"error\", \"Say you didn't!\") !!          call alert(\"warn\",  \"I wouldn't if I were you, Will Robinson.\") !!          call alert(\"info\",  \"I fixed that for you, but it was a bad idea.\") !!          call alert(\"debug\", \"Who knows what is happening now?.\") !!          call alert(\"???    \",  \"not today you don't\") !!          ! call to just update the macros !!          call alert() !!          ! conventional call to ATTR(3f) using the ALERT(3f)-defined macros !!          write(*,*)attr('<bo>The year was <g><YE></g>, the month was <g><MO></g>') !!          ! optional arguments !!          X=211.3 !!          call alert('error','allowed range of X is 0 <lt> X <lt> 100, X=<r>',X) !!          ! up to twenty values are allowed of intrinsic type !!          call alert('info','values are<g>',10,234.567,cmplx(11.0,22.0),123.456d0,'</g>today') !!       end program demo_alert !! !!   Results: !! !!     00:38:30.566 : (demo_alert) : error    -> Say you didn't! !!     00:38:30.567 : (demo_alert) : warning  -> I wouldn't if I were you, Will Robinson. !!     00:38:30.567 : (demo_alert) : info     -> I fixed that for you, but it was a bad idea. !!     00:38:30.567 : (demo_alert) : debug    -> Who knows what is happening now?. !!     00:38:30.567 : (demo_alert) : ???      -> not today you don't !!     00:38:30.567 : (demo_alert) : error    -> allowed range of X is 0  X  100, X= 211.300003 !!     00:38:30.567 : (demo_alert) : info     -> values are 10 234.567001 (11.0000000,22.0000000) 123.45600000000000 today !! !! !! !!##AUTHOR !!    John S. Urban, 2021 !! !!##LICENSE !!    MIT subroutine alert ( type , message , g0 , g1 , g2 , g3 , g4 , g5 , g6 , g7 , g8 , g9 , ga , gb , gc , gd , ge , gf , gg , gh , gi , gj ) ! TODO: could add a warning level to ignore info, or info|warning, or all implicit none character ( len =* ), intent ( in ), optional :: type character ( len =* ), intent ( in ), optional :: message class ( * ), intent ( in ), optional :: g0 , g1 , g2 , g3 , g4 , g5 , g6 , g7 , g8 , g9 class ( * ), intent ( in ), optional :: ga , gb , gc , gd , ge , gf , gg , gh , gi , gj character ( len = 8 ) :: dt character ( len = 10 ) :: tm character ( len = 5 ) :: zone integer , dimension ( 8 ) :: values character ( len = 4096 ) :: arg0 character ( len = :), allocatable :: new_message character ( len = :), allocatable :: other logical :: printme call date_and_time ( dt , tm , zone , values ) call attr_update ( 'YE' , dt ( 1 : 4 ), dt ( 1 : 4 )) call attr_update ( 'MO' , dt ( 5 : 6 ), dt ( 5 : 6 )) call attr_update ( 'DA' , dt ( 7 : 8 ), dt ( 7 : 8 )) call attr_update ( 'HR' , tm ( 1 : 2 ), tm ( 1 : 2 )) call attr_update ( 'MI' , tm ( 3 : 4 ), tm ( 3 : 4 )) call attr_update ( 'SE' , tm ( 5 : 6 ), tm ( 5 : 6 )) call attr_update ( 'MS' , tm ( 8 : 10 ), tm ( 8 : 10 )) call attr_update ( 'TZ' , zone , zone ) call get_command_argument ( 0 , arg0 ) if ( index ( arg0 , '/' ). ne . 0 ) arg0 = arg0 ( index ( arg0 , '/' , back = . true .) + 1 :) if ( index ( arg0 , '\\').ne.0) arg0=arg0(index(arg0,' \\ ',back=.true.)+1:) call attr_update(' ARG0 ',arg0,arg0) printme=.true. if(present(type))then new_message= ' < b > '//tm(1:2)//' : '//tm(3:4)//' : '//tm(5:6)//' . '//tm(8:10)//' </ b > : ( '//trim(arg0)//' ) : ' other=message//' '//str(g0,g1,g2,g3,g4,g5,g6,g7,g8,g9,ga,gb,gc,gd,ge,gf,gg,gh,gi,gj) select case(type) case(' warn ',' WARN ',' warning ',' WARNING ') new_message= new_message//' < EBONY >< bo >< y > warning </ y ></ EBONY > -< gt > ' printme=alert_warn case(' info ',' INFO ',' information ',' INFORMATION ') new_message= new_message//' < EBONY >< bo >< g > info </ g ></ EBONY > -< gt > ' printme=alert_info case(' error ',' ERROR ') new_message= new_message//' < EBONY >< bo >< r > error </ r ></ EBONY > -< gt > ' printme=alert_error case(' debug ',' DEBUG ') new_message= new_message//' < EBONY >< white >< bo > debug </ white ></ EBONY > -< gt > ' printme=alert_debug case default new_message= new_message//' < EBONY >< bo >< c > '//type//' </ c ></ EBONY > -< gt > ' printme=alert_other end select if(printme)then write(alert_unit,' ( a ) ')attr(trim(new_message//other)) endif elseif(present(message))then write(alert_unit,' ( a ) ')attr(trim(other)) endif end subroutine alert !> !!##NAME !!    str(3f) - [M_attr] converts any standard scalar type to a string !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!    Syntax: !! !!      function str(g0,g1,g2,g3,g4,g5,g6,g7,g8,g9,& !!      & ga,gb,gc,gd,ge,gf,gg,gh,gi,gj,sep) !!      class(*),intent(in),optional  :: g0,g1,g2,g3,g4,g5,g6,g7,g8,g9 !!      class(*),intent(in),optional  :: ga,gb,gc,gd,ge,gf,gg,gh,gi,gj !!      character(len=*),intent(in),optional :: sep !!      character,len=(:),allocatable :: str !! !!##DESCRIPTION !!    str(3f) builds a space-separated string from up to twenty scalar values. !! !!##OPTIONS !!    g[0-9a-j]   optional value to print the value of after the message. May !!                be of type INTEGER, LOGICAL, REAL, DOUBLEPRECISION, !!                COMPLEX, or CHARACTER. !! !!                Optionally, all the generic values can be !!                single-dimensioned arrays. Currently, mixing scalar !!                arguments and array arguments is not supported. !! !!    sep         separator string used between values. Defaults to a space. !! !!##RETURNS !!    str     description to print !! !!##EXAMPLES !! !!   Sample program: !! !!    program demo_msg !!    use M_attr, only : alert !!    end program demo_msg !! !!   Output !! !! !!##AUTHOR !!    John S. Urban !! !!##LICENSE !!    Public Domain function msg_scalar(generic0, generic1, generic2, generic3, generic4, generic5, generic6, generic7, generic8, generic9, & & generica, genericb, genericc, genericd, generice, genericf, genericg, generich, generici, genericj, & & sep) implicit none ! ident_1=\"@(#)M_attr::msg_scalar(3fp): writes a message to a string composed of any standard scalar types\" class(*),intent(in),optional  :: generic0, generic1, generic2, generic3, generic4 class(*),intent(in),optional  :: generic5, generic6, generic7, generic8, generic9 class(*),intent(in),optional  :: generica, genericb, genericc, genericd, generice class(*),intent(in),optional  :: genericf, genericg, generich, generici, genericj character(len=:),allocatable  :: msg_scalar character(len=4096)           :: line integer                       :: istart integer                       :: increment character(len=*),intent(in),optional :: sep character(len=:),allocatable  :: sep_local if(present(sep))then increment=len(sep)+1 sep_local=sep else increment=2 sep_local=' ' endif istart=1 line='' if(present(generic0))call print_generic(generic0) if(present(generic1))call print_generic(generic1) if(present(generic2))call print_generic(generic2) if(present(generic3))call print_generic(generic3) if(present(generic4))call print_generic(generic4) if(present(generic5))call print_generic(generic5) if(present(generic6))call print_generic(generic6) if(present(generic7))call print_generic(generic7) if(present(generic8))call print_generic(generic8) if(present(generic9))call print_generic(generic9) if(present(generica))call print_generic(generica) if(present(genericb))call print_generic(genericb) if(present(genericc))call print_generic(genericc) if(present(genericd))call print_generic(genericd) if(present(generice))call print_generic(generice) if(present(genericf))call print_generic(genericf) if(present(genericg))call print_generic(genericg) if(present(generich))call print_generic(generich) if(present(generici))call print_generic(generici) if(present(genericj))call print_generic(genericj) msg_scalar=trim(line) contains subroutine print_generic(generic) !use, intrinsic :: iso_fortran_env, only : int8, int16, int32, biggest=>int64, real32, real64, dp=>real128 use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64, real32, real64, real128 class(*),intent(in) :: generic select type(generic) type is (integer(kind=int8));     write(line(istart:),' ( i0 ) ') generic type is (integer(kind=int16));    write(line(istart:),' ( i0 ) ') generic type is (integer(kind=int32));    write(line(istart:),' ( i0 ) ') generic type is (integer(kind=int64));    write(line(istart:),' ( i0 ) ') generic type is (real(kind=real32));      write(line(istart:),' ( 1 pg0 ) ') generic type is (real(kind=real64));      write(line(istart:),' ( 1 pg0 ) ') generic type is (real(kind=real128));     write(line(istart:),' ( 1 pg0 ) ') generic type is (logical);                write(line(istart:),' ( l1 ) ') generic type is (character(len=*));       write(line(istart:),' ( a ) ') trim(generic) type is (complex);                write(line(istart:),' ( \"(\" , 1 pg0 , \",\" , 1 pg0 , \")\" ) ') generic end select istart=len_trim(line)+increment line=trim(line)//sep_local end subroutine print_generic end function msg_scalar function msg_one(generic0,generic1, generic2, generic3, generic4, generic5, generic6, generic7, generic8, generic9,& & generica,genericb, genericc, genericd, generice, genericf, genericg, generich, generici, genericj,& & sep) implicit none ! ident_2=\"@(#)M_attr::msg_one(3fp): writes a message to a string composed of any standard one dimensional types\" class(*),intent(in)           :: generic0(:) class(*),intent(in),optional  :: generic1(:), generic2(:), generic3(:), generic4(:), generic5(:) class(*),intent(in),optional  :: generic6(:), generic7(:), generic8(:), generic9(:) class(*),intent(in),optional  :: generica(:), genericb(:), genericc(:), genericd(:), generice(:) class(*),intent(in),optional  :: genericf(:), genericg(:), generich(:), generici(:), genericj(:) character(len=*),intent(in),optional :: sep character(len=:),allocatable  :: sep_local character(len=:), allocatable :: msg_one character(len=4096)           :: line integer                       :: istart integer                       :: increment if(present(sep))then increment=1+len(sep) sep_local=sep else sep_local=' ' increment=2 endif istart=1 line=' ' call print_generic(generic0) if(present(generic1))call print_generic(generic1) if(present(generic2))call print_generic(generic2) if(present(generic3))call print_generic(generic3) if(present(generic4))call print_generic(generic4) if(present(generic5))call print_generic(generic5) if(present(generic6))call print_generic(generic6) if(present(generic7))call print_generic(generic7) if(present(generic8))call print_generic(generic8) if(present(generic9))call print_generic(generic9) if(present(generica))call print_generic(generica) if(present(genericb))call print_generic(genericb) if(present(genericc))call print_generic(genericc) if(present(genericd))call print_generic(genericd) if(present(generice))call print_generic(generice) if(present(genericf))call print_generic(genericf) if(present(genericg))call print_generic(genericg) if(present(generich))call print_generic(generich) if(present(generici))call print_generic(generici) if(present(genericj))call print_generic(genericj) msg_one=trim(line) contains subroutine print_generic(generic) !use, intrinsic :: iso_fortran_env, only : int8, int16, int32, biggest=>int64, real32, real64, dp=>real128 use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64, real32, real64, real128 class(*),intent(in),optional :: generic(:) integer :: i select type(generic) type is (integer(kind=int8));     write(line(istart:),' ( \"[\" , * ( i0 , 1 x )) ') generic type is (integer(kind=int16));    write(line(istart:),' ( \"[\" , * ( i0 , 1 x )) ') generic type is (integer(kind=int32));    write(line(istart:),' ( \"[\" , * ( i0 , 1 x )) ') generic type is (integer(kind=int64));    write(line(istart:),' ( \"[\" , * ( i0 , 1 x )) ') generic type is (real(kind=real32));      write(line(istart:),' ( \"[\" , * ( 1 pg0 , 1 x )) ') generic type is (real(kind=real64));      write(line(istart:),' ( \"[\" , * ( 1 pg0 , 1 x )) ') generic type is (real(kind=real128));     write(line(istart:),' ( \"[\" , * ( 1 pg0 , 1 x )) ') generic !type is (real(kind=real256));     write(error_unit,' ( 1 pg0 ) ',advance=' no ') generic type is (logical);                write(line(istart:),' ( \"[\" , * ( l1 , 1 x )) ') generic type is (character(len=*));       write(line(istart:),' ( \"[\" ,: * ( \"\"\"\" , a , \"\"\"\" , 1 x )) ') (trim(generic(i)),i=1,size(generic)) type is (complex);                write(line(istart:),' ( \"[\" , * ( \"(\" , 1 pg0 , \",\" , 1 pg0 , \")\" , 1 x )) ') generic class default stop ' unknown type in * print_generic * ' end select istart=len_trim(line)+increment+1 line=trim(line)//' ] ' // sep_local end subroutine print_generic end function msg_one end module M_attr","tags":"","loc":"sourcefile/m_attr.f90.html"},{"title":"redirect.F90 – M_attr","text":"Contents Programs roots Source Code redirect.F90 Source Code program roots use , intrinsic :: iso_fortran_env , only : stdin => input_unit , stdout => output_unit , stderr => error_unit use M_attr , only : attr , attr_mode , attr_update ! Calculate and print the roots of a quadratic formula even if they are complex implicit none integer , parameter :: dp = kind ( 0.0d0 ) real ( kind = dp ) :: a , b , c , discriminant real ( kind = dp ) :: x1 , x2 , x ! Real roots of the equation real ( kind = dp ) :: x_real ! Real part of complex root of the equation REAL ( kind = dp ) :: x_complex ! Imaginary part of complex root of the equation character ( len = 256 ) :: message integer :: ios character ( len = 1 ) :: paws character ( len = 1024 ) :: buffer character ( len =* ), parameter :: numbers = '(\"<B><w><bo>   \",*(\"(\",g0.8,\",\",g0.8,\")\":,1x))' character ( len = :), allocatable :: TERM if ( system_isatty ( stdout )) then ! ISATTY() is an extension, but found in Intel, GNU, PGI, ... compiler call attr_mode ( 'color' ) else call attr_mode ( 'plain' ) endif TERM = system_getenv ( 'TERM' , 'vt102' ) ! perhaps change or add strings based on terminal type select case ( TERM ) case ( 'xterm' ) call attr_update ( 'mono' , attr ( '<esc>]11;black<bel><esc>]10;white<bel>' )) ! change default bg and fg case ( 'screen' ) end select INFINITE : do ! clear screen, set attributes and print messages call text ( \"<reset><clear>\" ) call text ( \"For the quadratic equation <m>A</m><g>*x**2 +<m>B</m><g>*x + <m>C</m> \" ) write ( stdout , '(*(a))' , advance = 'no' ) & & attr ( '<B><w><bo>' , chars = 80 ), & & char ( 13 ),& & attr ( '<B><g><bo>enter coefficients <m>A,B,C</m><g>:<y><gt><ul>' ,& & reset = . false ., chars = 80 ) read ( stdin , * , iostat = ios , iomsg = message ) a , b , c write ( stdout , '(a)' , advance = 'no' ) attr ( '<reset>' ) if ( ios . ne . 0 ) then write ( stdout , * ) write ( stdout , '(*(g0))' ) ios , ' ' , trim ( message ) rewind ( unit = stdin , iostat = ios ) backspace ( unit = stdin , iostat = ios ) else ! Given the equation \"A*X**2 + B*X + C = 0\" ! Use the quadratic formula to determine the root values of the equation. ! prompt for new value call text () call text ( 'Given the equation' ) call text () write ( buffer , '(*(g0.8))' ) '<B><w><bo>   ' , a , '<m>*X**2</m><w> + ' , b , '<m>*X</m><w> + ' , c , ' = 0' call text ( buffer ) call text () discriminant = b ** 2 - 4 * a * c if ( a . eq . 0 ) then call text ( '<ERROR> <m>If <m>a</m><g> is zero this is a linear, not quadratic equation' ) elseif ( discriminant > 0 ) then call text ( 'the <m>roots</m><g> (ie. \"x intercepts\") are <m>real<m><g> so the parabola ' ) call text ( 'crosses the x-axis at <m>two points</m><g>:' ) call text () x1 = ( - b + sqrt ( discriminant )) / ( 2 * a ) x2 = ( - b - sqrt ( discriminant )) / ( 2 * a ) write ( buffer , numbers ) x1 , 0.0d0 call text ( buffer ) write ( buffer , numbers ) x2 , 0.0d0 call text ( buffer ) call text () elseif ( discriminant == 0 ) then call text ( 'the <m>roots</m><g> (ie. \"x intercepts\") are repeated <m>(real and equal)</m><g>' ) call text ( 'so the parabola just touches the x-axis at:' ) call text () if ( b . ne . 0 ) then x = ( - b ) / ( 2 * a ) else x = 0.0d0 endif write ( buffer , numbers ) x , 0.0d0 call text ( buffer ) call text () else call text ( 'the <m>roots</m><g>(ie. \"x intercepts\")  are <m>complex</m><g>:' ) x_real = ( - b ) / ( 2 * a ) x_complex = sqrt ( abs ( discriminant )) / ( 2 * a ) call text () WRITE ( buffer , '(a,*(\"(\",g0.8,\", +i\",g0.8,\")\",:,1x))' ) '<B><w><bo>   ' , x_real , x_complex call text ( buffer ) WRITE ( buffer , '(a,*(\"(\",g0.8,\", -i\",g0.8,\")\",:,1x))' ) '<B><w><bo>   ' , x_real , x_complex call text ( buffer ) call text () endif call text ( 'with' ) call text () write ( buffer , '(g0,*(g0.8,1x))' ) \"<B><w><bo>   <m>discriminate</m><w> = \" , discriminant call text ( buffer ) call text () endif write ( stdout , '(*(g0))' , advance = 'no' ) attr ( '<B><e>press <g>return</g><e> to continue, \"<g>q</g><e>\" to quit:' , chars = 79 ) read ( stdin , advance = 'yes' , iostat = ios , fmt = '(a)' , iomsg = message ) paws if ( paws . ne . '' ) exit INFINITE enddo INFINITE contains subroutine text ( string ) character ( len =* ), intent ( in ), optional :: string if ( present ( string )) then write ( stdout , '(*(g0))' ) attr ( '<B><g><bo>' // trim ( string ), chars = 80 ) else write ( stdout , '(*(g0))' ) attr ( '<B><g><bo>' , chars = 80 ) endif end subroutine text !>  call compiler-specific ISATTY() function or return .FALSE. #undef ISATTY #ifdef __INTEL_COMPILER function system_isatty ( lun ) use IFPORT integer , intent ( in ) :: lun logical :: system_isatty system_isatty = isatty ( lun ) end function system_isatty #define ISATTY #endif #ifdef __NVCOMPILER_MAJOR__X ! __NVCOMPILER_MAJOR__ __NVCOMPILER_MINOR__ __NVCOMPILER_PATCHLEVEL__ function system_isatty ( lun ) use DFPORT integer , intent ( in ) :: lun logical :: system_isatty system_isatty = isatty ( lun ) end function system_isatty #define ISATTY #endif #ifdef __GFORTRAN__ function system_isatty ( lun ) integer , intent ( in ) :: lun logical :: system_isatty system_isatty = isatty ( lun ) end function system_isatty #define ISATTY #endif #ifndef ISATTY function system_isatty ( lun ) integer , intent ( in ) :: lun logical :: system_isatty system_isatty = . false . end function system_isatty #define ISATTY #endif function system_getenv ( name , default ) result ( value ) !$@(#) M_system::system_getenv(3f): call get_environment_variable as a function with a default value(3f) character ( len =* ), intent ( in ) :: name character ( len =* ), intent ( in ), optional :: default integer :: howbig integer :: stat character ( len = :), allocatable :: value if ( NAME . ne . '' ) then call get_environment_variable ( name , length = howbig , status = stat , trim_name = . true .) ! get length required to hold value if ( howbig . ne . 0 ) then select case ( stat ) case ( 1 ) ! print *, NAME, \" is not defined in the environment. Strange...\" value = '' case ( 2 ) ! print *, \"This processor doesn't support environment variables. Boooh!\" value = '' case default ! make string to hold value of sufficient size and get value if ( allocated ( value )) deallocate ( value ) allocate ( character ( len = max ( howbig , 1 )) :: VALUE ) call get_environment_variable ( name , value , status = stat , trim_name = . true .) if ( stat . ne . 0 ) VALUE = '' end select else value = '' endif else value = '' endif if ( value . eq . '' . and . present ( default )) value = default end function system_getenv END PROGRAM roots","tags":"","loc":"sourcefile/redirect.f90.html"},{"title":"light.f90 – M_attr","text":"Contents Programs demo_attr Source Code light.f90 Source Code program demo_attr ! read stdin and run it through M_attr::attr to display color use M_attr , only : attr , attr_update implicit none character ( len = 1024 ) :: line character ( len = :), allocatable :: expanded integer :: icount integer :: ios line = '' call attr_update ( 'Z' , char ( 27 ) // '[1m' ) icount = command_argument_count () ! get number of arguments ! if command arguments use those instead of reading stdin ! example: light '<clear><B><w><bo><CSI>12;36f Good Morning! ' if ( icount . gt . 0 ) then call args () else do read ( * , '(a)' , iostat = ios ) line if ( ios . ne . 0 ) exit expanded = attr ( trim ( line )) write ( * , '(a)' ) expanded enddo write ( * , '(a)' , advance = 'no' ) attr ( '<reset>' ) endif contains subroutine args () implicit none integer :: i integer :: istat integer :: argument_length character ( len = :), allocatable :: argument do i = 1 , icount call get_command_argument ( number = i , length = argument_length ) ! allocate string array big enough to hold command line argument if ( allocated ( argument )) deallocate ( argument ) allocate ( character ( len = argument_length ) :: argument ) ! read the argument call get_command_argument ( i , argument , status = istat ) expanded = attr ( trim ( argument )) write ( * , '(a)' ) expanded enddo end subroutine args end program demo_attr","tags":"","loc":"sourcefile/light.f90.html"},{"title":"plain.f90 – M_attr","text":"Contents Programs demo_attr Source Code plain.f90 Source Code program demo_attr ! read stdin and run it through M_attr::attr to display without color use M_attr , only : attr , attr_mode implicit none character ( len = 1024 ) :: line integer :: ios line = '' call attr_mode ( manner = 'plain' ) do read ( * , '(a)' , iostat = ios ) line if ( ios . ne . 0 ) exit write ( * , '(a)' ) attr ( trim ( line )) enddo write ( * , '(a)' , advance = 'no' ) attr ( '<reset>' ) end program demo_attr","tags":"","loc":"sourcefile/plain.f90.html"},{"title":"tat.f90 – M_attr","text":"Contents Programs terminal_attributes Source Code tat.f90 Source Code program terminal_attributes ! read stdin and run it through M_attr::attr to display color use M_attr , only : attr , attr_update , attr_mode use M_CLI2 , only : set_args , sget , iget , remaining , lget , unnamed , specified implicit none character ( len = 1024 ) :: line character ( len = :), allocatable :: prefix integer :: iwidth integer :: ios integer :: i character ( len = :), allocatable :: help_text (:), version_text (:) line = '' call setup () call set_args ( ' --manner \"color\" --debug F --chars 0 -prefix \" \"' , help_text , version_text ) ! if command arguments use those instead of reading stdin ! example: tat '<clear><B><w><bo><CSI>12;36f Good Morning! ' iwidth = iget ( 'chars' ) call attr_mode ( sget ( 'manner' )) if ( specified ( 'prefix' )) then prefix = sget ( 'prefix' ) else prefix = '' endif if ( lget ( 'debug' )) then write ( * , * ) 'REMAINING:' , remaining write ( * , * ) 'UNNAMED:' , unnamed write ( * , * ) 'MANNER:' , sget ( 'manner' ) write ( * , * ) 'CHARS:' , iwidth endif if ( size ( unnamed ). ne . 0 ) then do i = 1 , size ( unnamed ) write ( * , '(a)' ) attr ( unnamed ( i ), chars = iwidth ) enddo else do read ( * , '(a)' , iostat = ios ) line if ( ios . ne . 0 ) exit if ( len ( prefix ). ne . 0 ) then line = prefix // line endif write ( * , '(a)' ) attr ( trim ( line ), chars = iwidth ) enddo write ( * , '(a)' , advance = 'no' ) attr ( '<reset>' ) endif contains subroutine setup () help_text = [ character ( len = 80 ) :: & 'NAME                                                                           ' ,& '    tat(1f) - [M_attr] filter terminal attribute strings                       ' ,& '    (LICENSE:MIT)                                                              ' ,& 'SYNOPSIS                                                                       ' ,& '    tat [[string(s)][ --chars N] [ --prefix STR] [ --manner MODE] ]|           ' ,& '    [ --help| --version]                                                       ' ,& 'DESCRIPTION                                                                    ' ,& '   tat(1) (\"Terminal Attributes\") is like cat(1), except it processes          ' ,& '   special strings in the input specifying terminal attributes such as color   ' ,& '   and underlining using an HTML-like syntax via the M_attr(3f) module.        ' ,& '                                                                               ' ,& 'OPTIONS                                                                        ' ,& '   STRINGS    if present process and print these strings instead of reading    ' ,& '              and processing stdin.                                            ' ,& '   --manner   Set output mode (\"color\"|\"plain\"|\"raw\"). Default is \"color\".     ' ,& '   --chars    column to fill background color out to. Default is 0 (zero);     ' ,& '              meaning to not padd the lines. Note multi-byte character sets    ' ,& '              and non-printable characters will not work properly with this    ' ,& '              option, but typical plain ASCII will.                            ' ,& '   --prefix   string to place in from of input lines from stdin. Typically     ' ,& '              used to set background and text color, as with \"<B><w><bo>\".     ' ,& '   --help     display this help and exit                                       ' ,& '   --version  output version information and exit                              ' ,& '                                                                               ' ,& 'EXAMPLES                                                                       ' ,& '  Sample commands                                                              ' ,& '                                                                               ' ,& '     cmd|tat -chars 132 -prefix \"<B><w>\"                                       ' ,& '     tat \"<clear><B><w><bo><CSI>12;36f Good Morning!\"                          ' ,& '     tat --chars 80 --prefix \"<B><w>\"                                          ' ,& 'LIMITATIONS                                                                    ' ,& 'AUTHOR                                                                         ' ,& '   John S. Urban                                                               ' ,& 'LICENSE                                                                        ' ,& '   MIT                                                                         ' ,& '' ] version_text = [ character ( len = 80 ) :: & 'PRODUCT:        GPF (General Purpose Fortran) utilities and examples           ' ,& 'PROGRAM:        tat(1)                                                         ' ,& 'DESCRIPTION:    filter applies terminal attributes as defined by M_attr(3f)    ' ,& 'VERSION:        1.0, 20210801                                                  ' ,& 'AUTHOR:         John S. Urban                                                  ' ,& 'REPORTING BUGS: http://www.urbanjost.altervista.org/                           ' ,& 'HOME PAGE:      http://www.urbanjost.altervista.org/index.html                 ' ,& 'LICENSE:        MIT' ] end subroutine setup end program terminal_attributes","tags":"","loc":"sourcefile/tat.f90.html"},{"title":"demo_M_attr.f90 – M_attr","text":"Contents Programs demo_M_attr Source Code demo_M_attr.f90 Source Code program demo_M_attr use M_attr , only : attr , attr_mode , attr_update , alert implicit none character ( len = 256 ) :: line character ( len =* ), parameter :: f = '( & &\"   <bo><w><G> GREAT: </G></w>& &The new value <Y><b>\",f8.4,1x,\"</b></Y> is in range\"& &)' real :: value write ( * , '(a)' )& & attr ( '   <r><W><bo> ERROR: </W>red text on a white background</y>' ) value = 3.4567 write ( line , fmt = f ) value write ( * , '(a)' ) attr ( trim ( line )) ! write same string as plain text write ( * , * ) call attr_mode ( manner = 'plain' ) write ( * , '(a)' ) attr ( trim ( line )) call attr_mode ( manner = 'color' ) ! use pre-defined or user defined strings write ( * , * ) write ( * , '(a)' ) attr ( '<ERROR> Woe is nigh.' ) write ( * , '(a)' ) attr ( '<WARNING> The night is young.' ) write ( * , '(a)' ) attr ( '<INFO> It is Monday' ) call alert ( '<ERROR>' , 'Woe is nigh.' ) call alert ( '<WARNING>' , 'The night is young.' ) call alert ( '<INFO>' , 'It is Monday' ) ! create a custom mnemonic call attr_update ( 'MYERROR' , attr (& ' <R><e> E<w>-<e>R<w>-<e>R<w>-<e>O<w>-<e>R: </e></R></bo>' & )) write ( * , * ) write ( * , '(a)' ) attr ( '<MYERROR> my custom message style' ) end program demo_M_attr","tags":"","loc":"sourcefile/demo_m_attr.f90.html"},{"title":"custom.f90 – M_attr","text":"Contents Programs demo_M_attr Source Code custom.f90 Source Code program demo_M_attr use M_attr , only : attr , attr_update write ( * , '(a)' ) attr ( '<clear>TEST CUSTOMIZED:' ) ! add custom keywords call attr_update ( 'blink' , char ( 27 ) // '[5m' ) call attr_update ( '/blink' , char ( 27 ) // '[25m' ) write ( * , '(a)' ) attr ( '<blink>Items for Friday</blink> not before' ) write ( * , '(a)' , advance = 'no' ) attr ( '<r>RED</r>,' ) write ( * , '(a)' , advance = 'no' ) attr ( '<b>BLUE</b>,' ) write ( * , '(a)' , advance = 'yes' ) attr ( '<g>GREEN</g>' ) ! delete call attr_update ( 'r' ) call attr_update ( '/r' ) ! replace call attr_update ( 'b' , '<<<<' ) call attr_update ( '/b' , '>>>>' ) write ( * , '(a)' , advance = 'no' ) attr ( '<r>RED</r>,' ) write ( * , '(a)' , advance = 'no' ) attr ( '<b>BLUE</b>,' ) write ( * , '(a)' , advance = 'yes' ) attr ( '<g>GREEN</g>' ) end program demo_M_attr","tags":"","loc":"sourcefile/custom.f90.html"},{"title":"dots.f90 – M_attr","text":"Contents Programs dots Source Code dots.f90 Source Code !---------------------------------------------------------------------------------------- program dots ! @(#) random dots on screen till ctrl-C use M_attr , only : attr implicit none integer :: x , y integer :: z character ( len = 1 ) :: p integer :: fg , bg real :: r real :: c integer :: icount character ( len = 10 ), parameter :: colors ( 8 ) = [ character ( len = 10 ) :: 'RED' , 'GREEN' , 'BLUE' , 'CYAN' , 'MAGENTA' , 'YELLOW' , 'BLACK' , 'WHITE' ] fg = 8 bg = 7 r = 80 c = 24 icount = 0 INFINITE : do x = int (( c * ranf ()) + 1 ) y = int (( r * ranf ()) + 1 ) if ( ranf () > 0.9 ) then p = \"*\" else p = \" \" endif write ( * , '(*(g0))' , advance = 'no' ) attr ( '<CSI>' , reset = . false .), x , ';' , y , 'f' , p z = min ( 8 , int ( ranf () * 8 + 1 )) write ( * , '(a)' , advance = 'no' ) attr ( '<' // trim ( colors ( z )) // '>' , reset = . false .) icount = icount + 1 write ( * , '(*(g0))' , advance = 'no' ) attr ( '<CSI>1;1f' , reset = . false .), icount if ( icount . gt . 24 * 80 * 250 ) exit enddo INFINITE write ( * , * ) attr ( \"<reset>That was two hundred and fifty pages worth of dots\" ) CONTAINS !---------------------------------------------------------------------------------------- FUNCTION ranf () result ( r ) IMPLICIT NONE REAL :: r LOGICAL , SAVE :: already_run = . TRUE . IF (. NOT . already_run ) THEN CALL init_random_seed_by_clock () already_run = . TRUE . ENDIF CALL random_number ( r ) END FUNCTION ranf !---------------------------------------------------------------------------------------- SUBROUTINE init_random_seed_by_clock () implicit none INTEGER :: i , n , clock INTEGER , DIMENSION (:), ALLOCATABLE :: seed CALL RANDOM_SEED ( size = n ) ALLOCATE ( seed ( n )) CALL SYSTEM_CLOCK ( COUNT = clock ) seed = clock + 37 * ( / ( i - 1 , i = 1 , n ) / ) CALL RANDOM_SEED ( PUT = seed ) DEALLOCATE ( seed ) END SUBROUTINE init_random_seed_by_clock !---------------------------------------------------------------------------------------- END PROGRAM dots","tags":"","loc":"sourcefile/dots.f90.html"},{"title":"message.f90 – M_attr","text":"Contents Programs mode Source Code message.f90 Source Code program mode use M_attr , only : attr , attr_mode implicit none call printme ( 'color' ) call printme ( 'plain' ) call printme ( 'raw' ) contains subroutine printme ( mymode ) character ( len =* ), intent ( in ) :: mymode call attr_mode ( mymode ) write ( * , '(a)' ) mymode write ( * , '(a)' ) attr ( '<ERROR>Woe is nigh.' ) write ( * , '(a)' ) attr ( '<WARNING>The night is young.' ) write ( * , '(a)' ) attr ( '<INFO>It is Monday' ) end subroutine printme end program mode","tags":"","loc":"sourcefile/message.f90.html"},{"title":"demo_attr.f90 – M_attr","text":"Contents Programs demo_attr Source Code demo_attr.f90 Source Code program demo_attr use M_attr , only : attr , attr_mode , attr_update call printstuff ( 'defaults' ) call attr_mode ( manner = 'plain' ) call printstuff ( 'plain:' ) call printstuff ( 'raw' ) call attr_mode ( manner = 'color' ) call printstuff ( '' ) write ( * , '(a)' ) attr ( 'TEST ADDING A CUSTOM SEQUENCE:' ) call attr_update ( 'blink' , char ( 27 ) // '[5m' ) call attr_update ( '/blink' , char ( 27 ) // '[25m' ) write ( * , '(a)' ) attr ( '<blink>Items for Friday</blink>' ) contains subroutine printstuff ( label ) character ( len =* ), intent ( in ) :: label character ( len = :), allocatable :: array (:) call attr_mode ( manner = label ) array = [ character ( len = 60 ) :: & 'TEST MANNER=' // label , & '<r>RED</r>,<g>GREEN</g>,<b>BLUE</b>' , & '<c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y>' , & '<w>WHITE</w> and <e>EBONY</e>' ] write ( * , '(a)' ) attr ( array ) write ( * , '(a)' ) attr ( 'Adding <bo>bold</bo>' ) write ( * , '(a)' ) attr ( '<bo><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></bo>' ) write ( * , '(a)' ) attr ( '<bo><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y></bo>' ) write ( * , '(a)' ) attr ( '<bo><w>WHITE</w> and <e>EBONY</e></bo>' ) write ( * , '(a)' ) attr ( 'Adding <ul>underline</ul>' ) write ( * , '(a)' ) attr (& & '<bo><ul><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></ul></bo>' ) write ( * , '(a)' ) attr (& & '<bo><ul><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><w>WHITE</w> and <e>EBONY</e></ul></bo>' ) write ( * , '(a)' ) attr ( 'Adding <ul>italic</ul>' ) write ( * , '(a)' ) attr (& & '<bo><ul><it><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></it></ul></bo>' ) write ( * , '(a)' ) attr (& & '<bo><ul><it><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</it></y></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><it><w>WHITE</w> and <e>EBONY</e></ul></bo>' ) write ( * , '(a)' ) attr ( 'Adding <in>inverse</in>' ) write ( * , '(a)' ) attr ( '<in><bo><ul><it><r>RED</r>,<g>GREEN</g>,& &<b>BLUE</b></it></ul></bo></in>' ) write ( * , '(a)' ) attr ( '<in><bo><ul><it><c>CYAN</c>,<m>MAGENTA</g>,& &<y>YELLOW</it></y></ul></bo></in>' ) write ( * , '(a)' ) attr (& & '<in><bo><ul><it><w>WHITE</w> and <e>EBONY</e></ul></bo></in>' ) end subroutine printstuff end program demo_attr","tags":"","loc":"sourcefile/demo_attr.f90.html"},{"title":"version.f90 – M_attr","text":"Contents Programs version Source Code version.f90 Source Code program version use M_attr , only : attr , attr_update , attr_mode ! shows a limitation if periods are replaced with spaces the CHAR= option does not ! count the colored blanks so if no text after the blanks too much padding is appended to the line ! need to count last character with a background attribute or something different implicit none integer :: i !nvfortran bug!character(len=*),parameter :: text(*)= [character(len=132) :: & character ( len =* ), parameter :: text ( 23 ) = [ character ( len = 132 ) :: & '<E><e>                                                     ' ,& '<E><e>        <C>                                   </W><E><end>' ,& '<E><e>        <C>      LLL        </C><E> <bo><w>F</bo>ortran   </w></E><C>       <E><e></bo><end>' ,& '<E><e>        <C>     LL LL       </C><E>  <bo><w>P</bo>ackage  </w></E><C>       <E><e></bo><end>' ,& '<E><e>        <C>     LL          </C><E>   <bo><w>M</bo>anager </w></E><C>       <E><e></bo><end>' ,& '<E><e>        <C>   LLLLLL                          <E><end>' ,& '<E><e>        <C>     LL                            <E><end>' ,& '<E><e>        <C>     LL               LLLLL LLL    <E><end>' ,& '<E><e>        <C>     LL     LLLLLL     LL  L  LL   <E><end>' ,& '<E><e>        <C>     LL    LL     L    LL  L  LL   <E><end>' ,& '<E><e>        <C>     LL    LL     L    LL  L  LL   <E><end>' ,& '<E><e>        <C>     LL    LLLLLLL     LL  L  LL   <E><end>' ,& '<E><e>        <C>           LL                      <E><end>' ,& '<E><e>        <C>           LL                      <E><end>' ,& '<E><e>        <C>           LL                      <E><end>' ,& '<E><e>        <C>                                   <E><end>' ,& '<E><e>                                                     ' ,& '<E><bo><b>Program:</b><w>     fpm(1)                                     ' ,& '<E><bo><b>Description:</b><w> A Fortran package manager and build system ' ,& '<E><bo><b>Version:</b><w>     0.3.0, alpha                               ' ,& '<E><bo><b>License:</b><w>     MIT                                        ' ,& '<E><bo><b>Home Page:</b><w>   https://github.com/fortran-lang/fpm        ' ,& '<E><bo>' ] ! add custom keywords call attr_update ( 'end' , '.' , ' ' ) call attr_mode ( manner = 'plain' ) write ( * , '(a)' )( attr ( trim ( text ( i )), chars = 80 ), i = 1 , size ( text )) call attr_update ( 'end' , '.' , char ( 0 )) call attr_mode ( manner = 'color' ) write ( * , '(a)' )( attr ( trim ( text ( i )), chars = 80 ), i = 1 , size ( text )) end program version","tags":"","loc":"sourcefile/version.f90.html"},{"title":"help.f90 – M_attr","text":"Contents Programs fancy Source Code help.f90 Source Code program fancy use , intrinsic :: iso_fortran_env , only : stderr => ERROR_UNIT , stdin => INPUT_UNIT , stdout => OUTPUT_UNIT use M_attr , only : attr , attr_update , attr_mode implicit none integer :: i character ( len = 256 ), parameter :: help_list_nodash ( * ) = [ character ( len = 256 ) :: & !'<clear>', & '<E><w><b><bo>F</bo>ortran <bo>P</bo>ackage <bo>M</bo>anager:</b>' , & '<E><w>                                                                        ' , & '<E><w><bo>USAGE: <r><un>fpm</un></r><w> [ <r><un>SUBCOMMAND</un></r> <w>[<m>SUBCOMMAND_OPTIONS</m><w>] ]|& &<bo>[<g>--list</g><w>|<g>--help</g><w>|<g>--version</g><w>]' , & '<E><w>                                                                        ' , & '<E><w> where <r><un><bo>SUBCOMMAND</bo></un></r> <w>is commonly one of & &<bo><g>new</g><w>|<g>build</g><w>|<g>run</g><w>|<g>test</g></bo> <w>but may be any of' , & '<E><w>                                                                        ' , & '<E><w>  <bo><g>build</g></bo>     <w>Compile the package placing results in the \"build\" directory' , & '<E><w>  <bo><g>help</g></bo>      <w>Display help                                                ' , & '<E><w>  <bo><g>list</g></bo>      <w>Display this list of subcommand descriptions                ' , & '<E><w>  <bo><g>new</g></bo>       <w>Create a new Fortran package directory with sample files    ' , & '<E><w>  <bo><g>run</g></bo>       <w>Run the local package application programs                  ' , & '<E><w>  <bo><g>test</g></bo>      <w>Run the test programs                                       ' , & '<E><w>  <bo><g>update</g></bo>    <w>Update and manage project dependencies                      ' , & '<E><w>  <bo><g>install</g></bo>   <w>Install project                                             ' , & '<E><w>                                                                        ' , & '<E><w> <bo>Enter \"<r><un>fpm</un></r> <g>--list</g><w></bo>\" for a brief list of subcommand options. Enter' , & '<E><w> \"<bo><r><un>fpm</un></r> <g>--help</g></bo><w>\" or & &\"<bo><r><un>fpm</un> <un>SUBCOMMAND</un></r> <g>--help</g><w></bo>\" for detailed descriptions.' , & '<E><w>                                                                        ' , & '<E><w> <bo>Note:</bo> color mode is controlled by the environment variable FPM_COLOR. The' , & '<E><w>       set of allowable values is {<g><bo>always,never,auto</bo></g><w>}. The default is \"<g><bo>auto</bo></g><w>\". ' , & '<E><w> ' ] character ( len = 256 ), parameter :: help_list_dash ( * ) = [ character ( len = 256 ) :: & !'<clear>', & '<E><w><b><bo>F</bo>ortran </bo>P</bo>ackage <bo>M</bo>anager:</b>' , & '<E><w>                                                           ' , & '<E><w> <bo><g>build</g><w> [<g>--compiler</g> <m>COMPILER_NAME</m><w>] & &[<g>--profile</g> <m>PROF</m><w>] [<g>--flag</g> <m>FFLAGS</m><w>] [<g>--list</g><w>]' , & '<E><w>                                                           ' , & '<E><w> <bo><g>help</g><w> [<r><un>NAME(s)</un></r><w>]                       ' , & '<E><w>                                                           ' , & '<E><w> <bo><g>new</g><w> <r><un>NAME</un></r><w> [[<g>--lib</g><w>|<g>--src</g><w>] [<g>--app</g><w>] & &[<g>--test</g><w>] [<g>--example</g><w>]]|' , & '<E><w> <bo>         [<g>--full</g><w>|<g>--bare</g><w>][<g>--backfill</g><w>]' , & '<E><w>                                                           ' , & '<E><w> <bo><g>update</g><w> <w>[<r><un>NAME(s)</un></r><w>] [<g>--fetch-only</g><w>] [<g>--clean</g><w>] [<g>--verbose</g><w>]' , & '<E><w>                                                           ' , & '<E><w> <bo><g>list</g><w> [<g>--list</g><w>]' , & '<E><w>                                                           ' , & '<E><w> <bo><g>run</g><w>  [[<g>--target</g><w>] <r><un>NAME(s)</un></r> <w>[<g>--example</g><w>]& &[<g>--profile</g><w> <m>PROF</m><w>] [<g>--flag</g><w> <m>FFLAGS</m><w>] [<g>--all</g><w>]' , & '<E><w> <bo>     [<g>--runner</g><w> <m>\"CMD\"</m><w>] [<g>--compiler</g><w> <m>COMPILER_NAME</m><w>] & &[<g>--list</g><w>] [-- <m>ARGS</m><w>]' , & '<E><w>                                                           ' , & '<E><w> <bo><g>test</g><w> [[<g>--target</g><w>] <r><un>NAME(s)</un></r><w>] [<g>--profile</g><w> <m>PROF</m><w>] & &[<g>--flag</g><w> <m>FFLAGS</m><w>] [<g>--runner</g><w> <m>\"CMD\"</m><w>]' , & '<E><w> <bo>     [<g>--list</g><w>] [<g>--compiler</g><w> <m>COMPILER_NAME</m><w>] [-- <m>ARGS</m><w>]' , & '<E><w>                                                           ' , & '<E><w> <bo><g>install</g><w> [<g>--profile</g><w> <m>PROF</m>] [<g>--flag</g><w> <m>FFLAGS</m>] & &[<g>--no-rebuild</g><w>] [<g>--prefix</g><w> <m>PATH</m><w>] ' , & '<E><w> <bo>        <w>[<m>OPTIONS</m><w>]' , & '<E><w> ' ] ! shows a limitation if periods are replaced with spaces the CHAR= option does not ! count the colored blanks so if no text after the blanks too much padding is appended to the line ! need to count last character with a background attribute or something different !nvfortran bug!character(len=*),parameter :: text(*)= [character(len=132) :: & character ( len =* ), parameter :: text ( 22 ) = [ character ( len = 132 ) :: & '<E><e>                                                     ' ,& '<E><w><bo>       <C>                                   </C><E></bo>' ,& '<E><w><bo>       <C>      LLL   </C><bo><B><w> F</bo>ortran   </B><C>            </bo><W> <e></C><E>' ,& '<E><w><bo>       <C>     LL LL  </C><bo><B><w>  P</bo>ackage  </B><C>            </bo><W> <e></C><E>' ,& '<E><w><bo>       <C>     LL     </C><bo><B><w>   M</bo>anager </B><C>            </bo><W> <e></C><E>' ,& '<E><w><bo>       <C>   LLLLLL                          <W> <E></bo>' ,& '<E><w><bo>       <C>     LL                            <W> <E></bo>' ,& '<E><w><bo>       <C>     LL               LLLLL LLL    <W> <E></bo>' ,& '<E><w><bo>       <C>     LL     LLLLLL     LL  L  LL   <W> <E></bo>' ,& '<E><w><bo>       <C>     LL    LL     L    LL  L  LL   <W> <E></bo>' ,& '<E><w><bo>       <C>     LL    LL     L    LL  L  LL   <W> <E></bo>' ,& '<E><w><bo>       <C>     LL    LLLLLLL     LL  L  LL   <W> <E></bo>' ,& '<E><w><bo>       <C>           LL                      <W> <E></bo>' ,& '<E><w><bo>       <C>           LL                      <W> <E></bo>' ,& '<E><w><bo>       <C>           LL                      <W> <E></bo>' ,& '<E><w><bo>       <C>                                   <W> <E></bo>' ,& '<E><w><bo>        <W>                                   <E></bo><e>   ' ,& '<E><bo><b>Program:</b><w>     fpm(1)                                     ' ,& '<E><bo><b>Description:</b><w> package manager and build system for Fortran' ,& '<E><bo><b>Version:</b><w>     0.3.0, alpha                               ' ,& '<E><bo><b>License:</b><w>     MIT                                        ' ,& '<E><bo><b>Home Page:</b><w>   https://github.com/fortran-lang/fpm        ' ] call attr_mode ( manner = 'color' ) write ( * , '(a)' )( attr ( trim ( help_list_nodash ( i )), chars = 80 ), i = 1 , size ( help_list_nodash )) call paws () write ( * , '(a)' )( attr ( trim ( help_list_dash ( i )), chars = 80 ), i = 1 , size ( help_list_dash )) call paws () ! add custom keywords call attr_mode ( manner = 'plain' ) write ( * , '(a)' )( attr ( trim ( text ( i )), chars = 80 ), i = 1 , size ( text )) call paws () call attr_mode ( manner = 'color' ) write ( * , '(a)' )( attr ( trim ( text ( i )), chars = 80 ), i = 1 , size ( text )) call paws () contains subroutine paws () character ( len = 1 ) :: letter integer :: ios write ( stdout , '(a)' , advance = 'no' , iostat = ios ) 'Enter [RETURN] to continue ...' read ( * , '(a)' , iostat = ios ) letter write ( stdout , '(a)' ) attr ( '<clear>' ) flush ( unit = stdout , iostat = ios ) end subroutine paws end program fancy","tags":"","loc":"sourcefile/help.f90.html"},{"title":"demo_attr_update.f90 – M_attr","text":"Contents Programs demo_update Source Code demo_attr_update.f90 Source Code program demo_update use M_attr , only : attr , attr_update write ( * , '(a)' ) attr ( '<clear>TEST CUSTOMIZATIONS:' ) ! add custom keywords call attr_update ( 'blink' , char ( 27 ) // '[5m' ) call attr_update ( '/blink' , char ( 27 ) // '[25m' ) write ( * , * ) write ( * , '(a)' ) attr ( '<blink>Items for Friday</blink>' ) call attr_update ( 'ouch' , attr ( & ' <R><bo><w>BIG mistake!</R></w> ' )) write ( * , * ) write ( * , '(a)' ) attr ( '<ouch> Did not see that coming.' ) write ( * , * ) write ( * , '(a)' ) attr ( & 'ORIGINALLY: <r>Apple</r>, <b>Sky</b>, <g>Grass</g>' ) ! delete call attr_update ( 'r' ) call attr_update ( '/r' ) ! replace (or create) call attr_update ( 'b' , '<<<<' ) call attr_update ( '/b' , '>>>>' ) write ( * , * ) write ( * , '(a)' ) attr ( & 'CUSTOMIZED: <r>Apple</r>, <b>Sky</b>, <g>Grass</g>' ) end program demo_update","tags":"","loc":"sourcefile/demo_attr_update.f90.html"},{"title":"mixed.f90 – M_attr","text":"Contents Programs demo_M_attrape Source Code mixed.f90 Source Code program demo_M_attrape use M_attr , only : attr , attr_mode , attr_update write ( * , '(a)' ) attr ( '<clear>TEST DEFAULTS:' ) call printstuff () write ( * , '(a)' ) attr ( 'TEST MANNER=PLAIN:' ) call attr_mode ( manner = 'plain' ) call printstuff () write ( * , '(a)' ) attr ( 'TEST MANNER=RAW:' ) call attr_mode ( manner = 'raw' ) call printstuff () write ( * , '(a)' ) attr ( 'TEST MANNER=VT102:' ) call attr_mode ( manner = 'vt102' ) call printstuff () write ( * , '(a)' ) attr ( 'TEST ADDING A CUSTOM SEQUENCE:' ) call attr_update ( 'blink' , char ( 27 ) // '[5m' ) call attr_update ( '/blink' , char ( 27 ) // '[25m' ) write ( * , '(a)' ) attr ( '<blink>Items for Friday</blink>' ) contains subroutine printstuff () write ( * , '(a)' ) attr ( '<r>RED</r>,<g>GREEN</g>,<b>BLUE</b>' ) write ( * , '(a)' ) attr ( '<c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y>' ) write ( * , '(a)' ) attr ( '<w>WHITE</w> and <e>EBONY</e>' ) write ( * , '(a)' ) attr ( 'Adding <bo>bold</bo>' ) write ( * , '(a)' ) attr ( '<bo><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></bo>' ) write ( * , '(a)' ) attr ( '<bo><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y></bo>' ) write ( * , '(a)' ) attr ( '<bo><w>WHITE</w> and <e>EBONY</e></bo>' ) write ( * , '(a)' ) attr ( 'Adding <ul>underline</ul>' ) write ( * , '(a)' ) attr ( '<bo><ul><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><w>WHITE</w> and <e>EBONY</e></ul></bo>' ) write ( * , '(a)' ) attr ( 'Adding <ul>italic</ul>' ) write ( * , '(a)' ) attr ( '<bo><ul><it><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></it></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><it><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</it></y></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><it><w>WHITE</w> and <e>EBONY</e></ul></bo>' ) write ( * , '(a)' ) attr ( 'Adding <in>inverse</in>' ) write ( * , '(a)' ) attr ( '<in><bo><ul><it><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></it></ul></bo></in>' ) write ( * , '(a)' ) attr ( '<in><bo><ul><it><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</it></y></ul></bo></in>' ) write ( * , '(a)' ) attr ( '<in><bo><ul><it><w>WHITE</w> and <e>EBONY</e></ul></bo></in>' ) end subroutine printstuff end program demo_M_attrape","tags":"","loc":"sourcefile/mixed.f90.html"},{"title":"dump.f90 – M_attr","text":"Contents Programs demo_dump Source Code dump.f90 Source Code program demo_dump use M_attr , only : attr write ( * , '(a)' , advance = 'no' ) attr ( '<dump>' ) end program demo_dump","tags":"","loc":"sourcefile/dump.f90.html"},{"title":"demo_fmt.f90 – M_attr","text":"Contents Programs demo_fmt Source Code demo_fmt.f90 Source Code program demo_fmt use :: M_attr , only : fmt implicit none character ( len = :), allocatable :: output output = fmt ( 10 , \"'[',i0,']'\" ) write ( * , * ) 'result is ' , output output = fmt ( 1 0.0 / 3.0 , \"'[',g0.5,']'\" ) write ( * , * ) 'result is ' , output output = fmt (. true ., \"'The final answer is [',g0,']'\" ) write ( * , * ) 'result is ' , output end program demo_fmt","tags":"","loc":"sourcefile/demo_fmt.f90.html"},{"title":"position.f90 – M_attr","text":"Contents Programs position Source Code position.f90 Source Code program position use M_attr , only : attr write ( * , '(a)' ) attr ( '<clear><B><w><bo><CSI>12;36f Good Morning! ' ) end program position","tags":"","loc":"sourcefile/position.f90.html"},{"title":"demo1.f90 – M_attr","text":"Contents Programs demo_M_attr Source Code demo1.f90 Source Code program demo_M_attr use M_attr , only : attr , attr_mode , attr_update implicit none character ( len = 1024 ) :: line character ( len = :), allocatable :: expanded integer :: ios write ( * , '(a)' )& & attr ( 'The most common attributes and their defaults keywords:         ' ),& & attr ( '     colors:                                                    ' ),& & attr ( '       <r>r</r>,         red,       <R>R</R>,  RED              ' ),& & attr ( '       <g>g</g>,         green,     <G>G</G>,  GREEN            ' ),& & attr ( '       <b>b</b>,         blue,      <B>B</B>,  BLUE             ' ),& & attr ( '       <m>m</m>,         magenta,   <M>M</M>,  MAGENTA          ' ),& & attr ( '       <c>c</c>,         cyan,      <C>C</C>,  CYAN             ' ),& & attr ( '       <y>y</y>,         yellow,    <Y>Y</Y>,  YELLOW           ' ),& & attr ( '       <e>e</e>,         ebony,     <E>E</E>,  EBONY            ' ),& & attr ( '       <w>w</w>,         white,     <W>W</W>,  WHITE            ' ),& & attr ( '     attributes:                                                ' ),& & attr ( '       <it>it</it>,        italic                               ' ),& & attr ( '       <bo>bo</bo>,        bold                                 ' ),& & attr ( '       <un>un</un>,        underline                            ' ),& & attr ( '     other:                                                     ' ),& & attr ( '       clear                                                    ' ),& & attr ( '       attr,       escape                                       ' ),& & attr ( '       default                                                  ' ),& & attr ( '       gt                                                       ' ),& & attr ( '       clear                                                    ' ),& & attr ( '     dual-value (one for color, one for mono):                  ' ),& & attr ( '       <ERROR>ERROR                                             ' ),& & attr ( '       <WARNING>WARNING                                         ' ),& & attr ( '       <INFO>INFO                                               ' ),& & attr ( '' ) write ( * , '(a)' ) attr ([ character ( len = 80 ) :: & '<e><W>This is an array of strings      ' , & '<r>red</r>, <g>green</g>, <b>blue</b>' , & '<c>cyan</c>, <m>magenta</m>, <y>yellow</y>' , & '<un>underline</un>' , & '       ' , & '       ' , & '       ' ]) ! read stdin and run it through M_attr::attr to display color ! write as plain text call attr_mode ( manner = 'raw' ) call attr_mode ( manner = 'plain' ) call attr_mode ( manner = 'color' ) !call attr_mode(manner='dump') call attr_update ( 'Z' , char ( 27 ) // '[1m' ) line = '' write ( * , '(a)' )& & attr ( '<y><B>WELCOME:</B></y> enter text to have it assigned attributes' ),& & attr ( '     Like <lt>W<gt><lt>r<gt>Red text on a White background      ' ),& & attr ( '' ) do read ( * , '(a)' , iostat = ios ) line expanded = attr ( trim ( line )) write ( * , '(a)' ) expanded if ( ios . ne . 0 ) exit enddo write ( * , '(a)' , advance = 'no' ) attr ( '<reset>' ) end program demo_M_attr","tags":"","loc":"sourcefile/demo1.f90.html"},{"title":"demo_attr_mode.f90 – M_attr","text":"Contents Programs demo_attr_mode Source Code demo_attr_mode.f90 Source Code program demo_attr_mode use M_attr , only : attr , attr_mode implicit none character ( len = :), allocatable :: lines (:) character ( len = :), allocatable :: outlines (:) integer :: i lines = [ character ( len = 110 ) :: & & '<M><y>' ,& & '<M><y>  Suffice it to say that black and white are also colors' ,& & '<M><y>  for their simultaneous contrast is as striking as that ' ,& & '<M><y>  of green and red, for instance. & & --- <y><bo>Vincent van Gogh</bo></y>' ,& & ' ' ] outlines = attr ( lines , chars = 57 ) write ( * , '(a)' )( trim ( outlines ( i )), i = 1 , size ( outlines )) call attr_mode ( manner = 'plain' ) ! write as plain text write ( * , '(a)' ) attr ( lines ) call attr_mode ( manner = 'raw' ) ! write as-is write ( * , '(a)' ) attr ( lines ) call attr_mode ( manner = 'ansi' ) ! return to default mode end program demo_attr_mode","tags":"","loc":"sourcefile/demo_attr_mode.f90.html"},{"title":"demo_alert.f90 – M_attr","text":"Contents Programs demo_alert Source Code demo_alert.f90 Source Code program demo_alert use M_attr , only : alert , attr , attr_mode implicit none real X call attr_mode ( manner = 'plain' ) call attr_mode ( manner = 'color' ) call alert ( \"error\" , \"Say you didn't!\" ) call alert ( \"warn\" , \"I wouldn't if I were you, Will Robinson.\" ) call alert ( \"info\" , \"I fixed that for you, but it was a bad idea.\" ) call alert ( \"debug\" , \"Who knows what is happening now?.\" ) call alert ( \"???    \" , \"not today you don't\" ) ! call to just update the macros call alert () ! conventional call to ATTR(3f) using the ALERT(3f)-defined macros write ( * , * ) attr ( '<bo>The year was <g><YE></g>, the month was <g><MO></g>' ) ! optional arguments X = 21 1.3 call alert ( 'error' , 'allowed range of X is 0 <lt> X <lt> 100, X=<r>' , X ) ! up to twenty values are allowed of intrinsic type call alert ( 'info' , 'values are<g>' , 10 , 23 4.567 , cmplx ( 1 1.0 , 2 2.0 ), 12 3.456d0 , '</g>today' ) end program demo_alert","tags":"","loc":"sourcefile/demo_alert.f90.html"},{"title":"default.f90 – M_attr","text":"Contents Programs demo_M_attr Source Code default.f90 Source Code program demo_M_attr use M_attr , only : attr , attr_mode , attr_update write ( * , '(a)' ) attr ( 'TEST MANNER=DEFAULT:' ) write ( * , '(a)' ) attr ( '<r>RED</r>,<g>GREEN</g>,<b>BLUE</b>' ) write ( * , '(a)' ) attr ( '<c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y>' ) write ( * , '(a)' ) attr ( '<w>WHITE</w> and <e>EBONY</e>' ) write ( * , '(a)' ) attr ( 'Adding <bo>bold</bo>' ) write ( * , '(a)' ) attr ( '<bo><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></bo>' ) write ( * , '(a)' ) attr ( '<bo><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y></bo>' ) write ( * , '(a)' ) attr ( '<bo><w>WHITE</w> and <e>EBONY</e></bo>' ) write ( * , '(a)' ) attr ( 'Adding <ul>underline</ul>' ) write ( * , '(a)' ) attr ( '<bo><ul><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><w>WHITE</w> and <e>EBONY</e></ul></bo>' ) write ( * , '(a)' ) attr ( 'Adding <ul>italic</ul>' ) write ( * , '(a)' ) attr ( '<bo><ul><it><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></it></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><it><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</it></y></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><it><w>WHITE</w> and <e>EBONY</e></ul></bo>' ) write ( * , '(a)' ) attr ( 'Adding <in>inverse</in>' ) write ( * , '(a)' ) attr ( '<in><bo><ul><it><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></it></ul></bo></in>' ) write ( * , '(a)' ) attr ( '<in><bo><ul><it><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</it></y></ul></bo></in>' ) write ( * , '(a)' ) attr ( '<in><bo><ul><it><w>WHITE</w> and <e>EBONY</e></ul></bo></in>' ) end program demo_M_attr","tags":"","loc":"sourcefile/default.f90.html"},{"title":"test_suite_M_attr.f90 – M_attr","text":"Contents Programs runtest Modules M_testsuite_M_attr Source Code test_suite_M_attr.f90 Source Code module M_testsuite_M_attr use , intrinsic :: iso_fortran_env , only : standard_in => input_unit , standard_out => output_unit , std_error => error_unit use M_verify use M_attr implicit none character ( len =* ), parameter :: options = ' -section 3 -library libGPF -filename `pwd`/m_attr.FF & & -documentation y -ufpp   y -ccall  n -archive  GPF.a ' character ( len = 1 ), parameter :: esc = char ( 27 ) contains !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_suite_m_attr () call test_attr () call test_attr_mode () call test_attr_update () call test_alert () end subroutine test_suite_m_attr !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_attr () logical :: allpassed call unit_check_start ( 'attr' , ' -description display text with attributes' // OPTIONS ) allpassed = . true . call attr_mode ( 'color' ) allpassed = test ( '<red>red' , esc // '[31mred' // esc // '[0m' ) . and . allpassed allpassed = test ( '<green>green' , esc // '[32mgreen' // esc // '[0m' ) . and . allpassed allpassed = test ( '<blue>blue' , esc // '[34mblue' // esc // '[0m' ) . and . allpassed allpassed = test ( '<cyan>cyan' , esc // '[36mcyan' // esc // '[0m' ) . and . allpassed allpassed = test ( '<magenta>magenta' , esc // '[35mmagenta' // esc // '[0m' ) . and . allpassed allpassed = test ( '<yellow>yellow' , esc // '[33myellow' // esc // '[0m' ) . and . allpassed allpassed = test ( '<ebony>ebony' , esc // '[30mebony' // esc // '[0m' ) . and . allpassed allpassed = test ( '<white>white' , esc // '[37mwhite' // esc // '[0m' ) . and . allpassed allpassed = test ( '<RED>RED' , esc // '[41mRED' // esc // '[0m' ) . and . allpassed allpassed = test ( '<GREEN>GREEN' , esc // '[42mGREEN' // esc // '[0m' ) . and . allpassed allpassed = test ( '<BLUE>BLUE' , esc // '[44mBLUE' // esc // '[0m' ) . and . allpassed allpassed = test ( '<CYAN>CYAN' , esc // '[46mCYAN' // esc // '[0m' ) . and . allpassed allpassed = test ( '<MAGENTA>MAGENTA' , esc // '[45mMAGENTA' // esc // '[0m' ) . and . allpassed allpassed = test ( '<YELLOW>YELLOW' , esc // '[43mYELLOW' // esc // '[0m' ) . and . allpassed allpassed = test ( '<EBONY>EBONY' , esc // '[40mEBONY' // esc // '[0m' ) . and . allpassed allpassed = test ( '<WHITE>WHITE' , esc // '[47mWHITE' // esc // '[0m' ) . and . allpassed call attr_mode ( 'plain' ) allpassed = test ( '<red>red' , 'red' ) . and . allpassed allpassed = test ( '<green>green' , 'green' ) . and . allpassed allpassed = test ( '<blue>blue' , 'blue' ) . and . allpassed allpassed = test ( '<cyan>cyan' , 'cyan' ) . and . allpassed allpassed = test ( '<magenta>magenta' , 'magenta' ) . and . allpassed allpassed = test ( '<yellow>yellow' , 'yellow' ) . and . allpassed allpassed = test ( '<ebony>ebony' , 'ebony' ) . and . allpassed allpassed = test ( '<white>white' , 'white' ) . and . allpassed allpassed = test ( '<RED>RED' , 'RED' ) . and . allpassed allpassed = test ( '<GREEN>GREEN' , 'GREEN' ) . and . allpassed allpassed = test ( '<BLUE>BLUE' , 'BLUE' ) . and . allpassed allpassed = test ( '<CYAN>CYAN' , 'CYAN' ) . and . allpassed allpassed = test ( '<MAGENTA>MAGENTA' , 'MAGENTA' ) . and . allpassed allpassed = test ( '<YELLOW>YELLOW' , 'YELLOW' ) . and . allpassed allpassed = test ( '<EBONY>EBONY' , 'EBONY' ) . and . allpassed allpassed = test ( '<WHITE>WHITE' , 'WHITE' ) . and . allpassed call attr_mode ( 'raw' ) allpassed = test ( '<red>red' , '<red>red' ) . and . allpassed allpassed = test ( '<green>green' , '<green>green' ) . and . allpassed allpassed = test ( '<blue>blue' , '<blue>blue' ) . and . allpassed allpassed = test ( '<cyan>cyan' , '<cyan>cyan' ) . and . allpassed allpassed = test ( '<magenta>magenta' , '<magenta>magenta' ) . and . allpassed allpassed = test ( '<yellow>yellow' , '<yellow>yellow' ) . and . allpassed allpassed = test ( '<ebony>ebony' , '<ebony>ebony' ) . and . allpassed allpassed = test ( '<white>white' , '<white>white' ) . and . allpassed allpassed = test ( '<RED>RED' , '<RED>RED' ) . and . allpassed allpassed = test ( '<GREEN>GREEN' , '<GREEN>GREEN' ) . and . allpassed allpassed = test ( '<BLUE>BLUE' , '<BLUE>BLUE' ) . and . allpassed allpassed = test ( '<CYAN>CYAN' , '<CYAN>CYAN' ) . and . allpassed allpassed = test ( '<MAGENTA>MAGENTA' , '<MAGENTA>MAGENTA' ) . and . allpassed allpassed = test ( '<YELLOW>YELLOW' , '<YELLOW>YELLOW' ) . and . allpassed allpassed = test ( '<EBONY>EBONY' , '<EBONY>EBONY' ) . and . allpassed allpassed = test ( '<WHITE>WHITE' , '<WHITE>WHITE' ) . and . allpassed call unit_check ( 'attr' , allpassed , msg = 'basic colors passed foreground and background' ) call unit_check_done ( 'attr' ) contains function test ( in , ExpectedResult ) result ( passed ) character ( len =* ), intent ( in ) :: in character ( len =* ), intent ( in ) :: ExpectedResult logical :: Passed passed = attr ( in ). eq . ExpectedResult if (. false .) then if ( passed ) then write ( std_error , * ) \"Passed on \" , in , \" converted to \" , ExpectedResult else write ( std_error , * ) \"Failed on \" , in , \" got \" , attr ( in ), \" Expect \" , ExpectedResult endif endif end function test end subroutine test_attr !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_attr_update () character ( len = :), allocatable :: in character ( len = :), allocatable :: out call unit_check_start ( 'attr_update' , ' ' // OPTIONS ) if ( unit_check_level . gt . 0 ) then endif call attr_mode ( manner = 'color' ) call attr_update ( '/b' , '>>>>' ) call attr_update ( 'b' , '<<<<' ) call attr_update ( 'blink' , esc // '[5m' ) call attr_update ( '/blink' , esc // '[25m' ) call attr_update ( 'mono' , attr ( '<esc>]11;black<bel><esc>]10;white<bel>' )) ! change default bg and fg call attr_update ( '/r' ) call attr_update ( 'r' ) in = attr ( '<blink>blink!</blink> stare!' ) out = esc // '[5mblink!' // esc // '[25m stare!' // esc // '[0m' call unit_check ( 'attr_update' , in . eq . out , 'add blink, in=' , in , 'out=' , attr ( in ), 'expect=' , out ) in = attr ( '<r>red removed</r>' ) out = '<r>red removed</r>' call unit_check ( 'attr_update' , in . eq . out , 'in=' , in , 'out=' , attr ( in ), 'expect=' , out ) in = attr ( '<b>blue replaced</b>' ) out = '<<<<blue replaced>>>>' call unit_check ( 'attr_update' , in . eq . out , 'in=' , in , 'out=' , attr ( in ), 'expect=' , out ) call unit_check_done ( 'attr_update' ) end subroutine test_attr_update !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_attr_mode () character ( len =* ), parameter :: in = '<B><bo>Hello!</bo></B> <G><y>Hello Again!</y></G>' character ( len =* ), parameter :: expected_color = & & esc // '[44m' // esc // '[1mHello!' // & & esc // '[22m' // esc // '[49m ' // esc // '[42m' // esc // '[33mHello Again!' // & & esc // '[39m' // esc // '[49m' // esc // '[0m' character ( len =* ), parameter :: expected_plain = 'Hello! Hello Again!' call unit_check_start ( 'attr_mode' , ' ' // OPTIONS ) call attr_mode ( manner = 'color' ) call unit_check ( 'attr_mode' , attr ( in ). eq . expected_color , 'color' ) call attr_mode ( manner = 'plain' ) call unit_check ( 'attr_mode' , attr ( in ). eq . expected_plain , 'plain' ) call attr_mode ( manner = 'raw' ) call unit_check ( 'attr_mode' , attr ( in ). eq . in , 'raw' ) call unit_check_done ( 'attr_mode' ) end subroutine test_attr_mode !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_alert () call unit_check_start ( 'alert' , ' ' // OPTIONS ) !call unit_check('alert',targetline.eq.'a b ab baaa aaCCCC CCCC CCCC a a a aa aaaaaa','example of using RANGE',targetline) call unit_check_done ( 'alert' ) end subroutine test_alert !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT end module M_testsuite_M_attr program runtest use M_msg use M_verify , only : unit_check_command , unit_check_keep_going , unit_check_level , unit_check_stop use M_testsuite_M_attr unit_check_command = '' unit_check_keep_going = . true . unit_check_level = 0 call test_suite_M_attr () call unit_check_stop end program runtest !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT","tags":"","loc":"sourcefile/test_suite_m_attr.f90.html"},{"title":"alert – M_attr","text":"public subroutine alert(type, message, g0, g1, g2, g3, g4, g5, g6, g7, g8, g9, ga, gb, gc, gd, ge, gf, gg, gh, gi, gj) !> NAME alert ( 3 f ) - [ M_attr ] print messages using a standard format including time and program name ( LICENSE : MIT ) SYNOPSIS subroutine alert(message,g0,g1,g2,g3,g4,g5,g6,g7,g8,g9,ga,gb,gc,gd,ge,gf,gg,gh,gi,gj)\n\n    character(len=*),intent(in),optional :: type\n    character(len=*),intent(in),optional :: message\n    class(*),intent(in),optional :: g0,g1,g2,g3,g4,g5,g6,g7,g8,g9, &\n                                  & ga,gb,gc,gd,ge,gf,gg,gh,gi,gj DESCRIPTION Display a message prefixed with a timestamp and the name\nof the calling program when the TYPE is specified as any\nof 'error','warn', or 'info'.\n\nIt also allows the keywords\n<ARG0>,<TZ>,<YE>,<MO>,<DA>,<HR>,<MI>,<SE>,<MS> to be used in the\nmessage (which is passed to ATTR(3f)).\n\nNote that time stamp keywords will only be updated when using ALERT(3f)\nand will only be displayed in color mode! OPTIONS TYPE if present and one of 'warn' , 'message' , 'info' , or 'debug' a predefined message is written to stderr of the form : < HR >:< MI >:< SE > . < MS > : ( < ARG0 > ) : TYPE -> message MESSAGE the user - supplied message to display via a call to ATTR ( 3f ) g [ 0 - 9 a - j ] optional values to print after the message . May be of type INTEGER , LOGICAL , REAL , DOUBLEPRECISION , COMPLEX , or CHARACTER . if no parameters are supplied the macros are updated but no output is generated . EXAMPLE Sample program\n\n   program demo_alert\n   use M_attr, only : alert, attr, attr_mode\n   implicit none\n   real X\n      call attr_mode(manner='plain')\n      call attr_mode(manner='color')\n      call alert(\"error\", \"Say you didn't!\")\n      call alert(\"warn\",  \"I wouldn't if I were you, Will Robinson.\")\n      call alert(\"info\",  \"I fixed that for you, but it was a bad idea.\")\n      call alert(\"debug\", \"Who knows what is happening now?.\")\n      call alert(\"???    \",  \"not today you don't\")\n      ! call to just update the macros\n      call alert()\n      ! conventional call to ATTR(3f) using the ALERT(3f)-defined macros\n      write(*,*)attr(' <bo> The year was <g><YE></g> , the month was <g><MO></g> ')\n      ! optional arguments\n      X=211.3\n      call alert('error','allowed range of X is 0 <lt> X <lt> 100, X= <r> ',X)\n      ! up to twenty values are allowed of intrinsic type\n      call alert('info','values are <g> ',10,234.567,cmplx(11.0,22.0),123.456d0,' </g> today')\n   end program demo_alert Results: 00 : 38 : 30.566 : ( demo_alert ) : error -> Say you didn 't! 00:38:30.567 : (demo_alert) : warning  -> I wouldn' t if I were you , Will Robinson . 00 : 38 : 30.567 : ( demo_alert ) : info -> I fixed that for you , but it was a bad idea . 00 : 38 : 30.567 : ( demo_alert ) : debug -> Who knows what is happening now ? . 00 : 38 : 30.567 : ( demo_alert ) : ??? -> not today you don 't 00:38:30.567 : (demo_alert) : error    -> allowed range of X is 0  X  100, X= 211.300003 00:38:30.567 : (demo_alert) : info     -> values are 10 234.567001 (11.0000000,22.0000000) 123.45600000000000 today AUTHOR John S. Urban, 2021 LICENSE MIT Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: type character(len=*), intent(in), optional :: message class(*), intent(in), optional :: g0 class(*), intent(in), optional :: g1 class(*), intent(in), optional :: g2 class(*), intent(in), optional :: g3 class(*), intent(in), optional :: g4 class(*), intent(in), optional :: g5 class(*), intent(in), optional :: g6 class(*), intent(in), optional :: g7 class(*), intent(in), optional :: g8 class(*), intent(in), optional :: g9 class(*), intent(in), optional :: ga class(*), intent(in), optional :: gb class(*), intent(in), optional :: gc class(*), intent(in), optional :: gd class(*), intent(in), optional :: ge class(*), intent(in), optional :: gf class(*), intent(in), optional :: gg class(*), intent(in), optional :: gh class(*), intent(in), optional :: gi class(*), intent(in), optional :: gj Contents Variables arg0 dt new_message other printme tm values zone Source Code alert Variables Type Visibility Attributes Name Initial character(len=4096), public :: arg0 character(len=8), public :: dt character(len=:), public, allocatable :: new_message character(len=:), public, allocatable :: other logical, public :: printme character(len=10), public :: tm integer, public, dimension(8) :: values character(len=5), public :: zone Source Code subroutine alert ( type , message , g0 , g1 , g2 , g3 , g4 , g5 , g6 , g7 , g8 , g9 , ga , gb , gc , gd , ge , gf , gg , gh , gi , gj ) ! TODO: could add a warning level to ignore info, or info|warning, or all implicit none character ( len =* ), intent ( in ), optional :: type character ( len =* ), intent ( in ), optional :: message class ( * ), intent ( in ), optional :: g0 , g1 , g2 , g3 , g4 , g5 , g6 , g7 , g8 , g9 class ( * ), intent ( in ), optional :: ga , gb , gc , gd , ge , gf , gg , gh , gi , gj character ( len = 8 ) :: dt character ( len = 10 ) :: tm character ( len = 5 ) :: zone integer , dimension ( 8 ) :: values character ( len = 4096 ) :: arg0 character ( len = :), allocatable :: new_message character ( len = :), allocatable :: other logical :: printme call date_and_time ( dt , tm , zone , values ) call attr_update ( 'YE' , dt ( 1 : 4 ), dt ( 1 : 4 )) call attr_update ( 'MO' , dt ( 5 : 6 ), dt ( 5 : 6 )) call attr_update ( 'DA' , dt ( 7 : 8 ), dt ( 7 : 8 )) call attr_update ( 'HR' , tm ( 1 : 2 ), tm ( 1 : 2 )) call attr_update ( 'MI' , tm ( 3 : 4 ), tm ( 3 : 4 )) call attr_update ( 'SE' , tm ( 5 : 6 ), tm ( 5 : 6 )) call attr_update ( 'MS' , tm ( 8 : 10 ), tm ( 8 : 10 )) call attr_update ( 'TZ' , zone , zone ) call get_command_argument ( 0 , arg0 ) if ( index ( arg0 , '/' ). ne . 0 ) arg0 = arg0 ( index ( arg0 , '/' , back = . true .) + 1 :) if ( index ( arg0 , '\\').ne.0) arg0=arg0(index(arg0,' \\ ',back=.true.)+1:) call attr_update(' ARG0 ',arg0,arg0) printme=.true. if(present(type))then new_message= ' < b > '//tm(1:2)//' : '//tm(3:4)//' : '//tm(5:6)//' . '//tm(8:10)//' </ b > : ( '//trim(arg0)//' ) : ' other=message//' '//str(g0,g1,g2,g3,g4,g5,g6,g7,g8,g9,ga,gb,gc,gd,ge,gf,gg,gh,gi,gj) select case(type) case(' warn ',' WARN ',' warning ',' WARNING ') new_message= new_message//' < EBONY >< bo >< y > warning </ y ></ EBONY > -< gt > ' printme=alert_warn case(' info ',' INFO ',' information ',' INFORMATION ') new_message= new_message//' < EBONY >< bo >< g > info </ g ></ EBONY > -< gt > ' printme=alert_info case(' error ',' ERROR ') new_message= new_message//' < EBONY >< bo >< r > error </ r ></ EBONY > -< gt > ' printme=alert_error case(' debug ',' DEBUG ') new_message= new_message//' < EBONY >< white >< bo > debug </ white ></ EBONY > -< gt > ' printme=alert_debug case default new_message= new_message//' < EBONY >< bo >< c > '//type//' </ c ></ EBONY > -< gt > ' printme=alert_other end select if(printme)then write(alert_unit,' ( a ) ')attr(trim(new_message//other)) endif elseif(present(message))then write(alert_unit,' ( a ) ' ) attr ( trim ( other )) endif end subroutine alert","tags":"","loc":"proc/alert.html"},{"title":"attr_mode – M_attr","text":"public subroutine attr_mode(manner) !> NAME attr_mode ( 3 f ) - [ M_attr ] select processing mode for output from attr ( 3 f ) ( LICENSE : MIT ) SYNOPSIS subroutine attr_mode(manner)\n\n    character(len=*),intent(in) :: manner DESCRIPTION Turn off the generation of strings associated with the HTML keywords in the string generated by the attr ( 3 f ) function , or display the text in raw mode as it was passed to attr ( 3 f ) or return to ANSI escape control sequence generation . OPTIONS MANNER The current manners or modes supported via the attr_mode ( 3 f ) procedure are plain suppress the output associated with keywords color ( default ) commonly supported escape sequences raw echo the input to attr ( 3 f ) as its output reload restore original keyword meanings deleted or replaced by calls to attr_update ( 3 f ) . EXAMPLE Sample program\n\n program demo_attr_mode\n use M_attr, only : attr, attr_mode\n implicit none\n character(len=:),allocatable :: lines(:)\n character(len=:),allocatable :: outlines(:)\n integer :: i\n    lines=[character(len=110):: & & ' <M><y> ', & & ' <M><y> Suffice it to say that black and white are also colors', & & ' <M><y> for their simultaneous contrast is as striking as that ', & & ' <M><y> of green and red, for instance. & & --- <y><bo> Vincent van Gogh </bo></y> ', & & ' ']\n\n    outlines=attr(lines,chars=57)\n    write(*,'(a)')(trim(outlines(i)),i=1,size(outlines))\n\n    call attr_mode(manner='plain') ! write as plain text\n    write(*,'(a)')attr(lines)\n\n    call attr_mode(manner='raw')   ! write as-is\n    write(*,'(a)')attr(lines)\n\n    call attr_mode(manner='ansi')  ! return to default mode\n\n end program demo_attr_mode AUTHOR John S. Urban, 2021 LICENSE MIT Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: manner Contents Variables i Source Code attr_mode Variables Type Visibility Attributes Name Initial integer, public :: i Source Code subroutine attr_mode ( manner ) character ( len =* ), intent ( in ) :: manner integer :: i if (. not . allocated ( mode )) then ! set substitution mode mode = 'color' call vt102 () endif select case ( manner ) case ( 'vt102' , 'ANSI' , 'ansi' , 'color' , 'COLOR' ) mode = 'color' case ( 'reload' , 'default' , 'defaults' , '' ) call vt102 () mode = 'color' case ( 'raw' ) mode = 'raw' case ( 'dump' ) ! dump dictionary for debugging if ( allocated ( keywords )) then if ( size ( keywords ). gt . 0 ) then write ( stderr , '(*(a,t30,a))' ) 'KEYWORD' , 'VALUE' write ( stderr , '(*(a,t30,2(\"[\",a,\"]\"),/))' )( trim ( keywords ( i )), values ( i ), mono_values ( i ), i = 1 , size ( keywords )) endif endif case ( 'dummy' , 'plain' , 'text' ) mode = 'plain' case default write ( * , * ) 'unknown manner. Try color|raw|plain' mode = 'color' end select end subroutine attr_mode","tags":"","loc":"proc/attr_mode.html"},{"title":"attr_update – M_attr","text":"public subroutine attr_update(key, valin, mono_valin) !> NAME attr_update ( 3 f ) - [ M_attr ] update internal dictionary given keyword and value ( LICENSE : MIT ) SYNOPSIS subroutine attr_update(key,val)\n\n character(len=*),intent(in)           :: key\n character(len=*),intent(in),optional  :: val\n character(len=*),intent(in),optional  :: mono_val DESCRIPTION Update internal dictionary in M_attr(3fm) module. OPTIONS key name of keyword to add , replace , or delete from dictionary val if present add or replace value associated with keyword . If not present remove keyword entry from dictionary . mono_val if present add or replace second value associated with keyword used for plain text mode . Must only be specified if VAL is also specified . KEYWORDS The following keywords are defined by default colors : r , red c , cyan w , white g , green m , magenta e , ebony b , blue y , yellow If the color keywords are capitalized they control the text background instead of the text color . attributes : ul , underline it , italics ( often produces inverse colors on many devices EXAMPLE Sample program\n\n  program demo_update\n  use M_attr, only : attr, attr_update\n     write(*,'(a)') attr(' <clear> TEST CUSTOMIZATIONS:')\n     ! add custom keywords\n     call attr_update('blink',char(27)//'[5m')\n     call attr_update('/blink',char(27)//'[25m')\n     write(*,*)\n     write(*,'(a)') attr(' <blink> Items for Friday </blink> ')\n     call attr_update('ouch',attr( & ' <R><bo><w> BIG mistake! </R></w> '))\n     write(*,*)\n     write(*,'(a)') attr(' <ouch> Did not see that coming.')\n     write(*,*)\n     write(*,'(a)') attr( & 'ORIGINALLY: <r> Apple </r> , <b> Sky </b> , <g> Grass </g> ')\n     ! delete\n     call attr_update('r')\n     call attr_update('/r')\n     ! replace (or create)\n     call attr_update('b',' <<<< ')\n     call attr_update('/b','>>>>')\n     write(*,*)\n     write(*,'(a)') attr( & 'CUSTOMIZED: <r> Apple </r> , <b> Sky </b> , <g> Grass </g> ')\n  end program demo_update AUTHOR John S. Urban, 2021 LICENSE MIT Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: key character(len=*), intent(in), optional :: valin character(len=*), intent(in), optional :: mono_valin Contents Variables mono_val place val Source Code attr_update Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: mono_val integer, public :: place character(len=:), public, allocatable :: val Source Code subroutine attr_update ( key , valin , mono_valin ) character ( len =* ), intent ( in ) :: key character ( len =* ), intent ( in ), optional :: valin character ( len =* ), intent ( in ), optional :: mono_valin integer :: place character ( len = :), allocatable :: val character ( len = :), allocatable :: mono_val if (. not . allocated ( mode )) then ! set substitution mode mode = 'color' ! 'color'|'raw'|'plain' call vt102 () endif if ( present ( mono_valin )) then mono_val = mono_valin else mono_val = '' endif if ( present ( valin )) then val = valin ! find where string is or should be call locate ( keywords , key , place ) ! if string was not found insert it if ( place . lt . 1 ) then call insert ( keywords , key , iabs ( place )) call insert ( values , val , iabs ( place )) call insert ( mono_values , mono_val , iabs ( place )) else call replace ( values , val , place ) call replace ( mono_values , mono_val , place ) endif else call locate ( keywords , key , place ) if ( place . gt . 0 ) then call remove ( keywords , place ) call remove ( values , place ) call remove ( mono_values , place ) endif endif end subroutine attr_update","tags":"","loc":"proc/attr_update.html"},{"title":"advice – M_attr","text":"public interface advice Contents Module Procedures alert Module Procedures public subroutine alert (type, message, g0, g1, g2, g3, g4, g5, g6, g7, g8, g9, ga, gb, gc, gd, ge, gf, gg, gh, gi, gj) !> Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: type character(len=*), intent(in), optional :: message class(*), intent(in), optional :: g0 class(*), intent(in), optional :: g1 class(*), intent(in), optional :: g2 class(*), intent(in), optional :: g3 class(*), intent(in), optional :: g4 class(*), intent(in), optional :: g5 class(*), intent(in), optional :: g6 class(*), intent(in), optional :: g7 class(*), intent(in), optional :: g8 class(*), intent(in), optional :: g9 class(*), intent(in), optional :: ga class(*), intent(in), optional :: gb class(*), intent(in), optional :: gc class(*), intent(in), optional :: gd class(*), intent(in), optional :: ge class(*), intent(in), optional :: gf class(*), intent(in), optional :: gg class(*), intent(in), optional :: gh class(*), intent(in), optional :: gi class(*), intent(in), optional :: gj","tags":"","loc":"interface/advice.html"},{"title":"attr – M_attr","text":"public interface attr Contents Module Procedures attr_scalar attr_matrix attr_scalar_width Module Procedures private function attr_scalar(string, reset) result(expanded) Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string logical, intent(in), optional :: reset Return Value character(len=:),\n  allocatable private function attr_matrix(strings, reset, chars) result(expanded) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: strings (:) logical, intent(in), optional :: reset integer, intent(in), optional :: chars Return Value character(len=:),\n  allocatable, (:) private function attr_scalar_width(string, reset, chars) result(expanded) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string logical, intent(in), optional :: reset integer, intent(in) :: chars Return Value character(len=:),\n  allocatable","tags":"","loc":"interface/attr.html"},{"title":"system_getenv – M_attr","text":"function system_getenv(name, default) result(value) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name character(len=*), intent(in), optional :: default Return Value character(len=:),\n  allocatable Contents Variables howbig stat Source Code system_getenv Variables Type Visibility Attributes Name Initial integer, public :: howbig integer, public :: stat Source Code function system_getenv ( name , default ) result ( value ) !$@(#) M_system::system_getenv(3f): call get_environment_variable as a function with a default value(3f) character ( len =* ), intent ( in ) :: name character ( len =* ), intent ( in ), optional :: default integer :: howbig integer :: stat character ( len = :), allocatable :: value if ( NAME . ne . '' ) then call get_environment_variable ( name , length = howbig , status = stat , trim_name = . true .) ! get length required to hold value if ( howbig . ne . 0 ) then select case ( stat ) case ( 1 ) ! print *, NAME, \" is not defined in the environment. Strange...\" value = '' case ( 2 ) ! print *, \"This processor doesn't support environment variables. Boooh!\" value = '' case default ! make string to hold value of sufficient size and get value if ( allocated ( value )) deallocate ( value ) allocate ( character ( len = max ( howbig , 1 )) :: VALUE ) call get_environment_variable ( name , value , status = stat , trim_name = . true .) if ( stat . ne . 0 ) VALUE = '' end select else value = '' endif else value = '' endif if ( value . eq . '' . and . present ( default )) value = default end function system_getenv","tags":"","loc":"proc/system_getenv.html"},{"title":"system_isatty – M_attr","text":"function system_isatty(lun) call compiler-specific ISATTY() function or return .FALSE. Arguments Type Intent Optional Attributes Name integer, intent(in) :: lun Return Value logical Contents Source Code system_isatty Source Code function system_isatty ( lun ) use IFPORT integer , intent ( in ) :: lun logical :: system_isatty system_isatty = isatty ( lun ) end function system_isatty","tags":"","loc":"proc/system_isatty.html"},{"title":"text – M_attr","text":"subroutine text(string) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: string Contents Source Code text Source Code subroutine text ( string ) character ( len =* ), intent ( in ), optional :: string if ( present ( string )) then write ( stdout , '(*(g0))' ) attr ( '<B><g><bo>' // trim ( string ), chars = 80 ) else write ( stdout , '(*(g0))' ) attr ( '<B><g><bo>' , chars = 80 ) endif end subroutine text","tags":"","loc":"proc/text.html"},{"title":"args – M_attr","text":"subroutine args() Arguments None Contents Variables argument argument_length i istat Source Code args Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: argument integer, public :: argument_length integer, public :: i integer, public :: istat Source Code subroutine args () implicit none integer :: i integer :: istat integer :: argument_length character ( len = :), allocatable :: argument do i = 1 , icount call get_command_argument ( number = i , length = argument_length ) ! allocate string array big enough to hold command line argument if ( allocated ( argument )) deallocate ( argument ) allocate ( character ( len = argument_length ) :: argument ) ! read the argument call get_command_argument ( i , argument , status = istat ) expanded = attr ( trim ( argument )) write ( * , '(a)' ) expanded enddo end subroutine args","tags":"","loc":"proc/args.html"},{"title":"setup – M_attr","text":"subroutine setup() Arguments None Contents Source Code setup Source Code subroutine setup () help_text = [ character ( len = 80 ) :: & 'NAME                                                                           ' ,& '    tat(1f) - [M_attr] filter terminal attribute strings                       ' ,& '    (LICENSE:MIT)                                                              ' ,& 'SYNOPSIS                                                                       ' ,& '    tat [[string(s)][ --chars N] [ --prefix STR] [ --manner MODE] ]|           ' ,& '    [ --help| --version]                                                       ' ,& 'DESCRIPTION                                                                    ' ,& '   tat(1) (\"Terminal Attributes\") is like cat(1), except it processes          ' ,& '   special strings in the input specifying terminal attributes such as color   ' ,& '   and underlining using an HTML-like syntax via the M_attr(3f) module.        ' ,& '                                                                               ' ,& 'OPTIONS                                                                        ' ,& '   STRINGS    if present process and print these strings instead of reading    ' ,& '              and processing stdin.                                            ' ,& '   --manner   Set output mode (\"color\"|\"plain\"|\"raw\"). Default is \"color\".     ' ,& '   --chars    column to fill background color out to. Default is 0 (zero);     ' ,& '              meaning to not padd the lines. Note multi-byte character sets    ' ,& '              and non-printable characters will not work properly with this    ' ,& '              option, but typical plain ASCII will.                            ' ,& '   --prefix   string to place in from of input lines from stdin. Typically     ' ,& '              used to set background and text color, as with \"<B><w><bo>\".     ' ,& '   --help     display this help and exit                                       ' ,& '   --version  output version information and exit                              ' ,& '                                                                               ' ,& 'EXAMPLES                                                                       ' ,& '  Sample commands                                                              ' ,& '                                                                               ' ,& '     cmd|tat -chars 132 -prefix \"<B><w>\"                                       ' ,& '     tat \"<clear><B><w><bo><CSI>12;36f Good Morning!\"                          ' ,& '     tat --chars 80 --prefix \"<B><w>\"                                          ' ,& 'LIMITATIONS                                                                    ' ,& 'AUTHOR                                                                         ' ,& '   John S. Urban                                                               ' ,& 'LICENSE                                                                        ' ,& '   MIT                                                                         ' ,& '' ] version_text = [ character ( len = 80 ) :: & 'PRODUCT:        GPF (General Purpose Fortran) utilities and examples           ' ,& 'PROGRAM:        tat(1)                                                         ' ,& 'DESCRIPTION:    filter applies terminal attributes as defined by M_attr(3f)    ' ,& 'VERSION:        1.0, 20210801                                                  ' ,& 'AUTHOR:         John S. Urban                                                  ' ,& 'REPORTING BUGS: http://www.urbanjost.altervista.org/                           ' ,& 'HOME PAGE:      http://www.urbanjost.altervista.org/index.html                 ' ,& 'LICENSE:        MIT' ] end subroutine setup","tags":"","loc":"proc/setup.html"},{"title":"ranf – M_attr","text":"function ranf() result(r) Arguments None Return Value real Contents Variables already_run Source Code ranf Variables Type Visibility Attributes Name Initial logical, public, SAVE :: already_run = .TRUE. Source Code FUNCTION ranf () result ( r ) IMPLICIT NONE REAL :: r LOGICAL , SAVE :: already_run = . TRUE . IF (. NOT . already_run ) THEN CALL init_random_seed_by_clock () already_run = . TRUE . ENDIF CALL random_number ( r ) END FUNCTION ranf","tags":"","loc":"proc/ranf.html"},{"title":"init_random_seed_by_clock – M_attr","text":"subroutine init_random_seed_by_clock() Arguments None Contents Variables clock i n seed Source Code init_random_seed_by_clock Variables Type Visibility Attributes Name Initial integer, public :: clock integer, public :: i integer, public :: n integer, public, DIMENSION(:), ALLOCATABLE :: seed Source Code SUBROUTINE init_random_seed_by_clock () implicit none INTEGER :: i , n , clock INTEGER , DIMENSION (:), ALLOCATABLE :: seed CALL RANDOM_SEED ( size = n ) ALLOCATE ( seed ( n )) CALL SYSTEM_CLOCK ( COUNT = clock ) seed = clock + 37 * ( / ( i - 1 , i = 1 , n ) / ) CALL RANDOM_SEED ( PUT = seed ) DEALLOCATE ( seed ) END SUBROUTINE init_random_seed_by_clock","tags":"","loc":"proc/init_random_seed_by_clock.html"},{"title":"printme – M_attr","text":"subroutine printme(mymode) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: mymode Contents Source Code printme Source Code subroutine printme ( mymode ) character ( len =* ), intent ( in ) :: mymode call attr_mode ( mymode ) write ( * , '(a)' ) mymode write ( * , '(a)' ) attr ( '<ERROR>Woe is nigh.' ) write ( * , '(a)' ) attr ( '<WARNING>The night is young.' ) write ( * , '(a)' ) attr ( '<INFO>It is Monday' ) end subroutine printme","tags":"","loc":"proc/printme.html"},{"title":"printstuff – M_attr","text":"subroutine printstuff(label) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: label Contents Variables array Source Code printstuff Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: array (:) Source Code subroutine printstuff ( label ) character ( len =* ), intent ( in ) :: label character ( len = :), allocatable :: array (:) call attr_mode ( manner = label ) array = [ character ( len = 60 ) :: & 'TEST MANNER=' // label , & '<r>RED</r>,<g>GREEN</g>,<b>BLUE</b>' , & '<c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y>' , & '<w>WHITE</w> and <e>EBONY</e>' ] write ( * , '(a)' ) attr ( array ) write ( * , '(a)' ) attr ( 'Adding <bo>bold</bo>' ) write ( * , '(a)' ) attr ( '<bo><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></bo>' ) write ( * , '(a)' ) attr ( '<bo><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y></bo>' ) write ( * , '(a)' ) attr ( '<bo><w>WHITE</w> and <e>EBONY</e></bo>' ) write ( * , '(a)' ) attr ( 'Adding <ul>underline</ul>' ) write ( * , '(a)' ) attr (& & '<bo><ul><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></ul></bo>' ) write ( * , '(a)' ) attr (& & '<bo><ul><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><w>WHITE</w> and <e>EBONY</e></ul></bo>' ) write ( * , '(a)' ) attr ( 'Adding <ul>italic</ul>' ) write ( * , '(a)' ) attr (& & '<bo><ul><it><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></it></ul></bo>' ) write ( * , '(a)' ) attr (& & '<bo><ul><it><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</it></y></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><it><w>WHITE</w> and <e>EBONY</e></ul></bo>' ) write ( * , '(a)' ) attr ( 'Adding <in>inverse</in>' ) write ( * , '(a)' ) attr ( '<in><bo><ul><it><r>RED</r>,<g>GREEN</g>,& &<b>BLUE</b></it></ul></bo></in>' ) write ( * , '(a)' ) attr ( '<in><bo><ul><it><c>CYAN</c>,<m>MAGENTA</g>,& &<y>YELLOW</it></y></ul></bo></in>' ) write ( * , '(a)' ) attr (& & '<in><bo><ul><it><w>WHITE</w> and <e>EBONY</e></ul></bo></in>' ) end subroutine printstuff","tags":"","loc":"proc/printstuff.html"},{"title":"paws – M_attr","text":"subroutine paws() Arguments None Contents Variables ios letter Source Code paws Variables Type Visibility Attributes Name Initial integer, public :: ios character(len=1), public :: letter Source Code subroutine paws () character ( len = 1 ) :: letter integer :: ios write ( stdout , '(a)' , advance = 'no' , iostat = ios ) 'Enter [RETURN] to continue ...' read ( * , '(a)' , iostat = ios ) letter write ( stdout , '(a)' ) attr ( '<clear>' ) flush ( unit = stdout , iostat = ios ) end subroutine paws","tags":"","loc":"proc/paws.html"},{"title":"printstuff – M_attr","text":"subroutine printstuff() Arguments None Contents Source Code printstuff Source Code subroutine printstuff () write ( * , '(a)' ) attr ( '<r>RED</r>,<g>GREEN</g>,<b>BLUE</b>' ) write ( * , '(a)' ) attr ( '<c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y>' ) write ( * , '(a)' ) attr ( '<w>WHITE</w> and <e>EBONY</e>' ) write ( * , '(a)' ) attr ( 'Adding <bo>bold</bo>' ) write ( * , '(a)' ) attr ( '<bo><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></bo>' ) write ( * , '(a)' ) attr ( '<bo><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y></bo>' ) write ( * , '(a)' ) attr ( '<bo><w>WHITE</w> and <e>EBONY</e></bo>' ) write ( * , '(a)' ) attr ( 'Adding <ul>underline</ul>' ) write ( * , '(a)' ) attr ( '<bo><ul><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><w>WHITE</w> and <e>EBONY</e></ul></bo>' ) write ( * , '(a)' ) attr ( 'Adding <ul>italic</ul>' ) write ( * , '(a)' ) attr ( '<bo><ul><it><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></it></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><it><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</it></y></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><it><w>WHITE</w> and <e>EBONY</e></ul></bo>' ) write ( * , '(a)' ) attr ( 'Adding <in>inverse</in>' ) write ( * , '(a)' ) attr ( '<in><bo><ul><it><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></it></ul></bo></in>' ) write ( * , '(a)' ) attr ( '<in><bo><ul><it><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</it></y></ul></bo></in>' ) write ( * , '(a)' ) attr ( '<in><bo><ul><it><w>WHITE</w> and <e>EBONY</e></ul></bo></in>' ) end subroutine printstuff","tags":"","loc":"proc/printstuff~2.html"},{"title":"test_alert – M_attr","text":"public subroutine test_alert() Arguments None Contents Source Code test_alert Source Code subroutine test_alert () call unit_check_start ( 'alert' , ' ' // OPTIONS ) !call unit_check('alert',targetline.eq.'a b ab baaa aaCCCC CCCC CCCC a a a aa aaaaaa','example of using RANGE',targetline) call unit_check_done ( 'alert' ) end subroutine test_alert","tags":"","loc":"proc/test_alert.html"},{"title":"test_attr – M_attr","text":"public subroutine test_attr() Arguments None Contents Variables allpassed Functions test Source Code test_attr Variables Type Visibility Attributes Name Initial logical, public :: allpassed Functions function test(in, ExpectedResult) result(Passed) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: in character(len=*), intent(in) :: ExpectedResult Return Value logical Source Code subroutine test_attr () logical :: allpassed call unit_check_start ( 'attr' , ' -description display text with attributes' // OPTIONS ) allpassed = . true . call attr_mode ( 'color' ) allpassed = test ( '<red>red' , esc // '[31mred' // esc // '[0m' ) . and . allpassed allpassed = test ( '<green>green' , esc // '[32mgreen' // esc // '[0m' ) . and . allpassed allpassed = test ( '<blue>blue' , esc // '[34mblue' // esc // '[0m' ) . and . allpassed allpassed = test ( '<cyan>cyan' , esc // '[36mcyan' // esc // '[0m' ) . and . allpassed allpassed = test ( '<magenta>magenta' , esc // '[35mmagenta' // esc // '[0m' ) . and . allpassed allpassed = test ( '<yellow>yellow' , esc // '[33myellow' // esc // '[0m' ) . and . allpassed allpassed = test ( '<ebony>ebony' , esc // '[30mebony' // esc // '[0m' ) . and . allpassed allpassed = test ( '<white>white' , esc // '[37mwhite' // esc // '[0m' ) . and . allpassed allpassed = test ( '<RED>RED' , esc // '[41mRED' // esc // '[0m' ) . and . allpassed allpassed = test ( '<GREEN>GREEN' , esc // '[42mGREEN' // esc // '[0m' ) . and . allpassed allpassed = test ( '<BLUE>BLUE' , esc // '[44mBLUE' // esc // '[0m' ) . and . allpassed allpassed = test ( '<CYAN>CYAN' , esc // '[46mCYAN' // esc // '[0m' ) . and . allpassed allpassed = test ( '<MAGENTA>MAGENTA' , esc // '[45mMAGENTA' // esc // '[0m' ) . and . allpassed allpassed = test ( '<YELLOW>YELLOW' , esc // '[43mYELLOW' // esc // '[0m' ) . and . allpassed allpassed = test ( '<EBONY>EBONY' , esc // '[40mEBONY' // esc // '[0m' ) . and . allpassed allpassed = test ( '<WHITE>WHITE' , esc // '[47mWHITE' // esc // '[0m' ) . and . allpassed call attr_mode ( 'plain' ) allpassed = test ( '<red>red' , 'red' ) . and . allpassed allpassed = test ( '<green>green' , 'green' ) . and . allpassed allpassed = test ( '<blue>blue' , 'blue' ) . and . allpassed allpassed = test ( '<cyan>cyan' , 'cyan' ) . and . allpassed allpassed = test ( '<magenta>magenta' , 'magenta' ) . and . allpassed allpassed = test ( '<yellow>yellow' , 'yellow' ) . and . allpassed allpassed = test ( '<ebony>ebony' , 'ebony' ) . and . allpassed allpassed = test ( '<white>white' , 'white' ) . and . allpassed allpassed = test ( '<RED>RED' , 'RED' ) . and . allpassed allpassed = test ( '<GREEN>GREEN' , 'GREEN' ) . and . allpassed allpassed = test ( '<BLUE>BLUE' , 'BLUE' ) . and . allpassed allpassed = test ( '<CYAN>CYAN' , 'CYAN' ) . and . allpassed allpassed = test ( '<MAGENTA>MAGENTA' , 'MAGENTA' ) . and . allpassed allpassed = test ( '<YELLOW>YELLOW' , 'YELLOW' ) . and . allpassed allpassed = test ( '<EBONY>EBONY' , 'EBONY' ) . and . allpassed allpassed = test ( '<WHITE>WHITE' , 'WHITE' ) . and . allpassed call attr_mode ( 'raw' ) allpassed = test ( '<red>red' , '<red>red' ) . and . allpassed allpassed = test ( '<green>green' , '<green>green' ) . and . allpassed allpassed = test ( '<blue>blue' , '<blue>blue' ) . and . allpassed allpassed = test ( '<cyan>cyan' , '<cyan>cyan' ) . and . allpassed allpassed = test ( '<magenta>magenta' , '<magenta>magenta' ) . and . allpassed allpassed = test ( '<yellow>yellow' , '<yellow>yellow' ) . and . allpassed allpassed = test ( '<ebony>ebony' , '<ebony>ebony' ) . and . allpassed allpassed = test ( '<white>white' , '<white>white' ) . and . allpassed allpassed = test ( '<RED>RED' , '<RED>RED' ) . and . allpassed allpassed = test ( '<GREEN>GREEN' , '<GREEN>GREEN' ) . and . allpassed allpassed = test ( '<BLUE>BLUE' , '<BLUE>BLUE' ) . and . allpassed allpassed = test ( '<CYAN>CYAN' , '<CYAN>CYAN' ) . and . allpassed allpassed = test ( '<MAGENTA>MAGENTA' , '<MAGENTA>MAGENTA' ) . and . allpassed allpassed = test ( '<YELLOW>YELLOW' , '<YELLOW>YELLOW' ) . and . allpassed allpassed = test ( '<EBONY>EBONY' , '<EBONY>EBONY' ) . and . allpassed allpassed = test ( '<WHITE>WHITE' , '<WHITE>WHITE' ) . and . allpassed call unit_check ( 'attr' , allpassed , msg = 'basic colors passed foreground and background' ) call unit_check_done ( 'attr' ) contains function test ( in , ExpectedResult ) result ( passed ) character ( len =* ), intent ( in ) :: in character ( len =* ), intent ( in ) :: ExpectedResult logical :: Passed passed = attr ( in ). eq . ExpectedResult if (. false .) then if ( passed ) then write ( std_error , * ) \"Passed on \" , in , \" converted to \" , ExpectedResult else write ( std_error , * ) \"Failed on \" , in , \" got \" , attr ( in ), \" Expect \" , ExpectedResult endif endif end function test end subroutine test_attr","tags":"","loc":"proc/test_attr.html"},{"title":"test_attr_mode – M_attr","text":"public subroutine test_attr_mode() Arguments None Contents Variables expected_color expected_plain in Source Code test_attr_mode Variables Type Visibility Attributes Name Initial character(len=*), public, parameter :: expected_color = esc//'[44m'//esc//'[1mHello!'//esc//'[22m'//esc//'[49m '//esc//'[42m'//esc//'[33mHello Again!'//esc//'[39m'//esc//'[49m'//esc//'[0m' character(len=*), public, parameter :: expected_plain = 'Hello! Hello Again!' character(len=*), public, parameter :: in = ' Hello! Hello Again! ' Source Code subroutine test_attr_mode () character ( len =* ), parameter :: in = '<B><bo>Hello!</bo></B> <G><y>Hello Again!</y></G>' character ( len =* ), parameter :: expected_color = & & esc // '[44m' // esc // '[1mHello!' // & & esc // '[22m' // esc // '[49m ' // esc // '[42m' // esc // '[33mHello Again!' // & & esc // '[39m' // esc // '[49m' // esc // '[0m' character ( len =* ), parameter :: expected_plain = 'Hello! Hello Again!' call unit_check_start ( 'attr_mode' , ' ' // OPTIONS ) call attr_mode ( manner = 'color' ) call unit_check ( 'attr_mode' , attr ( in ). eq . expected_color , 'color' ) call attr_mode ( manner = 'plain' ) call unit_check ( 'attr_mode' , attr ( in ). eq . expected_plain , 'plain' ) call attr_mode ( manner = 'raw' ) call unit_check ( 'attr_mode' , attr ( in ). eq . in , 'raw' ) call unit_check_done ( 'attr_mode' ) end subroutine test_attr_mode","tags":"","loc":"proc/test_attr_mode.html"},{"title":"test_attr_update – M_attr","text":"public subroutine test_attr_update() Arguments None Contents Variables in out Source Code test_attr_update Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: in character(len=:), public, allocatable :: out Source Code subroutine test_attr_update () character ( len = :), allocatable :: in character ( len = :), allocatable :: out call unit_check_start ( 'attr_update' , ' ' // OPTIONS ) if ( unit_check_level . gt . 0 ) then endif call attr_mode ( manner = 'color' ) call attr_update ( '/b' , '>>>>' ) call attr_update ( 'b' , '<<<<' ) call attr_update ( 'blink' , esc // '[5m' ) call attr_update ( '/blink' , esc // '[25m' ) call attr_update ( 'mono' , attr ( '<esc>]11;black<bel><esc>]10;white<bel>' )) ! change default bg and fg call attr_update ( '/r' ) call attr_update ( 'r' ) in = attr ( '<blink>blink!</blink> stare!' ) out = esc // '[5mblink!' // esc // '[25m stare!' // esc // '[0m' call unit_check ( 'attr_update' , in . eq . out , 'add blink, in=' , in , 'out=' , attr ( in ), 'expect=' , out ) in = attr ( '<r>red removed</r>' ) out = '<r>red removed</r>' call unit_check ( 'attr_update' , in . eq . out , 'in=' , in , 'out=' , attr ( in ), 'expect=' , out ) in = attr ( '<b>blue replaced</b>' ) out = '<<<<blue replaced>>>>' call unit_check ( 'attr_update' , in . eq . out , 'in=' , in , 'out=' , attr ( in ), 'expect=' , out ) call unit_check_done ( 'attr_update' ) end subroutine test_attr_update","tags":"","loc":"proc/test_attr_update.html"},{"title":"test_suite_m_attr – M_attr","text":"public subroutine test_suite_m_attr() Arguments None Contents Source Code test_suite_m_attr Source Code subroutine test_suite_m_attr () call test_attr () call test_attr_mode () call test_attr_update () call test_alert () end subroutine test_suite_m_attr","tags":"","loc":"proc/test_suite_m_attr.html"},{"title":"M_attr – M_attr","text":"NAME M_attr(3f) - [M_attr::INTRO] control text attributes on terminals\n(LICENSE:MIT) SYNOPSIS use M_attr, only : attr, attr_mode, attr_update\n\n  use M_attr, only : alert ! generate standard messages DESCRIPTION M_attr(3f) is a Fortran module that uses common ANSI escape sequences\nto control terminal text attributes.\n\n     use M_attr\n     write(*,*)attr(' <red> Red Text! </red> <green> Green Text! </green> ')\n     end\n\nIt is designed to use three simple procedures to\n\n + Specify attributes using simple HTML-like syntax\n + allow the sequences to be suppressed when desired\n + permit the  user program to completely customize the keywords.\n   The user can add, delete and replace the sequences associated with\n   a keyword without changing the code.\n\nOne advantage of the approach of using formatting directives which\nare replaced with in-band escape sequences is that it is easy to turn\noff when running batch.\n\nAnother important capability is that programs can be run in \"raw\" mode\nand create a simple text file with the formatting directives in it\nthat can then be read back in by a simple filter program that strips\nit back to plain text( see app/plain.f90), or displays it to a screen\nin color(see app/light.f90) or perhaps converts it to another format.\n\nSo this approach makes it trivial to read specially-formatted data\nfrom a file like a message catalog (perhaps with various versions\nin different languages) and colorize it or display it as plain text\n\nBy making each line self-contained (by default) lines can be filtered\nby external utilities and still display correctly. ACCESS Via git ( 1 ) : git clone https : // github . com / urbanjost / M_attr . git cd M_attr / src # change Makefile if not using one of the listed compilers make clean ; make gfortran # for gfortran make clean ; make ifort # for ifort make clean ; make nvfortran # for nvfortran This will compile the M_attr module and example programs . Alternatively , via fpm ( described at https : // github . com / fortran - lang / fpm ) : git clone https : // github . com / urbanjost / M_attr . git or just list it as a dependency in your fpm . toml project file . [ dependencies ] M_attr = { git = \"https://github.com/urbanjost/M_attr.git\" } LIMITATIONS o colors are not nestable.\n   o keywords are case-sensitive,\n   o ANSI escape sequences are not universally supported by\n     all terminal emulators; and normally should be suppressed\n     when not going to a tty device. Therefore, you should use\n     M_system::system_istty(3f) or the common Fortran extension\n     ISATTY() to set the default to “plain” instead of “color”\n     when the output file is not a conforming terminal. On basic\n     MSWindows console windows, it is best to use Windows 10+ and/or\n     the Linux mode; you may have to enable ANSI escape sequence\n     mode on MSWindows. It does work as-is with CygWin and MinGW and\n     Putty windows and mintty(1) as tested. EXAMPLE Sample program\n\n program demo_M_attr\n use M_attr, only : attr, attr_mode, attr_update, alert\n implicit none\n character(len=256) :: line\n character(len=*),parameter :: f='( & & \" <bo><w><G> GREAT: </G></w> & & The new value <Y><b> \",f8.4,1x,\" </b></Y> is in range\" & & )'\n real :: value\n\n    write(*,'(a)') & & attr(' <r><W><bo> ERROR: </W> red text on a white background </y> ')\n\n    value=3.4567\n    write(line,fmt=f) value\n    write(*,'(a)')attr(trim(line))\n\n    ! write same string as plain text\n    write(*,*)\n    call attr_mode(manner='plain')\n    write(*,'(a)')attr(trim(line))\n\n    call attr_mode(manner='color')\n    ! use pre-defined or user defined strings\n    write(*,*)\n    write(*,'(a)')attr(' <ERROR> Woe is nigh.')\n    write(*,'(a)')attr(' <WARNING> The night is young.')\n    write(*,'(a)')attr(' <INFO> It is Monday')\n\n    call alert(' <ERROR> ', 'Woe is nigh.')\n    call alert(' <WARNING> ', 'The night is young.')\n    call alert(' <INFO> ', 'It is Monday')\n\n    ! create a custom mnemonic\n    call attr_update('MYERROR',attr( & ' <R><e> E <w> - <e> R <w> - <e> R <w> - <e> O <w> - <e> R: </e></R></bo> ' & ))\n    write(*,*)\n    write(*,'(a)')attr(' <MYERROR> my custom message style')\n\n end program demo_M_attr AUTHOR John S. Urban, 2021 LICENSE MIT SEE ALSO attr(3f), attr_mode(3f), attr_update(3f)\n\nRelated information:\n\n terminfo(3c), termlib(3c), tput(1), reset(1), clear(1),\n console_codes(4), ECMA-48,\n https://en.wikipedia.org/wiki/ANSI_escape_code Uses iso_fortran_env iso_c_binding Contents Variables bg_black bg_blue bg_cyan bg_default bg_ebony bg_green bg_magenta bg_red bg_white bg_yellow bold clear fg_black fg_blue fg_cyan fg_default fg_ebony fg_green fg_magenta fg_red fg_white fg_yellow inverse italic reset unbold underline uninverse unitalic ununderline Interfaces advice attr Subroutines alert attr_mode attr_update Variables Type Visibility Attributes Name Initial character(len=*), public, parameter :: bg_black = CODE_START//BG//BLACK//CODE_END character(len=*), public, parameter :: bg_blue = CODE_START//BG//BLUE//CODE_END character(len=*), public, parameter :: bg_cyan = CODE_START//BG//CYAN//CODE_END character(len=*), public, parameter :: bg_default = CODE_START//BG//DEFAULT//CODE_END character(len=*), public, parameter :: bg_ebony = CODE_START//BG//BLACK//CODE_END character(len=*), public, parameter :: bg_green = CODE_START//BG//GREEN//CODE_END character(len=*), public, parameter :: bg_magenta = CODE_START//BG//MAGENTA//CODE_END character(len=*), public, parameter :: bg_red = CODE_START//BG//RED//CODE_END character(len=*), public, parameter :: bg_white = CODE_START//BG//WHITE//CODE_END character(len=*), public, parameter :: bg_yellow = CODE_START//BG//YELLOW//CODE_END character(len=*), public, parameter :: bold = CODE_START//ON//AT_BOLD//CODE_END character(len=*), public, parameter :: clear = HOME_DISPLAY//CLEAR_DISPLAY character(len=*), public, parameter :: fg_black = CODE_START//FG//BLACK//CODE_END character(len=*), public, parameter :: fg_blue = CODE_START//FG//BLUE//CODE_END character(len=*), public, parameter :: fg_cyan = CODE_START//FG//CYAN//CODE_END character(len=*), public, parameter :: fg_default = CODE_START//FG//DEFAULT//CODE_END character(len=*), public, parameter :: fg_ebony = CODE_START//FG//BLACK//CODE_END character(len=*), public, parameter :: fg_green = CODE_START//FG//GREEN//CODE_END character(len=*), public, parameter :: fg_magenta = CODE_START//FG//MAGENTA//CODE_END character(len=*), public, parameter :: fg_red = CODE_START//FG//RED//CODE_END character(len=*), public, parameter :: fg_white = CODE_START//FG//WHITE//CODE_END character(len=*), public, parameter :: fg_yellow = CODE_START//FG//YELLOW//CODE_END character(len=*), public, parameter :: inverse = CODE_START//ON//AT_INVERSE//CODE_END character(len=*), public, parameter :: italic = CODE_START//ON//AT_ITALIC//CODE_END character(len=*), public, parameter :: reset = CODE_RESET character(len=*), public, parameter :: unbold = CODE_START//'22'//CODE_END character(len=*), public, parameter :: underline = CODE_START//ON//AT_UNDERLINE//CODE_END character(len=*), public, parameter :: uninverse = CODE_START//OFF//AT_INVERSE//CODE_END character(len=*), public, parameter :: unitalic = CODE_START//OFF//AT_ITALIC//CODE_END character(len=*), public, parameter :: ununderline = CODE_START//OFF//AT_UNDERLINE//CODE_END Interfaces public interface advice public subroutine alert (type, message, g0, g1, g2, g3, g4, g5, g6, g7, g8, g9, ga, gb, gc, gd, ge, gf, gg, gh, gi, gj) !> Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: type character(len=*), intent(in), optional :: message class(*), intent(in), optional :: g0 class(*), intent(in), optional :: g1 class(*), intent(in), optional :: g2 class(*), intent(in), optional :: g3 class(*), intent(in), optional :: g4 class(*), intent(in), optional :: g5 class(*), intent(in), optional :: g6 class(*), intent(in), optional :: g7 class(*), intent(in), optional :: g8 class(*), intent(in), optional :: g9 class(*), intent(in), optional :: ga class(*), intent(in), optional :: gb class(*), intent(in), optional :: gc class(*), intent(in), optional :: gd class(*), intent(in), optional :: ge class(*), intent(in), optional :: gf class(*), intent(in), optional :: gg class(*), intent(in), optional :: gh class(*), intent(in), optional :: gi class(*), intent(in), optional :: gj public interface attr private function attr_scalar(string, reset) result(expanded) Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string logical, intent(in), optional :: reset Return Value character(len=:),\n  allocatable private function attr_matrix(strings, reset, chars) result(expanded) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: strings (:) logical, intent(in), optional :: reset integer, intent(in), optional :: chars Return Value character(len=:),\n  allocatable, (:) private function attr_scalar_width(string, reset, chars) result(expanded) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string logical, intent(in), optional :: reset integer, intent(in) :: chars Return Value character(len=:),\n  allocatable Subroutines public subroutine alert (type, message, g0, g1, g2, g3, g4, g5, g6, g7, g8, g9, ga, gb, gc, gd, ge, gf, gg, gh, gi, gj) !> Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: type character(len=*), intent(in), optional :: message class(*), intent(in), optional :: g0 class(*), intent(in), optional :: g1 class(*), intent(in), optional :: g2 class(*), intent(in), optional :: g3 class(*), intent(in), optional :: g4 class(*), intent(in), optional :: g5 class(*), intent(in), optional :: g6 class(*), intent(in), optional :: g7 class(*), intent(in), optional :: g8 class(*), intent(in), optional :: g9 class(*), intent(in), optional :: ga class(*), intent(in), optional :: gb class(*), intent(in), optional :: gc class(*), intent(in), optional :: gd class(*), intent(in), optional :: ge class(*), intent(in), optional :: gf class(*), intent(in), optional :: gg class(*), intent(in), optional :: gh class(*), intent(in), optional :: gi class(*), intent(in), optional :: gj public subroutine attr_mode (manner) !> Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: manner public subroutine attr_update (key, valin, mono_valin) !> Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: key character(len=*), intent(in), optional :: valin character(len=*), intent(in), optional :: mono_valin","tags":"","loc":"module/m_attr.html"},{"title":"M_testsuite_M_attr – M_attr","text":"Uses iso_fortran_env M_verify M_attr Contents Variables esc options Subroutines test_alert test_attr test_attr_mode test_attr_update test_suite_m_attr Variables Type Visibility Attributes Name Initial character(len=1), public, parameter :: esc = char(27) character(len=*), public, parameter :: options = ' -section 3 -library libGPF -filename `pwd`/m_attr.FF  -documentation y -ufpp   y -ccall  n -archive  GPF.a ' Subroutines public subroutine test_alert () Arguments None public subroutine test_attr () Arguments None public subroutine test_attr_mode () Arguments None public subroutine test_attr_update () Arguments None public subroutine test_suite_m_attr () Arguments None","tags":"","loc":"module/m_testsuite_m_attr.html"},{"title":"roots – M_attr","text":"Uses iso_fortran_env M_attr Contents Variables TERM a b buffer c discriminant dp ios message numbers paws x x1 x2 x_complex x_real Functions system_getenv system_isatty Subroutines text Source Code roots Variables Type Attributes Name Initial character(len=:), allocatable :: TERM real(kind=dp) :: a real(kind=dp) :: b character(len=1024) :: buffer real(kind=dp) :: c real(kind=dp) :: discriminant integer, parameter :: dp = kind(0.0d0) integer :: ios character(len=256) :: message character(len=*), parameter :: numbers = '(\" \",*(\"(\",g0.8,\",\",g0.8,\")\":,1x))' character(len=1) :: paws real(kind=dp) :: x real(kind=dp) :: x1 real(kind=dp) :: x2 real(kind=dp) :: x_complex real(kind=dp) :: x_real Functions function system_getenv (name, default) result(value) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name character(len=*), intent(in), optional :: default Return Value character(len=:),\n  allocatable function system_isatty (lun) call compiler-specific ISATTY() function or return .FALSE. Arguments Type Intent Optional Attributes Name integer, intent(in) :: lun Return Value logical Subroutines subroutine text (string) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: string Source Code program roots use , intrinsic :: iso_fortran_env , only : stdin => input_unit , stdout => output_unit , stderr => error_unit use M_attr , only : attr , attr_mode , attr_update ! Calculate and print the roots of a quadratic formula even if they are complex implicit none integer , parameter :: dp = kind ( 0.0d0 ) real ( kind = dp ) :: a , b , c , discriminant real ( kind = dp ) :: x1 , x2 , x ! Real roots of the equation real ( kind = dp ) :: x_real ! Real part of complex root of the equation REAL ( kind = dp ) :: x_complex ! Imaginary part of complex root of the equation character ( len = 256 ) :: message integer :: ios character ( len = 1 ) :: paws character ( len = 1024 ) :: buffer character ( len =* ), parameter :: numbers = '(\"<B><w><bo>   \",*(\"(\",g0.8,\",\",g0.8,\")\":,1x))' character ( len = :), allocatable :: TERM if ( system_isatty ( stdout )) then ! ISATTY() is an extension, but found in Intel, GNU, PGI, ... compiler call attr_mode ( 'color' ) else call attr_mode ( 'plain' ) endif TERM = system_getenv ( 'TERM' , 'vt102' ) ! perhaps change or add strings based on terminal type select case ( TERM ) case ( 'xterm' ) call attr_update ( 'mono' , attr ( '<esc>]11;black<bel><esc>]10;white<bel>' )) ! change default bg and fg case ( 'screen' ) end select INFINITE : do ! clear screen, set attributes and print messages call text ( \"<reset><clear>\" ) call text ( \"For the quadratic equation <m>A</m><g>*x**2 +<m>B</m><g>*x + <m>C</m> \" ) write ( stdout , '(*(a))' , advance = 'no' ) & & attr ( '<B><w><bo>' , chars = 80 ), & & char ( 13 ),& & attr ( '<B><g><bo>enter coefficients <m>A,B,C</m><g>:<y><gt><ul>' ,& & reset = . false ., chars = 80 ) read ( stdin , * , iostat = ios , iomsg = message ) a , b , c write ( stdout , '(a)' , advance = 'no' ) attr ( '<reset>' ) if ( ios . ne . 0 ) then write ( stdout , * ) write ( stdout , '(*(g0))' ) ios , ' ' , trim ( message ) rewind ( unit = stdin , iostat = ios ) backspace ( unit = stdin , iostat = ios ) else ! Given the equation \"A*X**2 + B*X + C = 0\" ! Use the quadratic formula to determine the root values of the equation. ! prompt for new value call text () call text ( 'Given the equation' ) call text () write ( buffer , '(*(g0.8))' ) '<B><w><bo>   ' , a , '<m>*X**2</m><w> + ' , b , '<m>*X</m><w> + ' , c , ' = 0' call text ( buffer ) call text () discriminant = b ** 2 - 4 * a * c if ( a . eq . 0 ) then call text ( '<ERROR> <m>If <m>a</m><g> is zero this is a linear, not quadratic equation' ) elseif ( discriminant > 0 ) then call text ( 'the <m>roots</m><g> (ie. \"x intercepts\") are <m>real<m><g> so the parabola ' ) call text ( 'crosses the x-axis at <m>two points</m><g>:' ) call text () x1 = ( - b + sqrt ( discriminant )) / ( 2 * a ) x2 = ( - b - sqrt ( discriminant )) / ( 2 * a ) write ( buffer , numbers ) x1 , 0.0d0 call text ( buffer ) write ( buffer , numbers ) x2 , 0.0d0 call text ( buffer ) call text () elseif ( discriminant == 0 ) then call text ( 'the <m>roots</m><g> (ie. \"x intercepts\") are repeated <m>(real and equal)</m><g>' ) call text ( 'so the parabola just touches the x-axis at:' ) call text () if ( b . ne . 0 ) then x = ( - b ) / ( 2 * a ) else x = 0.0d0 endif write ( buffer , numbers ) x , 0.0d0 call text ( buffer ) call text () else call text ( 'the <m>roots</m><g>(ie. \"x intercepts\")  are <m>complex</m><g>:' ) x_real = ( - b ) / ( 2 * a ) x_complex = sqrt ( abs ( discriminant )) / ( 2 * a ) call text () WRITE ( buffer , '(a,*(\"(\",g0.8,\", +i\",g0.8,\")\",:,1x))' ) '<B><w><bo>   ' , x_real , x_complex call text ( buffer ) WRITE ( buffer , '(a,*(\"(\",g0.8,\", -i\",g0.8,\")\",:,1x))' ) '<B><w><bo>   ' , x_real , x_complex call text ( buffer ) call text () endif call text ( 'with' ) call text () write ( buffer , '(g0,*(g0.8,1x))' ) \"<B><w><bo>   <m>discriminate</m><w> = \" , discriminant call text ( buffer ) call text () endif write ( stdout , '(*(g0))' , advance = 'no' ) attr ( '<B><e>press <g>return</g><e> to continue, \"<g>q</g><e>\" to quit:' , chars = 79 ) read ( stdin , advance = 'yes' , iostat = ios , fmt = '(a)' , iomsg = message ) paws if ( paws . ne . '' ) exit INFINITE enddo INFINITE contains subroutine text ( string ) character ( len =* ), intent ( in ), optional :: string if ( present ( string )) then write ( stdout , '(*(g0))' ) attr ( '<B><g><bo>' // trim ( string ), chars = 80 ) else write ( stdout , '(*(g0))' ) attr ( '<B><g><bo>' , chars = 80 ) endif end subroutine text !>  call compiler-specific ISATTY() function or return .FALSE. #undef ISATTY #ifdef __INTEL_COMPILER function system_isatty ( lun ) use IFPORT integer , intent ( in ) :: lun logical :: system_isatty system_isatty = isatty ( lun ) end function system_isatty #define ISATTY #endif #ifdef __NVCOMPILER_MAJOR__X ! __NVCOMPILER_MAJOR__ __NVCOMPILER_MINOR__ __NVCOMPILER_PATCHLEVEL__ function system_isatty ( lun ) use DFPORT integer , intent ( in ) :: lun logical :: system_isatty system_isatty = isatty ( lun ) end function system_isatty #define ISATTY #endif #ifdef __GFORTRAN__ function system_isatty ( lun ) integer , intent ( in ) :: lun logical :: system_isatty system_isatty = isatty ( lun ) end function system_isatty #define ISATTY #endif #ifndef ISATTY function system_isatty ( lun ) integer , intent ( in ) :: lun logical :: system_isatty system_isatty = . false . end function system_isatty #define ISATTY #endif function system_getenv ( name , default ) result ( value ) !$@(#) M_system::system_getenv(3f): call get_environment_variable as a function with a default value(3f) character ( len =* ), intent ( in ) :: name character ( len =* ), intent ( in ), optional :: default integer :: howbig integer :: stat character ( len = :), allocatable :: value if ( NAME . ne . '' ) then call get_environment_variable ( name , length = howbig , status = stat , trim_name = . true .) ! get length required to hold value if ( howbig . ne . 0 ) then select case ( stat ) case ( 1 ) ! print *, NAME, \" is not defined in the environment. Strange...\" value = '' case ( 2 ) ! print *, \"This processor doesn't support environment variables. Boooh!\" value = '' case default ! make string to hold value of sufficient size and get value if ( allocated ( value )) deallocate ( value ) allocate ( character ( len = max ( howbig , 1 )) :: VALUE ) call get_environment_variable ( name , value , status = stat , trim_name = . true .) if ( stat . ne . 0 ) VALUE = '' end select else value = '' endif else value = '' endif if ( value . eq . '' . and . present ( default )) value = default end function system_getenv END PROGRAM roots","tags":"","loc":"program/roots.html"},{"title":"demo_attr – M_attr","text":"Uses M_attr Contents Variables expanded icount ios line Subroutines args Source Code demo_attr Variables Type Attributes Name Initial character(len=:), allocatable :: expanded integer :: icount integer :: ios character(len=1024) :: line Subroutines subroutine args () Arguments None Source Code program demo_attr ! read stdin and run it through M_attr::attr to display color use M_attr , only : attr , attr_update implicit none character ( len = 1024 ) :: line character ( len = :), allocatable :: expanded integer :: icount integer :: ios line = '' call attr_update ( 'Z' , char ( 27 ) // '[1m' ) icount = command_argument_count () ! get number of arguments ! if command arguments use those instead of reading stdin ! example: light '<clear><B><w><bo><CSI>12;36f Good Morning! ' if ( icount . gt . 0 ) then call args () else do read ( * , '(a)' , iostat = ios ) line if ( ios . ne . 0 ) exit expanded = attr ( trim ( line )) write ( * , '(a)' ) expanded enddo write ( * , '(a)' , advance = 'no' ) attr ( '<reset>' ) endif contains subroutine args () implicit none integer :: i integer :: istat integer :: argument_length character ( len = :), allocatable :: argument do i = 1 , icount call get_command_argument ( number = i , length = argument_length ) ! allocate string array big enough to hold command line argument if ( allocated ( argument )) deallocate ( argument ) allocate ( character ( len = argument_length ) :: argument ) ! read the argument call get_command_argument ( i , argument , status = istat ) expanded = attr ( trim ( argument )) write ( * , '(a)' ) expanded enddo end subroutine args end program demo_attr","tags":"","loc":"program/demo_attr.html"},{"title":"demo_attr – M_attr","text":"Uses M_attr Contents Variables ios line Source Code demo_attr Variables Type Attributes Name Initial integer :: ios character(len=1024) :: line Source Code program demo_attr ! read stdin and run it through M_attr::attr to display without color use M_attr , only : attr , attr_mode implicit none character ( len = 1024 ) :: line integer :: ios line = '' call attr_mode ( manner = 'plain' ) do read ( * , '(a)' , iostat = ios ) line if ( ios . ne . 0 ) exit write ( * , '(a)' ) attr ( trim ( line )) enddo write ( * , '(a)' , advance = 'no' ) attr ( '<reset>' ) end program demo_attr","tags":"","loc":"program/demo_attr~2.html"},{"title":"terminal_attributes – M_attr","text":"Uses M_attr M_CLI2 Contents Variables help_text i ios iwidth line prefix version_text Subroutines setup Source Code terminal_attributes Variables Type Attributes Name Initial character(len=:), allocatable :: help_text (:) integer :: i integer :: ios integer :: iwidth character(len=1024) :: line character(len=:), allocatable :: prefix character(len=:), allocatable :: version_text (:) Subroutines subroutine setup () Arguments None Source Code program terminal_attributes ! read stdin and run it through M_attr::attr to display color use M_attr , only : attr , attr_update , attr_mode use M_CLI2 , only : set_args , sget , iget , remaining , lget , unnamed , specified implicit none character ( len = 1024 ) :: line character ( len = :), allocatable :: prefix integer :: iwidth integer :: ios integer :: i character ( len = :), allocatable :: help_text (:), version_text (:) line = '' call setup () call set_args ( ' --manner \"color\" --debug F --chars 0 -prefix \" \"' , help_text , version_text ) ! if command arguments use those instead of reading stdin ! example: tat '<clear><B><w><bo><CSI>12;36f Good Morning! ' iwidth = iget ( 'chars' ) call attr_mode ( sget ( 'manner' )) if ( specified ( 'prefix' )) then prefix = sget ( 'prefix' ) else prefix = '' endif if ( lget ( 'debug' )) then write ( * , * ) 'REMAINING:' , remaining write ( * , * ) 'UNNAMED:' , unnamed write ( * , * ) 'MANNER:' , sget ( 'manner' ) write ( * , * ) 'CHARS:' , iwidth endif if ( size ( unnamed ). ne . 0 ) then do i = 1 , size ( unnamed ) write ( * , '(a)' ) attr ( unnamed ( i ), chars = iwidth ) enddo else do read ( * , '(a)' , iostat = ios ) line if ( ios . ne . 0 ) exit if ( len ( prefix ). ne . 0 ) then line = prefix // line endif write ( * , '(a)' ) attr ( trim ( line ), chars = iwidth ) enddo write ( * , '(a)' , advance = 'no' ) attr ( '<reset>' ) endif contains subroutine setup () help_text = [ character ( len = 80 ) :: & 'NAME                                                                           ' ,& '    tat(1f) - [M_attr] filter terminal attribute strings                       ' ,& '    (LICENSE:MIT)                                                              ' ,& 'SYNOPSIS                                                                       ' ,& '    tat [[string(s)][ --chars N] [ --prefix STR] [ --manner MODE] ]|           ' ,& '    [ --help| --version]                                                       ' ,& 'DESCRIPTION                                                                    ' ,& '   tat(1) (\"Terminal Attributes\") is like cat(1), except it processes          ' ,& '   special strings in the input specifying terminal attributes such as color   ' ,& '   and underlining using an HTML-like syntax via the M_attr(3f) module.        ' ,& '                                                                               ' ,& 'OPTIONS                                                                        ' ,& '   STRINGS    if present process and print these strings instead of reading    ' ,& '              and processing stdin.                                            ' ,& '   --manner   Set output mode (\"color\"|\"plain\"|\"raw\"). Default is \"color\".     ' ,& '   --chars    column to fill background color out to. Default is 0 (zero);     ' ,& '              meaning to not padd the lines. Note multi-byte character sets    ' ,& '              and non-printable characters will not work properly with this    ' ,& '              option, but typical plain ASCII will.                            ' ,& '   --prefix   string to place in from of input lines from stdin. Typically     ' ,& '              used to set background and text color, as with \"<B><w><bo>\".     ' ,& '   --help     display this help and exit                                       ' ,& '   --version  output version information and exit                              ' ,& '                                                                               ' ,& 'EXAMPLES                                                                       ' ,& '  Sample commands                                                              ' ,& '                                                                               ' ,& '     cmd|tat -chars 132 -prefix \"<B><w>\"                                       ' ,& '     tat \"<clear><B><w><bo><CSI>12;36f Good Morning!\"                          ' ,& '     tat --chars 80 --prefix \"<B><w>\"                                          ' ,& 'LIMITATIONS                                                                    ' ,& 'AUTHOR                                                                         ' ,& '   John S. Urban                                                               ' ,& 'LICENSE                                                                        ' ,& '   MIT                                                                         ' ,& '' ] version_text = [ character ( len = 80 ) :: & 'PRODUCT:        GPF (General Purpose Fortran) utilities and examples           ' ,& 'PROGRAM:        tat(1)                                                         ' ,& 'DESCRIPTION:    filter applies terminal attributes as defined by M_attr(3f)    ' ,& 'VERSION:        1.0, 20210801                                                  ' ,& 'AUTHOR:         John S. Urban                                                  ' ,& 'REPORTING BUGS: http://www.urbanjost.altervista.org/                           ' ,& 'HOME PAGE:      http://www.urbanjost.altervista.org/index.html                 ' ,& 'LICENSE:        MIT' ] end subroutine setup end program terminal_attributes","tags":"","loc":"program/terminal_attributes.html"},{"title":"demo_M_attr – M_attr","text":"Uses M_attr Contents Variables f line value Source Code demo_M_attr Variables Type Attributes Name Initial character(len=*), parameter :: f = '( \" GREAT: The new value \",f8.4,1x,\" is in range\")' character(len=256) :: line real :: value Source Code program demo_M_attr use M_attr , only : attr , attr_mode , attr_update , alert implicit none character ( len = 256 ) :: line character ( len =* ), parameter :: f = '( & &\"   <bo><w><G> GREAT: </G></w>& &The new value <Y><b>\",f8.4,1x,\"</b></Y> is in range\"& &)' real :: value write ( * , '(a)' )& & attr ( '   <r><W><bo> ERROR: </W>red text on a white background</y>' ) value = 3.4567 write ( line , fmt = f ) value write ( * , '(a)' ) attr ( trim ( line )) ! write same string as plain text write ( * , * ) call attr_mode ( manner = 'plain' ) write ( * , '(a)' ) attr ( trim ( line )) call attr_mode ( manner = 'color' ) ! use pre-defined or user defined strings write ( * , * ) write ( * , '(a)' ) attr ( '<ERROR> Woe is nigh.' ) write ( * , '(a)' ) attr ( '<WARNING> The night is young.' ) write ( * , '(a)' ) attr ( '<INFO> It is Monday' ) call alert ( '<ERROR>' , 'Woe is nigh.' ) call alert ( '<WARNING>' , 'The night is young.' ) call alert ( '<INFO>' , 'It is Monday' ) ! create a custom mnemonic call attr_update ( 'MYERROR' , attr (& ' <R><e> E<w>-<e>R<w>-<e>R<w>-<e>O<w>-<e>R: </e></R></bo>' & )) write ( * , * ) write ( * , '(a)' ) attr ( '<MYERROR> my custom message style' ) end program demo_M_attr","tags":"","loc":"program/demo_m_attr.html"},{"title":"demo_M_attr – M_attr","text":"Uses M_attr Contents Source Code demo_M_attr Source Code program demo_M_attr use M_attr , only : attr , attr_update write ( * , '(a)' ) attr ( '<clear>TEST CUSTOMIZED:' ) ! add custom keywords call attr_update ( 'blink' , char ( 27 ) // '[5m' ) call attr_update ( '/blink' , char ( 27 ) // '[25m' ) write ( * , '(a)' ) attr ( '<blink>Items for Friday</blink> not before' ) write ( * , '(a)' , advance = 'no' ) attr ( '<r>RED</r>,' ) write ( * , '(a)' , advance = 'no' ) attr ( '<b>BLUE</b>,' ) write ( * , '(a)' , advance = 'yes' ) attr ( '<g>GREEN</g>' ) ! delete call attr_update ( 'r' ) call attr_update ( '/r' ) ! replace call attr_update ( 'b' , '<<<<' ) call attr_update ( '/b' , '>>>>' ) write ( * , '(a)' , advance = 'no' ) attr ( '<r>RED</r>,' ) write ( * , '(a)' , advance = 'no' ) attr ( '<b>BLUE</b>,' ) write ( * , '(a)' , advance = 'yes' ) attr ( '<g>GREEN</g>' ) end program demo_M_attr","tags":"","loc":"program/demo_m_attr~2.html"},{"title":"dots – M_attr","text":"Uses M_attr Contents Variables bg c colors fg icount p r x y z Functions ranf Subroutines init_random_seed_by_clock Source Code dots Variables Type Attributes Name Initial integer :: bg real :: c character(len=10), parameter :: colors (8) = [character(len=10)::'RED', 'GREEN', 'BLUE', 'CYAN', 'MAGENTA', 'YELLOW', 'BLACK', 'WHITE'] integer :: fg integer :: icount character(len=1) :: p real :: r integer :: x integer :: y integer :: z Functions function ranf () result(r) Arguments None Return Value real Subroutines subroutine init_random_seed_by_clock () Arguments None Source Code program dots ! @(#) random dots on screen till ctrl-C use M_attr , only : attr implicit none integer :: x , y integer :: z character ( len = 1 ) :: p integer :: fg , bg real :: r real :: c integer :: icount character ( len = 10 ), parameter :: colors ( 8 ) = [ character ( len = 10 ) :: 'RED' , 'GREEN' , 'BLUE' , 'CYAN' , 'MAGENTA' , 'YELLOW' , 'BLACK' , 'WHITE' ] fg = 8 bg = 7 r = 80 c = 24 icount = 0 INFINITE : do x = int (( c * ranf ()) + 1 ) y = int (( r * ranf ()) + 1 ) if ( ranf () > 0.9 ) then p = \"*\" else p = \" \" endif write ( * , '(*(g0))' , advance = 'no' ) attr ( '<CSI>' , reset = . false .), x , ';' , y , 'f' , p z = min ( 8 , int ( ranf () * 8 + 1 )) write ( * , '(a)' , advance = 'no' ) attr ( '<' // trim ( colors ( z )) // '>' , reset = . false .) icount = icount + 1 write ( * , '(*(g0))' , advance = 'no' ) attr ( '<CSI>1;1f' , reset = . false .), icount if ( icount . gt . 24 * 80 * 250 ) exit enddo INFINITE write ( * , * ) attr ( \"<reset>That was two hundred and fifty pages worth of dots\" ) CONTAINS !---------------------------------------------------------------------------------------- FUNCTION ranf () result ( r ) IMPLICIT NONE REAL :: r LOGICAL , SAVE :: already_run = . TRUE . IF (. NOT . already_run ) THEN CALL init_random_seed_by_clock () already_run = . TRUE . ENDIF CALL random_number ( r ) END FUNCTION ranf !---------------------------------------------------------------------------------------- SUBROUTINE init_random_seed_by_clock () implicit none INTEGER :: i , n , clock INTEGER , DIMENSION (:), ALLOCATABLE :: seed CALL RANDOM_SEED ( size = n ) ALLOCATE ( seed ( n )) CALL SYSTEM_CLOCK ( COUNT = clock ) seed = clock + 37 * ( / ( i - 1 , i = 1 , n ) / ) CALL RANDOM_SEED ( PUT = seed ) DEALLOCATE ( seed ) END SUBROUTINE init_random_seed_by_clock !---------------------------------------------------------------------------------------- END PROGRAM dots","tags":"","loc":"program/dots.html"},{"title":"mode – M_attr","text":"Uses M_attr Contents Subroutines printme Source Code mode Subroutines subroutine printme (mymode) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: mymode Source Code program mode use M_attr , only : attr , attr_mode implicit none call printme ( 'color' ) call printme ( 'plain' ) call printme ( 'raw' ) contains subroutine printme ( mymode ) character ( len =* ), intent ( in ) :: mymode call attr_mode ( mymode ) write ( * , '(a)' ) mymode write ( * , '(a)' ) attr ( '<ERROR>Woe is nigh.' ) write ( * , '(a)' ) attr ( '<WARNING>The night is young.' ) write ( * , '(a)' ) attr ( '<INFO>It is Monday' ) end subroutine printme end program mode","tags":"","loc":"program/mode.html"},{"title":"demo_attr – M_attr","text":"Uses M_attr Contents Subroutines printstuff Source Code demo_attr Subroutines subroutine printstuff (label) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: label Source Code program demo_attr use M_attr , only : attr , attr_mode , attr_update call printstuff ( 'defaults' ) call attr_mode ( manner = 'plain' ) call printstuff ( 'plain:' ) call printstuff ( 'raw' ) call attr_mode ( manner = 'color' ) call printstuff ( '' ) write ( * , '(a)' ) attr ( 'TEST ADDING A CUSTOM SEQUENCE:' ) call attr_update ( 'blink' , char ( 27 ) // '[5m' ) call attr_update ( '/blink' , char ( 27 ) // '[25m' ) write ( * , '(a)' ) attr ( '<blink>Items for Friday</blink>' ) contains subroutine printstuff ( label ) character ( len =* ), intent ( in ) :: label character ( len = :), allocatable :: array (:) call attr_mode ( manner = label ) array = [ character ( len = 60 ) :: & 'TEST MANNER=' // label , & '<r>RED</r>,<g>GREEN</g>,<b>BLUE</b>' , & '<c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y>' , & '<w>WHITE</w> and <e>EBONY</e>' ] write ( * , '(a)' ) attr ( array ) write ( * , '(a)' ) attr ( 'Adding <bo>bold</bo>' ) write ( * , '(a)' ) attr ( '<bo><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></bo>' ) write ( * , '(a)' ) attr ( '<bo><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y></bo>' ) write ( * , '(a)' ) attr ( '<bo><w>WHITE</w> and <e>EBONY</e></bo>' ) write ( * , '(a)' ) attr ( 'Adding <ul>underline</ul>' ) write ( * , '(a)' ) attr (& & '<bo><ul><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></ul></bo>' ) write ( * , '(a)' ) attr (& & '<bo><ul><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><w>WHITE</w> and <e>EBONY</e></ul></bo>' ) write ( * , '(a)' ) attr ( 'Adding <ul>italic</ul>' ) write ( * , '(a)' ) attr (& & '<bo><ul><it><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></it></ul></bo>' ) write ( * , '(a)' ) attr (& & '<bo><ul><it><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</it></y></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><it><w>WHITE</w> and <e>EBONY</e></ul></bo>' ) write ( * , '(a)' ) attr ( 'Adding <in>inverse</in>' ) write ( * , '(a)' ) attr ( '<in><bo><ul><it><r>RED</r>,<g>GREEN</g>,& &<b>BLUE</b></it></ul></bo></in>' ) write ( * , '(a)' ) attr ( '<in><bo><ul><it><c>CYAN</c>,<m>MAGENTA</g>,& &<y>YELLOW</it></y></ul></bo></in>' ) write ( * , '(a)' ) attr (& & '<in><bo><ul><it><w>WHITE</w> and <e>EBONY</e></ul></bo></in>' ) end subroutine printstuff end program demo_attr","tags":"","loc":"program/demo_attr~3.html"},{"title":"version – M_attr","text":"Uses M_attr Contents Variables i text Source Code version Variables Type Attributes Name Initial integer :: i character(len=*), parameter :: text (23) = [character(len=132)::' ', ' ', ' LLL F ortran ', ' LL LL P ackage ', ' LL M anager ', ' LLLLLL ', ' LL ', ' LL               LLLLL LLL ', ' LL     LLLLLL     LL  L  LL ', ' LL    LL     L    LL  L  LL ', ' LL    LL     L    LL  L  LL ', ' LL    LLLLLLL     LL  L  LL ', ' LL ', ' LL ', ' LL ', ' ', ' ', ' Program: fpm(1)                                     ', ' Description: A Fortran package manager and build system ', ' Version: 0.3.0, alpha                               ', ' License: MIT                                        ', ' Home Page: https://github.com/fortran-lang/fpm        ', ' '] Source Code program version use M_attr , only : attr , attr_update , attr_mode ! shows a limitation if periods are replaced with spaces the CHAR= option does not ! count the colored blanks so if no text after the blanks too much padding is appended to the line ! need to count last character with a background attribute or something different implicit none integer :: i !nvfortran bug!character(len=*),parameter :: text(*)= [character(len=132) :: & character ( len =* ), parameter :: text ( 23 ) = [ character ( len = 132 ) :: & '<E><e>                                                     ' ,& '<E><e>        <C>                                   </W><E><end>' ,& '<E><e>        <C>      LLL        </C><E> <bo><w>F</bo>ortran   </w></E><C>       <E><e></bo><end>' ,& '<E><e>        <C>     LL LL       </C><E>  <bo><w>P</bo>ackage  </w></E><C>       <E><e></bo><end>' ,& '<E><e>        <C>     LL          </C><E>   <bo><w>M</bo>anager </w></E><C>       <E><e></bo><end>' ,& '<E><e>        <C>   LLLLLL                          <E><end>' ,& '<E><e>        <C>     LL                            <E><end>' ,& '<E><e>        <C>     LL               LLLLL LLL    <E><end>' ,& '<E><e>        <C>     LL     LLLLLL     LL  L  LL   <E><end>' ,& '<E><e>        <C>     LL    LL     L    LL  L  LL   <E><end>' ,& '<E><e>        <C>     LL    LL     L    LL  L  LL   <E><end>' ,& '<E><e>        <C>     LL    LLLLLLL     LL  L  LL   <E><end>' ,& '<E><e>        <C>           LL                      <E><end>' ,& '<E><e>        <C>           LL                      <E><end>' ,& '<E><e>        <C>           LL                      <E><end>' ,& '<E><e>        <C>                                   <E><end>' ,& '<E><e>                                                     ' ,& '<E><bo><b>Program:</b><w>     fpm(1)                                     ' ,& '<E><bo><b>Description:</b><w> A Fortran package manager and build system ' ,& '<E><bo><b>Version:</b><w>     0.3.0, alpha                               ' ,& '<E><bo><b>License:</b><w>     MIT                                        ' ,& '<E><bo><b>Home Page:</b><w>   https://github.com/fortran-lang/fpm        ' ,& '<E><bo>' ] ! add custom keywords call attr_update ( 'end' , '.' , ' ' ) call attr_mode ( manner = 'plain' ) write ( * , '(a)' )( attr ( trim ( text ( i )), chars = 80 ), i = 1 , size ( text )) call attr_update ( 'end' , '.' , char ( 0 )) call attr_mode ( manner = 'color' ) write ( * , '(a)' )( attr ( trim ( text ( i )), chars = 80 ), i = 1 , size ( text )) end program version","tags":"","loc":"program/version.html"},{"title":"fancy – M_attr","text":"Uses iso_fortran_env M_attr Contents Variables help_list_dash help_list_nodash i text Subroutines paws Source Code fancy Variables Type Attributes Name Initial character(len=256), parameter :: help_list_dash (*) = [character(len=256)::' F ortran Package M anager: ', ' ', ' build [ --compiler COMPILER_NAME ] [ --profile PROF ] [ --flag FFLAGS ] [ --list ]', ' ', ' help [ NAME(s) ]                       ', ' ', ' new NAME [[ --lib | --src ] [ --app ] [ --test ] [ --example ]]|', ' [ --full | --bare ][ --backfill ]', ' ', ' update [ NAME(s) ] [ --fetch-only ] [ --clean ] [ --verbose ]', ' ', ' list [ --list ]', ' ', ' run [[ --target ] NAME(s) [ --example ][ --profile PROF ] [ --flag FFLAGS ] [ --all ]', ' [ --runner \"CMD\" ] [ --compiler COMPILER_NAME ] [ --list ] [-- ARGS ]', ' ', ' test [[ --target ] NAME(s) ] [ --profile PROF ] [ --flag FFLAGS ] [ --runner \"CMD\" ]', ' [ --list ] [ --compiler COMPILER_NAME ] [-- ARGS ]', ' ', ' install [ --profile PROF ] [ --flag FFLAGS ] [ --no-rebuild ] [ --prefix PATH ] ', ' [ OPTIONS ]', ' '] character(len=256), parameter :: help_list_nodash (*) = [character(len=256)::' F ortran P ackage M anager: ', ' ', ' USAGE: fpm [ SUBCOMMAND [ SUBCOMMAND_OPTIONS ] ]| [ --list | --help | --version ]', ' ', ' where SUBCOMMAND is commonly one of new | build | run | test but may be any of', ' ', ' build Compile the package placing results in the \"build\" directory', ' help Display help                                                ', ' list Display this list of subcommand descriptions                ', ' new Create a new Fortran package directory with sample files    ', ' run Run the local package application programs                  ', ' test Run the test programs                                       ', ' update Update and manage project dependencies                      ', ' install Install project                                             ', ' ', ' Enter \" fpm --list \" for a brief list of subcommand options. Enter', ' \" fpm --help \" or \" fpm SUBCOMMAND --help \" for detailed descriptions.', ' ', ' Note: color mode is controlled by the environment variable FPM_COLOR. The', ' set of allowable values is { always,never,auto }. The default is \" auto \". ', ' '] integer :: i character(len=*), parameter :: text (22) = [character(len=132)::' ', ' ', ' LLL F ortran ', ' LL LL P ackage ', ' LL M anager ', ' LLLLLL ', ' LL ', ' LL               LLLLL LLL ', ' LL     LLLLLL     LL  L  LL ', ' LL    LL     L    LL  L  LL ', ' LL    LL     L    LL  L  LL ', ' LL    LLLLLLL     LL  L  LL ', ' LL ', ' LL ', ' LL ', ' ', ' ', ' Program: fpm(1)                                     ', ' Description: package manager and build system for Fortran', ' Version: 0.3.0, alpha                               ', ' License: MIT                                        ', ' Home Page: https://github.com/fortran-lang/fpm        '] Subroutines subroutine paws () Arguments None Source Code program fancy use , intrinsic :: iso_fortran_env , only : stderr => ERROR_UNIT , stdin => INPUT_UNIT , stdout => OUTPUT_UNIT use M_attr , only : attr , attr_update , attr_mode implicit none integer :: i character ( len = 256 ), parameter :: help_list_nodash ( * ) = [ character ( len = 256 ) :: & !'<clear>', & '<E><w><b><bo>F</bo>ortran <bo>P</bo>ackage <bo>M</bo>anager:</b>' , & '<E><w>                                                                        ' , & '<E><w><bo>USAGE: <r><un>fpm</un></r><w> [ <r><un>SUBCOMMAND</un></r> <w>[<m>SUBCOMMAND_OPTIONS</m><w>] ]|& &<bo>[<g>--list</g><w>|<g>--help</g><w>|<g>--version</g><w>]' , & '<E><w>                                                                        ' , & '<E><w> where <r><un><bo>SUBCOMMAND</bo></un></r> <w>is commonly one of & &<bo><g>new</g><w>|<g>build</g><w>|<g>run</g><w>|<g>test</g></bo> <w>but may be any of' , & '<E><w>                                                                        ' , & '<E><w>  <bo><g>build</g></bo>     <w>Compile the package placing results in the \"build\" directory' , & '<E><w>  <bo><g>help</g></bo>      <w>Display help                                                ' , & '<E><w>  <bo><g>list</g></bo>      <w>Display this list of subcommand descriptions                ' , & '<E><w>  <bo><g>new</g></bo>       <w>Create a new Fortran package directory with sample files    ' , & '<E><w>  <bo><g>run</g></bo>       <w>Run the local package application programs                  ' , & '<E><w>  <bo><g>test</g></bo>      <w>Run the test programs                                       ' , & '<E><w>  <bo><g>update</g></bo>    <w>Update and manage project dependencies                      ' , & '<E><w>  <bo><g>install</g></bo>   <w>Install project                                             ' , & '<E><w>                                                                        ' , & '<E><w> <bo>Enter \"<r><un>fpm</un></r> <g>--list</g><w></bo>\" for a brief list of subcommand options. Enter' , & '<E><w> \"<bo><r><un>fpm</un></r> <g>--help</g></bo><w>\" or & &\"<bo><r><un>fpm</un> <un>SUBCOMMAND</un></r> <g>--help</g><w></bo>\" for detailed descriptions.' , & '<E><w>                                                                        ' , & '<E><w> <bo>Note:</bo> color mode is controlled by the environment variable FPM_COLOR. The' , & '<E><w>       set of allowable values is {<g><bo>always,never,auto</bo></g><w>}. The default is \"<g><bo>auto</bo></g><w>\". ' , & '<E><w> ' ] character ( len = 256 ), parameter :: help_list_dash ( * ) = [ character ( len = 256 ) :: & !'<clear>', & '<E><w><b><bo>F</bo>ortran </bo>P</bo>ackage <bo>M</bo>anager:</b>' , & '<E><w>                                                           ' , & '<E><w> <bo><g>build</g><w> [<g>--compiler</g> <m>COMPILER_NAME</m><w>] & &[<g>--profile</g> <m>PROF</m><w>] [<g>--flag</g> <m>FFLAGS</m><w>] [<g>--list</g><w>]' , & '<E><w>                                                           ' , & '<E><w> <bo><g>help</g><w> [<r><un>NAME(s)</un></r><w>]                       ' , & '<E><w>                                                           ' , & '<E><w> <bo><g>new</g><w> <r><un>NAME</un></r><w> [[<g>--lib</g><w>|<g>--src</g><w>] [<g>--app</g><w>] & &[<g>--test</g><w>] [<g>--example</g><w>]]|' , & '<E><w> <bo>         [<g>--full</g><w>|<g>--bare</g><w>][<g>--backfill</g><w>]' , & '<E><w>                                                           ' , & '<E><w> <bo><g>update</g><w> <w>[<r><un>NAME(s)</un></r><w>] [<g>--fetch-only</g><w>] [<g>--clean</g><w>] [<g>--verbose</g><w>]' , & '<E><w>                                                           ' , & '<E><w> <bo><g>list</g><w> [<g>--list</g><w>]' , & '<E><w>                                                           ' , & '<E><w> <bo><g>run</g><w>  [[<g>--target</g><w>] <r><un>NAME(s)</un></r> <w>[<g>--example</g><w>]& &[<g>--profile</g><w> <m>PROF</m><w>] [<g>--flag</g><w> <m>FFLAGS</m><w>] [<g>--all</g><w>]' , & '<E><w> <bo>     [<g>--runner</g><w> <m>\"CMD\"</m><w>] [<g>--compiler</g><w> <m>COMPILER_NAME</m><w>] & &[<g>--list</g><w>] [-- <m>ARGS</m><w>]' , & '<E><w>                                                           ' , & '<E><w> <bo><g>test</g><w> [[<g>--target</g><w>] <r><un>NAME(s)</un></r><w>] [<g>--profile</g><w> <m>PROF</m><w>] & &[<g>--flag</g><w> <m>FFLAGS</m><w>] [<g>--runner</g><w> <m>\"CMD\"</m><w>]' , & '<E><w> <bo>     [<g>--list</g><w>] [<g>--compiler</g><w> <m>COMPILER_NAME</m><w>] [-- <m>ARGS</m><w>]' , & '<E><w>                                                           ' , & '<E><w> <bo><g>install</g><w> [<g>--profile</g><w> <m>PROF</m>] [<g>--flag</g><w> <m>FFLAGS</m>] & &[<g>--no-rebuild</g><w>] [<g>--prefix</g><w> <m>PATH</m><w>] ' , & '<E><w> <bo>        <w>[<m>OPTIONS</m><w>]' , & '<E><w> ' ] ! shows a limitation if periods are replaced with spaces the CHAR= option does not ! count the colored blanks so if no text after the blanks too much padding is appended to the line ! need to count last character with a background attribute or something different !nvfortran bug!character(len=*),parameter :: text(*)= [character(len=132) :: & character ( len =* ), parameter :: text ( 22 ) = [ character ( len = 132 ) :: & '<E><e>                                                     ' ,& '<E><w><bo>       <C>                                   </C><E></bo>' ,& '<E><w><bo>       <C>      LLL   </C><bo><B><w> F</bo>ortran   </B><C>            </bo><W> <e></C><E>' ,& '<E><w><bo>       <C>     LL LL  </C><bo><B><w>  P</bo>ackage  </B><C>            </bo><W> <e></C><E>' ,& '<E><w><bo>       <C>     LL     </C><bo><B><w>   M</bo>anager </B><C>            </bo><W> <e></C><E>' ,& '<E><w><bo>       <C>   LLLLLL                          <W> <E></bo>' ,& '<E><w><bo>       <C>     LL                            <W> <E></bo>' ,& '<E><w><bo>       <C>     LL               LLLLL LLL    <W> <E></bo>' ,& '<E><w><bo>       <C>     LL     LLLLLL     LL  L  LL   <W> <E></bo>' ,& '<E><w><bo>       <C>     LL    LL     L    LL  L  LL   <W> <E></bo>' ,& '<E><w><bo>       <C>     LL    LL     L    LL  L  LL   <W> <E></bo>' ,& '<E><w><bo>       <C>     LL    LLLLLLL     LL  L  LL   <W> <E></bo>' ,& '<E><w><bo>       <C>           LL                      <W> <E></bo>' ,& '<E><w><bo>       <C>           LL                      <W> <E></bo>' ,& '<E><w><bo>       <C>           LL                      <W> <E></bo>' ,& '<E><w><bo>       <C>                                   <W> <E></bo>' ,& '<E><w><bo>        <W>                                   <E></bo><e>   ' ,& '<E><bo><b>Program:</b><w>     fpm(1)                                     ' ,& '<E><bo><b>Description:</b><w> package manager and build system for Fortran' ,& '<E><bo><b>Version:</b><w>     0.3.0, alpha                               ' ,& '<E><bo><b>License:</b><w>     MIT                                        ' ,& '<E><bo><b>Home Page:</b><w>   https://github.com/fortran-lang/fpm        ' ] call attr_mode ( manner = 'color' ) write ( * , '(a)' )( attr ( trim ( help_list_nodash ( i )), chars = 80 ), i = 1 , size ( help_list_nodash )) call paws () write ( * , '(a)' )( attr ( trim ( help_list_dash ( i )), chars = 80 ), i = 1 , size ( help_list_dash )) call paws () ! add custom keywords call attr_mode ( manner = 'plain' ) write ( * , '(a)' )( attr ( trim ( text ( i )), chars = 80 ), i = 1 , size ( text )) call paws () call attr_mode ( manner = 'color' ) write ( * , '(a)' )( attr ( trim ( text ( i )), chars = 80 ), i = 1 , size ( text )) call paws () contains subroutine paws () character ( len = 1 ) :: letter integer :: ios write ( stdout , '(a)' , advance = 'no' , iostat = ios ) 'Enter [RETURN] to continue ...' read ( * , '(a)' , iostat = ios ) letter write ( stdout , '(a)' ) attr ( '<clear>' ) flush ( unit = stdout , iostat = ios ) end subroutine paws end program fancy","tags":"","loc":"program/fancy.html"},{"title":"demo_update – M_attr","text":"Uses M_attr Contents Source Code demo_update Source Code program demo_update use M_attr , only : attr , attr_update write ( * , '(a)' ) attr ( '<clear>TEST CUSTOMIZATIONS:' ) ! add custom keywords call attr_update ( 'blink' , char ( 27 ) // '[5m' ) call attr_update ( '/blink' , char ( 27 ) // '[25m' ) write ( * , * ) write ( * , '(a)' ) attr ( '<blink>Items for Friday</blink>' ) call attr_update ( 'ouch' , attr ( & ' <R><bo><w>BIG mistake!</R></w> ' )) write ( * , * ) write ( * , '(a)' ) attr ( '<ouch> Did not see that coming.' ) write ( * , * ) write ( * , '(a)' ) attr ( & 'ORIGINALLY: <r>Apple</r>, <b>Sky</b>, <g>Grass</g>' ) ! delete call attr_update ( 'r' ) call attr_update ( '/r' ) ! replace (or create) call attr_update ( 'b' , '<<<<' ) call attr_update ( '/b' , '>>>>' ) write ( * , * ) write ( * , '(a)' ) attr ( & 'CUSTOMIZED: <r>Apple</r>, <b>Sky</b>, <g>Grass</g>' ) end program demo_update","tags":"","loc":"program/demo_update.html"},{"title":"demo_M_attrape – M_attr","text":"Uses M_attr Contents Subroutines printstuff Source Code demo_M_attrape Subroutines subroutine printstuff () Arguments None Source Code program demo_M_attrape use M_attr , only : attr , attr_mode , attr_update write ( * , '(a)' ) attr ( '<clear>TEST DEFAULTS:' ) call printstuff () write ( * , '(a)' ) attr ( 'TEST MANNER=PLAIN:' ) call attr_mode ( manner = 'plain' ) call printstuff () write ( * , '(a)' ) attr ( 'TEST MANNER=RAW:' ) call attr_mode ( manner = 'raw' ) call printstuff () write ( * , '(a)' ) attr ( 'TEST MANNER=VT102:' ) call attr_mode ( manner = 'vt102' ) call printstuff () write ( * , '(a)' ) attr ( 'TEST ADDING A CUSTOM SEQUENCE:' ) call attr_update ( 'blink' , char ( 27 ) // '[5m' ) call attr_update ( '/blink' , char ( 27 ) // '[25m' ) write ( * , '(a)' ) attr ( '<blink>Items for Friday</blink>' ) contains subroutine printstuff () write ( * , '(a)' ) attr ( '<r>RED</r>,<g>GREEN</g>,<b>BLUE</b>' ) write ( * , '(a)' ) attr ( '<c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y>' ) write ( * , '(a)' ) attr ( '<w>WHITE</w> and <e>EBONY</e>' ) write ( * , '(a)' ) attr ( 'Adding <bo>bold</bo>' ) write ( * , '(a)' ) attr ( '<bo><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></bo>' ) write ( * , '(a)' ) attr ( '<bo><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y></bo>' ) write ( * , '(a)' ) attr ( '<bo><w>WHITE</w> and <e>EBONY</e></bo>' ) write ( * , '(a)' ) attr ( 'Adding <ul>underline</ul>' ) write ( * , '(a)' ) attr ( '<bo><ul><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><w>WHITE</w> and <e>EBONY</e></ul></bo>' ) write ( * , '(a)' ) attr ( 'Adding <ul>italic</ul>' ) write ( * , '(a)' ) attr ( '<bo><ul><it><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></it></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><it><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</it></y></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><it><w>WHITE</w> and <e>EBONY</e></ul></bo>' ) write ( * , '(a)' ) attr ( 'Adding <in>inverse</in>' ) write ( * , '(a)' ) attr ( '<in><bo><ul><it><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></it></ul></bo></in>' ) write ( * , '(a)' ) attr ( '<in><bo><ul><it><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</it></y></ul></bo></in>' ) write ( * , '(a)' ) attr ( '<in><bo><ul><it><w>WHITE</w> and <e>EBONY</e></ul></bo></in>' ) end subroutine printstuff end program demo_M_attrape","tags":"","loc":"program/demo_m_attrape.html"},{"title":"demo_dump – M_attr","text":"Uses M_attr Contents Source Code demo_dump Source Code program demo_dump use M_attr , only : attr write ( * , '(a)' , advance = 'no' ) attr ( '<dump>' ) end program demo_dump","tags":"","loc":"program/demo_dump.html"},{"title":"demo_fmt – M_attr","text":"Uses M_attr Contents Variables output Source Code demo_fmt Variables Type Attributes Name Initial character(len=:), allocatable :: output Source Code program demo_fmt use :: M_attr , only : fmt implicit none character ( len = :), allocatable :: output output = fmt ( 10 , \"'[',i0,']'\" ) write ( * , * ) 'result is ' , output output = fmt ( 1 0.0 / 3.0 , \"'[',g0.5,']'\" ) write ( * , * ) 'result is ' , output output = fmt (. true ., \"'The final answer is [',g0,']'\" ) write ( * , * ) 'result is ' , output end program demo_fmt","tags":"","loc":"program/demo_fmt.html"},{"title":"position – M_attr","text":"Uses M_attr Contents Source Code position Source Code program position use M_attr , only : attr write ( * , '(a)' ) attr ( '<clear><B><w><bo><CSI>12;36f Good Morning! ' ) end program position","tags":"","loc":"program/position.html"},{"title":"demo_M_attr – M_attr","text":"Uses M_attr Contents Variables expanded ios line Source Code demo_M_attr Variables Type Attributes Name Initial character(len=:), allocatable :: expanded integer :: ios character(len=1024) :: line Source Code program demo_M_attr use M_attr , only : attr , attr_mode , attr_update implicit none character ( len = 1024 ) :: line character ( len = :), allocatable :: expanded integer :: ios write ( * , '(a)' )& & attr ( 'The most common attributes and their defaults keywords:         ' ),& & attr ( '     colors:                                                    ' ),& & attr ( '       <r>r</r>,         red,       <R>R</R>,  RED              ' ),& & attr ( '       <g>g</g>,         green,     <G>G</G>,  GREEN            ' ),& & attr ( '       <b>b</b>,         blue,      <B>B</B>,  BLUE             ' ),& & attr ( '       <m>m</m>,         magenta,   <M>M</M>,  MAGENTA          ' ),& & attr ( '       <c>c</c>,         cyan,      <C>C</C>,  CYAN             ' ),& & attr ( '       <y>y</y>,         yellow,    <Y>Y</Y>,  YELLOW           ' ),& & attr ( '       <e>e</e>,         ebony,     <E>E</E>,  EBONY            ' ),& & attr ( '       <w>w</w>,         white,     <W>W</W>,  WHITE            ' ),& & attr ( '     attributes:                                                ' ),& & attr ( '       <it>it</it>,        italic                               ' ),& & attr ( '       <bo>bo</bo>,        bold                                 ' ),& & attr ( '       <un>un</un>,        underline                            ' ),& & attr ( '     other:                                                     ' ),& & attr ( '       clear                                                    ' ),& & attr ( '       attr,       escape                                       ' ),& & attr ( '       default                                                  ' ),& & attr ( '       gt                                                       ' ),& & attr ( '       clear                                                    ' ),& & attr ( '     dual-value (one for color, one for mono):                  ' ),& & attr ( '       <ERROR>ERROR                                             ' ),& & attr ( '       <WARNING>WARNING                                         ' ),& & attr ( '       <INFO>INFO                                               ' ),& & attr ( '' ) write ( * , '(a)' ) attr ([ character ( len = 80 ) :: & '<e><W>This is an array of strings      ' , & '<r>red</r>, <g>green</g>, <b>blue</b>' , & '<c>cyan</c>, <m>magenta</m>, <y>yellow</y>' , & '<un>underline</un>' , & '       ' , & '       ' , & '       ' ]) ! read stdin and run it through M_attr::attr to display color ! write as plain text call attr_mode ( manner = 'raw' ) call attr_mode ( manner = 'plain' ) call attr_mode ( manner = 'color' ) !call attr_mode(manner='dump') call attr_update ( 'Z' , char ( 27 ) // '[1m' ) line = '' write ( * , '(a)' )& & attr ( '<y><B>WELCOME:</B></y> enter text to have it assigned attributes' ),& & attr ( '     Like <lt>W<gt><lt>r<gt>Red text on a White background      ' ),& & attr ( '' ) do read ( * , '(a)' , iostat = ios ) line expanded = attr ( trim ( line )) write ( * , '(a)' ) expanded if ( ios . ne . 0 ) exit enddo write ( * , '(a)' , advance = 'no' ) attr ( '<reset>' ) end program demo_M_attr","tags":"","loc":"program/demo_m_attr~3.html"},{"title":"demo_attr_mode – M_attr","text":"Uses M_attr Contents Variables i lines outlines Source Code demo_attr_mode Variables Type Attributes Name Initial integer :: i character(len=:), allocatable :: lines (:) character(len=:), allocatable :: outlines (:) Source Code program demo_attr_mode use M_attr , only : attr , attr_mode implicit none character ( len = :), allocatable :: lines (:) character ( len = :), allocatable :: outlines (:) integer :: i lines = [ character ( len = 110 ) :: & & '<M><y>' ,& & '<M><y>  Suffice it to say that black and white are also colors' ,& & '<M><y>  for their simultaneous contrast is as striking as that ' ,& & '<M><y>  of green and red, for instance. & & --- <y><bo>Vincent van Gogh</bo></y>' ,& & ' ' ] outlines = attr ( lines , chars = 57 ) write ( * , '(a)' )( trim ( outlines ( i )), i = 1 , size ( outlines )) call attr_mode ( manner = 'plain' ) ! write as plain text write ( * , '(a)' ) attr ( lines ) call attr_mode ( manner = 'raw' ) ! write as-is write ( * , '(a)' ) attr ( lines ) call attr_mode ( manner = 'ansi' ) ! return to default mode end program demo_attr_mode","tags":"","loc":"program/demo_attr_mode.html"},{"title":"demo_alert – M_attr","text":"Uses M_attr Contents Variables X Source Code demo_alert Variables Type Attributes Name Initial real :: X Source Code program demo_alert use M_attr , only : alert , attr , attr_mode implicit none real X call attr_mode ( manner = 'plain' ) call attr_mode ( manner = 'color' ) call alert ( \"error\" , \"Say you didn't!\" ) call alert ( \"warn\" , \"I wouldn't if I were you, Will Robinson.\" ) call alert ( \"info\" , \"I fixed that for you, but it was a bad idea.\" ) call alert ( \"debug\" , \"Who knows what is happening now?.\" ) call alert ( \"???    \" , \"not today you don't\" ) ! call to just update the macros call alert () ! conventional call to ATTR(3f) using the ALERT(3f)-defined macros write ( * , * ) attr ( '<bo>The year was <g><YE></g>, the month was <g><MO></g>' ) ! optional arguments X = 21 1.3 call alert ( 'error' , 'allowed range of X is 0 <lt> X <lt> 100, X=<r>' , X ) ! up to twenty values are allowed of intrinsic type call alert ( 'info' , 'values are<g>' , 10 , 23 4.567 , cmplx ( 1 1.0 , 2 2.0 ), 12 3.456d0 , '</g>today' ) end program demo_alert","tags":"","loc":"program/demo_alert.html"},{"title":"demo_M_attr – M_attr","text":"Uses M_attr Contents Source Code demo_M_attr Source Code program demo_M_attr use M_attr , only : attr , attr_mode , attr_update write ( * , '(a)' ) attr ( 'TEST MANNER=DEFAULT:' ) write ( * , '(a)' ) attr ( '<r>RED</r>,<g>GREEN</g>,<b>BLUE</b>' ) write ( * , '(a)' ) attr ( '<c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y>' ) write ( * , '(a)' ) attr ( '<w>WHITE</w> and <e>EBONY</e>' ) write ( * , '(a)' ) attr ( 'Adding <bo>bold</bo>' ) write ( * , '(a)' ) attr ( '<bo><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></bo>' ) write ( * , '(a)' ) attr ( '<bo><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y></bo>' ) write ( * , '(a)' ) attr ( '<bo><w>WHITE</w> and <e>EBONY</e></bo>' ) write ( * , '(a)' ) attr ( 'Adding <ul>underline</ul>' ) write ( * , '(a)' ) attr ( '<bo><ul><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</y></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><w>WHITE</w> and <e>EBONY</e></ul></bo>' ) write ( * , '(a)' ) attr ( 'Adding <ul>italic</ul>' ) write ( * , '(a)' ) attr ( '<bo><ul><it><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></it></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><it><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</it></y></ul></bo>' ) write ( * , '(a)' ) attr ( '<bo><ul><it><w>WHITE</w> and <e>EBONY</e></ul></bo>' ) write ( * , '(a)' ) attr ( 'Adding <in>inverse</in>' ) write ( * , '(a)' ) attr ( '<in><bo><ul><it><r>RED</r>,<g>GREEN</g>,<b>BLUE</b></it></ul></bo></in>' ) write ( * , '(a)' ) attr ( '<in><bo><ul><it><c>CYAN</c>,<m>MAGENTA</g>,<y>YELLOW</it></y></ul></bo></in>' ) write ( * , '(a)' ) attr ( '<in><bo><ul><it><w>WHITE</w> and <e>EBONY</e></ul></bo></in>' ) end program demo_M_attr","tags":"","loc":"program/demo_m_attr~4.html"},{"title":"runtest – M_attr","text":"Uses M_msg M_verify M_testsuite_M_attr Contents Source Code runtest Source Code program runtest use M_msg use M_verify , only : unit_check_command , unit_check_keep_going , unit_check_level , unit_check_stop use M_testsuite_M_attr unit_check_command = '' unit_check_keep_going = . true . unit_check_level = 0 call test_suite_M_attr () call unit_check_stop end program runtest","tags":"","loc":"program/runtest.html"}]}